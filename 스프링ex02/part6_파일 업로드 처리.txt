파일 업로드 처리
대부분의 웹 프로젝트는 사용자가 첨부파일을 추가할 수 있는 기능이 있다.
초기에는 단순히 <form> 태그를 이용해서 첨부파일을 게시물 작성과 같은 시점에 처리하는 방식을 사용했지만,
최근에는 첨부파일을 별도로 업로드해서 사용자가 최종적으로 게시물을 등록하기 전에 자신이 어떤 파일을 업로드하는지 알 수 있는 방식을 사용한다.

첨부파일에 대한 처리는 흔히 업로드가 전부라고 생각하지만, 현실적으로 업로드된 이후에 처리가 상당히 복잡하다.
예를 들어 이미지 파일의 경우에는 화면에 작은 섬네일(Thumbnail) 이미지를 생성해서 보여주어야 하고, 일반 파일의 경우에는 첨부파일이 존재한다는
아이콘만을 보여주어야 한다. 또한 이미지의 경우는 대부분 클릭해서 원본 이미지를 확인 할 수 있게 하지만, 반면에 일반의 경우에는 단순히 다운로드만을 처리해야 한다.

파일 업로드 방식

첨부파일을 서버에 전송하는 방식은 크게 <form> 태그를 이용해서 업로드하는 방식과 Ajax를 이용하는 방식으로 나눌수 있다.
브라우저 상에서 첨부파일에 대한 처리는 주로 다음과 같은 방식들을 이용하는 경우가 대부분이다.

º <form> 태그를 이용하는 방식 : 브라우저의 제한이 없어야 하는 경우에 사용
 - 일반적으로 페이지 이동과 동시에 첨부파일을 업로드하는 방식
 - <iframe>을 이용해서 화면의 이동 없이 첨부파일을 처리하는 방식

º Ajax를 이용하는 방식: 첨부파일을 별도로 처리하는 방식
 - <inpu type='file'>을 이용하고 Ajax로 처리하는 방식
 - HTML5의 Drag And Drop 기능이나 jQuery 라이브러리를 이용해서 처리하는 방식

브라우저 상에서 첨부파일을 퍼리하는 방식은 다양하게 있지만, 서버 쪽에서의 처리는 거의 대부분 비슷하다.
응답을 HTML 코드로 하는지 아니면 JSON 등으로 처리하는지 정도의 구분만 하면 된다. 

서버에서 주의해야 하는 점은 첨부파일의 처리를 위해서 어떤 종류의 라이브러리나 API등을 활용할 것인지에 대한 부분이다.
서버에서 첨부파일을 처리하는 방식은 크게 다음과 같은 API들을 활용한다.

º cos.jar: 2002년도 이후에 개발이 종료되었으므로, 더 이상 사용하는 것을 권장하지 않는다.
º commons-fileupload: 가장 일반적으로 많이 활용되고, 서블릿 스펙 3.0 이전에도 사용가능
º 서블릿 3.0 이상 - 3.0 이상부터는 자체적인 파일 업로드 처리가 API 상에서 지원

위의 방식에서 가장 일반적인 형태는 commons-fileupload를 이용한 설정이지만, Tomcat 7버전 이후에는 서블릿 3.0 이상을 지월하므로, 예제에서는 이를 활용하는 방식으로
설정해서 사용하겠다.
첨부파일은 실제 서버가 동작하는 머신 내에 있는 폴더에 업로드 시켜야 하므로 C 드라이브 밑에 upload 폴더와 임시 업로드 파일을 저장할 temp폴더를 생성한다.
(c드라이브에 upload폴더 생성 그 안에 temp폴더 생성)

스프링의 첨부파일을 위한 설정

예제를 위해 'ex05'프로젝트를 Spring Legacy Project로 생성하고 생성된 프로젝트의 pom.xml의 일부는 버전을 변경한다.

예제) ex04의 pom.xml복사 붙여넣기

web.xml을 이용하는 경우의 첨부파일 설정
프로젝트가 web.xml을 이용하는 경우라면 첨부파일의 처리에 대한 설정 역시 web.xml을 이용해서 처리한다.
Spring Legucy Project로 생성된 경우에는 서블릿 버전은 2.5버전이므로 이를 수정하는 작업이 필요하다.

web.xml의 상단에 XML 네임스페이스가 2.5 버전으로 설정을 찾아서 수정한다.

예제) web.xml 설정하기 
	xmlns="http://xmlns.jcp.org/xml/ns/javaee"
	xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
	id="WebApp_ID" version="3.1">

	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
		
		<multipart-config>
			<location>C:\\upload\\temp</location>
			<max-file-size>20971520</max-file-size> <!-- 1MB * 20 -->
			<max-request-size>41943040</max-request-size><!-- 40MB -->
			<file-size-threshold>20971520</file-size-threshold><!-- 20MB -->
		</multipart-config>
		
<multipart-config>의 설정은 특정 사이즈의 메모리 사용(file-size-threshold), 업로드되는 파일을 저장할 공간(location)과 업로드되는 파일의 최대 크기(max-file-size)와 
한번에 올릴 수 있는 최대 크기(max-request-size)를 지정할 수 있다.

web.xml의 설정은 WAS(Tomcat) 자체의 설정일 뿐이고, 스프링에서 업로드 처리는 MultipartResolver라는 타입의 객체를 빈으로 등록해야만 가능하다.
Web과 관련된 설정이므로 servlet-context.xml을 이용해서 설정한다.

예제) servlet-context.xml bean MultipartResolver 추가

<beans:bean id="multipartResolver" 
	class="org.springframework.web.multipart.support.StandardServletMultipartResolver">
	</beans:bean>


<form> 방식의 파일 업로드
서버상에서 첨부파일의 처리는 컨트롤러에서 이루어지므로, 실습을 위해 UploadController를 작성한다.

UploadController는 GET방식으로 첨부파일을 업로드할 수 있는 화면을 처리하는 메서드와 POST방식으로 첨부파일 업로드를 처리하는 메서드를 추가한다.

예제) UploadController 생성
package org.zerock.controller;

import java.io.File;
import java.io.IOException;


import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.multipart.MultipartFile;

import lombok.extern.log4j.Log4j;

@Controller
@Log4j
public class UploadController {
	
	@GetMapping("/uploadForm")
	public void uploadForm() {
		
		log.info("upload form");
	}


}

 
UploadController에는 클래스 선언부에 @RequestMapping이 적용되지 않았으므로, WEB-INF/views 폴더에 uploadForm.jsp를 생성한다.

예제) uploadForm.jsp 생성
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>


<form action="uploadFormAction" method="post" enctype="multipart/form-data">

	<input type="file" name="uploadFile" multiple>
	<button>Submit</button>
</form>
</body>
</html>

uploadForm.jsp는 간단하게 <form> 태그만을 생ㅅ어하고 <input type='file'>을 추가한다.
실제 전송은 uploadFormAction 경로를 이용해서 처리한다.
파일 업로드에서 가장 신경써야 하는 부분은 enctype의 속성값을 'multipart/form-data'로 지정하는 것이다.
<input type='file'>의 경우 최근 브라우저에서 'multiple'이라는 속성을 지원하는 데 이를 이용하면 하나의 <input> 태그로
한꺼번에 여러 개의 파일을 업로드할 수 있다.
#<form> 태그의 enctype 속성은 폼 데이터(form data)가 서버로 제출될 때 해당 데이터가 인코딩되는 방법을 명시합니다. 
이 속성은 <form> 요소의 method 속성값이 “post”인 경우에만 사용할 수 있습니다.

multiple 속성은 브라우저의 버전에 따라 지원 여보가 달라지므로 IE의 경우 10 이상에서만 사용할 수 있다.

MutipartFile 타입
스프링 MVC에는 MultipleFile 타입을 제공해서 업로드 되는 파일 데이터를 쉽게 처리할 수 있다. 
위의 <input type='file' name = 'uploadFile'>의 name 속성으로 변수를 지정해서 처리한다.

예제) UploadController uploadFormPost 메서드 가
	
@PostMapping("/uploadFormAction")
	public void uploadFormPost(MultipartFile[] uploadFile, Model model) throws IOException {
		
		// 향상된 for문 배열만큼 loop
		for (MultipartFile multipartFile : uploadFile) {
			
			 MultipartFile 인터페이스의 메서드들
			log.info("-------------------------------------------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			log.info("Upload File getName: " + multipartFile.getName());//String getName() 파라미터 이름<input> 태그의 이름
			log.info("Upload File isEmpty: " + multipaMultipartFilertFile.isEmpty());// 파일이 존재하지 않는 경우 true
			log.info("Upload File getBytes: " + multipartFile.getBytes());// byte[]로 파일 데이터 반환
			log.info("Upload File getInputStream: " + multipartFile.getInputStream()); // 파일데이터와 연결된 inputStream을 반환
		}
	}

파일 처리는 스프링에서 제공하는 MultipartFile이라는 타입을 이용한다.
화면에서 첨부파일을 여러 개 선택할 수 있으므로 배열 타입으로 설정한 후 업로드 해 본다.

결과 페이지(uploadFormAction.jsp)를 작성하지 않아 404에러가 뜨지만 Log.info보면 정상적으로 호출되는 것을 확인할 수 있다.

IE의 경우는 getOriginalFilename()의 결과가 조금 다르게 파일의 이름이 나오지 않고, 전체 경로가 출력된다.
IE까지 같이 처리하려면 마지막에 경로까지 잘라낸 문자만을 취해야 하는데, 이에 대한 처리는 Ajax 처리 시 알아보도록 한다.
MultipartFile은 다음과 같은 메서들을 가지고 있다.

String getName() : 파라미터의 이름<input> 태그의 이름
String getOriginalFileName() : 업로드되는 파일의 이름
boolean isEmpty() : 파일이 존재하지 않는 경우 true
long getSize() : 업로드되는 파일의 크리
byte[] getBytes() : byte[]로 파일 데이터 번환
inputStream getInputStream() : 파라미터와 연결된 inputStream을 반환
transferTo(file, file) : 파일의 저장

파일 저장 
업로드되는 파일을 저장하는 방법은 간단히 transferTo()르 ㄹ이용해서 처리할 수 있다.

예제) UploadController 수정
	@PostMapping("/uploadFormAction")
	public void uploadFormPost(MultipartFile[] uploadFile, Model model) throws IOException {

		String uploadFolder = "C:\\upload";
		
		// 향상된 for문 아래는 형식
	//	for(타입 변수 : 배열)
		for (MultipartFile multipartFile : uploadFile) {
			
			log.info("-------------------------------------------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			
			File saveFile = new File(uploadFolder, multipartFile.getOriginalFilename());
			
			try {
				multipartFile.transferTo(saveFile); // 파일의 저장 MultipartFile 인터페이스의 메소드
			} catch (Exception e) {
				log.error(e.getMessage());
			}//end catch
		}// end for
	}

tranferTo()의 파라미터로는 java.io.File의 지정하면 되기 때문에 업로드는 원래 파일의 이름으로 C드라이브 upload 폴더에 저장된다.
파일 저장에는 파일 이름이 한글인 문제부터 여러 문제가 있다.
Ajax를 먼저 보고 나중에 처리

Ajax를 이용하는 파일 업로드
첨부파일을 업로드하는 또 다른 방식은 Ajax를 이용해서 파일 데이터만을 전송하는 방식이다.
Ajax를 이용하는 첨부파일 처리는 FormData라는 객체를 이용하는 IE의 경우 10 이후의 버전부터 지원듸므로 브라우저에 제약이 있을 수 있다.

UploadController에 GET방식으로 첨부파일을 업로드하는 페이지를 제작한다.

예제) uploadController uploadAjax()추가

@GetMapping("/uploadAjax")
	public void uploadAjax() {
		
		log.info("upload ajax");
	}

WEB-INF/views uploadAjax.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h1>Upload with Ajax</h1>
	
	<div class="uploadDiv">
		<input type="file" name="uploadFile" multiple>
	</div>
	
	<button id="uploadBtn">Upload</button>

	<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
	  
	<script type="text/javascript">
		
		$(document).ready(function () {
			
			$("#uploadBtn").on("click", function(e) {
				
				var formData = new FormData();
				
				var inputFile = $("input[name='uploadFile']");
				
				var files = inputFile[0].files;
				
				
				console.log(files);
				
		
			});
		});
	</script>
</body>
</html>

uploadAjax.jsp는 순수한 JavaScript를 이용해서 처리할 수도 있지만, jQuery를 이용해서 처리하는 것이 편리하다.
uploadAjax.jsp내에 jQuery 라이브러리 경로를 추가하고(jQuerry cdn으로 검색하면 쉽게 링크를 찾을 수 있다.)

jQuery를 이용하는 경우에 파일 업로드는 FormData라는 객체를 이용하게 된다.(브라우저의 제약이 있어 주의)
FormData는 쉽게 말해서 가상의 <form> 태그와 같다고 생각하면 된다.
Ajax를 이용하는 파일 업로드는 FormData를 이용해서 필요한 파라미터를 담아서 전송하는 방식이다.

jQuery를 이용한 첨부파일 전송
Ajax를 이용해서 첨부파일을 전송하는 경우 가장 중요한 객체는 FormData 타입의 객체에 각 파일 데이터를 추가하는 것과 이를 Ajax로 전송할 때 약간의 옵션이 붙어야 한다.

예제) uploadAjax.jsp 수정

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h1>Upload with Ajax</h1>
	
	<div class="uploadDiv">
		<input type="file" name="uploadFile" multiple>
	</div>
	
	<button id="uploadBtn">Upload</button>

	<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
	  
	<script type="text/javascript">
		
		$(document).ready(function () {
			
			$("#uploadBtn").on("click", function(e) {
				
				var formData = new FormData();
				
				var inputFile = $("input[name='uploadFile']");
				
				var files = inputFile[0].files;
				
				console.log(inputFile);
				console.log(files);
				
				// add File Data to formData
				for (var i = 0; i < files.length; i++) {
					
					formData.append("uploadFile", files[i]);
				}
				
				$.ajax({
					url: '/uploadAjaxAction',
					processData: false,
					contentType: false,
					data: formData,
					type: 'POST',
					success: function(result){
						alert("Uploaded");
					}
				}); // $.ajax
			});
		});
	</script>
</body>
</html>

첨부파일 데이터는 fileData를 formData에 추가한 뒤에 Ajax를 통해서 formData 자체를 전송한다.
이때 processData와 contentType은 반드시 'false'로 지정해야만 전송되므로 주의해야 한다.
UploadController에서는 기존과 동일하게 MultipartFile타입을 이용해서 데이터를 처리한다.

예제) UploadController uploadAjaxPost() 추가
@PostMapping("/uploadAjaxAction")
	public void uploadAjaxPost(MultipartFile[] uploadFile) {
		
		log.info("update ajax post.....");
		
		String uploadFolder = "C:\\upload";
		
		for(MultipartFile multipartFile : uploadFile) {
			
			log.info("----------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			
			String uploadFileName = multipartFile.getOriginalFilename();
			
			// IE has file path
			uploadFileName = uploadFileName.substring(uploadFileName.lastIndexOf("\\") + 1);
			
			log.info("only file name : " + uploadFileName);
			
			File saveFile = new File(uploadFolder, uploadFileName);
			
			try {
				multipartFile.transferTo(saveFile);
			} catch (Exception e) {
				// TODO: handle exception
				log.error(e.getMessage());
			} // end catch
			
		}// end for
	}

uploadAjaxPost()는 기존의 <form> 태그를 이용하던 방식과 아무런 차이가 없지만,
조금 뒤에 Ajax 방식으로 결과 데이터를 전달하면서 리턴 타입이 달라지도록 한다.
파라미터에서는 Ajax 방식을 이용하기 때문에 Model을 사용할 일이 없으므로 사용하지 않습니다.
IE의 경우에는 전체 파일 경로가 전송되므로, 마지막 '\'을 기준으로 잘라낸 문자열이 실제 파일 이름이 된다.

브라우저를 이용해서 '/uploadAjax'에서 정상적으로 첨부파일이 업로드가 되는지 확인한다.
예제는 첨부파일의 처리를 Ajax를 이용할 것이므로 지금까지의 문제점 등을 파악하고 해결해 나가는 방식으로 진행한다.

파일 업로드에서 고려해야 하는 점들
첨부파일을 서버에 전송하고 저장하는 일은 그다지 복잡한 일은 아니지만, 생각해야 하는 일들이 많다.

- 동일한 이름으로 파일이 업로드 되었을 때 기존 파일이 사라지는 문제
- 이미지 파일의 경우에는 원본 파일의 용량이 큰 경우 섬네일 이미지를 생성해야 하는 문제
- 이미지 파일과 일반 파일을 구분해서 다운로드 혹은 페이지에서 조회하도록 처리하는 문제
- 첨부파일 공격에 대비하기 위한 업로드 파일의 혹장자 제한


파일 업로드 상세처리

파일의 확장자나 크기의 사전 처리
최근 포털에서도 특정한 확장자를 제외한 파일들의 업로드를 제한하는 경우가 많은데, 이는 첨부파일을 이용하는 웹 공격을 막기 위해서 행해지는 조치이다.
예제는 첨부파일의 확장자가 'exe, sh, zip'등의 경우에는 업로드를 제한하고, 특정 크기 이상의 파일은 업로드할 수 없도록 제한하는 처리를 JavaScript로 처리한다.
파일 확장자의 경우 정규 표현식을 이용해서 검사할 수 있다.

uploadAjax.jsp에 파일의 확장자와 크기를 설정하고, 이를 검사하는 함수 checkExtension()을 작성해서 적용하면 아래와 같은 형태가 된다.
예제) uploadAjax.jsp checkExtension() 함수 추가


			var regex = new RegExp("(.*?)\.(exe|sh|zip|akz)$");
			var maxSize = 5242880; //5MB
			
			function checkExtension(fileName, fileSize) {
				
				if (regex.test(fileName)) {
					alert("해당 종류의 파일은 업로드할 수 없습니다.");
					return false;
				}
				
				if (fileSize >= maxSize) {
					alert("파일 사이즈 초과");
					return false;
				}
				
			
				return true;
			}

			$("#uploadBtn").on("click", function(e) {
				
				var formData = new FormData();
				
				var inputFile = $("input[name='uploadFile']");
				
				var files = inputFile[0].files;
				
				console.log(files);
				
				// add File Data to formData
				for (var i = 0; i < files.length; i++) {
					
					if (!checkExtension(files[i].name, files[i].size)) {
						return false;
					}
					
					formData.append("uploadFile", files[i]);
				}
				
				$.ajax({
					url: '/uploadAjaxAction',
					processData: false,
					contentType: false,
					data: formData,
					type: 'POST',
					dataType :'json',
					success: function(result){

						alert("Uploaded");
					
				}); // $.ajax
			});


첨부파일을 업로드하면 for 루프에서 checkExtension()을 호출해서 확장자와 파일의 크기를 체크하게 된다.

중복된 이름의 첨부파일 처리
첨부파일을 저장할 때 신경 쓰이는 것은 크게 두 가지로 
1) 중복된 이름의 파일 처리와
2) 한 폴더 내에 너무 많은 파일의 생성 문제

1)의 경우는 현재 시간을 밀리세컨드(천분의 1초 단위)까지 구분해서 파일 이름을 생성해서 저장하거나 UUID를 이용해서 중복이 발생할 가능성이 거의 없는 문자열을 생성해서 처리한다.
2)의 경우는 하나의 폴더에 생성될 수 있는 파일의 개수에 대한 문제인데, 한 폴더에 너무 많은 파일이 있는 경우 속도의 저하와 개수의 제한 문제가 생기는 것을 방지해야 한다.
   이에 대한 해결책으로 일반적인 방법은 '년/월/일'단위의 폴더를 생성해서 파일을 저장하는 것이다.

년/월/일 폴더의 생성
첨부파일을 보관하는 폴더를 생성하는 작업은 한 번에 폴더를 생성하거나 존재하는 폴더를 이용하는 방식을 사용한다. 
java.io.File에 존재하는 mkdirs()를 이용하면 필요한 상위 폴더까지 한 번에 생성할 수 있으므로 간단히 처리할 수 있다.

UploadController에 추가적인 메서드와 수정을 통해서 업로드 폴더 등을 처리하도록 한다.

예제) UploadController getFolder() 메소드 추가
	// 날짜 포맷
	private String getFolder() {
		
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		
		Date date = new Date();
		
		String str = sdf.format(date);
		
		return str.replace("-", File.separator);
	}
	
	@PostMapping( "/uploadAjaxAction")
	public void uploadAjaxPost(MultipartFile[] uploadFile) {
		
		
		String uploadFolder = "C:\\upload";
		
		
		// make folder --------
		File uploadPath = new File(uploadFolder, getFolder());
		log.info("upload path: " + uploadPath);
		
		
		
		if (uploadPath.exists() == false) {
			uploadPath.mkdirs();
		}
		// make yyyy/MM/dd folder
		
		for(MultipartFile multipartFile : uploadFile) {
			
			
			
			log.info("----------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			
			String uploadFileName = multipartFile.getOriginalFilename();
			
			// IE has file path
			uploadFileName = uploadFileName.substring(uploadFileName.lastIndexOf("\\") + 1);
			
			log.info("only file name : " + uploadFileName);
			
			
			//p.509 폴더생성으로 경로 변경 주석처리
			//File saveFile = new File(uploadFolder, uploadFileName);
			File saveFile = new File(uploadPath, uploadFileName);
			
			try {
				
				multipartFile.transferTo(saveFile);
				
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			} // end catch
			
		}// end for
		
	}

getFolder()는 오늘 날짜의 경로를 문자열로 생성한다. 생성된 경로는 폴더 경로로 수정된 뒤에 반환한다.
uploadAjaxPost()에서는 해당 경로가 있는지 검사하고, 폴더를 생성한다.
이후 생성된 폴더로 파일을 저장하게 한다. 
위와 같이 폴더를 생성한 후 기존과 달리 uploadPath 경로에 파일을 저장하게 되면 자동으로 폴더가 생성되면서 파일이 저장되는 것을 볼 수 있다.

중복 방지를 위한 UUID 적용
파일 이름을 생성할 때 동일한 이름으로 업로드되면 기존 파일을 지우게 되므로 java.util.UUID의 값을 이용해서 처리한다.

예제) UploadController uploadAjaxPost() UUID 적용

	@PostMapping( "/uploadAjaxAction")
	public void uploadAjaxPost(MultipartFile[] uploadFile) {
		
		
		String uploadFolder = "C:\\upload";
		
		
		// make folder --------
		File uploadPath = new File(uploadFolder, getFolder());
		log.info("upload path: " + uploadPath);
		
		
		
		if (uploadPath.exists() == false) {
			uploadPath.mkdirs();
		}
		// make yyyy/MM/dd folder
		
		for(MultipartFile multipartFile : uploadFile) {
			
			
			
			log.info("----------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			
			String uploadFileName = multipartFile.getOriginalFilename();
			
			// IE has file path
			uploadFileName = uploadFileName.substring(uploadFileName.lastIndexOf("\\") + 1);
			
			log.info("only file name : " + uploadFileName);
			
			// 중복 방지를 위한 UUID 적용
			UUID uuid = UUID.randomUUID();
			
			uploadFileName = uuid.toString() + "_" + uploadFileName;

			//p.509 폴더생성으로 경로 변경 주석처리
			//File saveFile = new File(uploadFolder, uploadFileName);
			File saveFile = new File(uploadPath, uploadFileName);
			
			try {
				
				multipartFile.transferTo(saveFile);
				
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			} // end catch
			
		}// end for
		
	}

첨부파일은 randomUUID()를 이용해서 임의의 값을 생성한다. 생성된 값은 원래의 파일 이름과 구분할 수 있도록 중간에 '_'를 추가한다.


나중에 앞에서부터 '_'를 기준으로 분리하면 원래의 파일 이름을 파악할 수 있따.

이제 첨부파일을 업로드하면 UUID가 생성된 파일이 생기므로, 원본 이름과 같더라도 다른 이름의 파일로 생성되는 것을 확인할 수 있다.

섬네일 이미지 생성
이미지의 경로에 대한 처리와 중복 이름에 대한 처리가 완료되었다면, 남은 작업은 일반 파일과 이미지 파일을 구분하는 것이다.
이미지 파일의 경우에는 화면에 보여지는 작은 이미지(이하 섬네일)를 생성하는 추가적인 처리이다.
만일 용량이 큰 파일을 섬네일 처리하지 않는다면 모바일과 같은 환경에서 많은 데이터를 소비해야만 하므로 이미지의 경우는 특별한 경우가 아니라면 섬네일을 제작해야만 한다.

섬네일을 제작하는 방법은 여러 가지 방식이 있다. 
JDK1.4부터는 ImageI.O를 제공하기 때문에 이를 이용해서 원본 이미지의 크기를 줄일 수 도 있고, ImgScalr와 같은 별도의 라이브러리를 이용하는 방식도 있다.
JDK에 포함된 API를 이용하는 방식보다는 별도의 라이브러리를 사용하는 경우가 많은데, 이는 이미지를 축소햇을 때의 크기나 해상도를 직접 조절하는 작업을 줄이기 위해서이다.
예제에서는 Thumbnailator 라이브러리를 이용해서 섬네일 이미지를 생성한다.
(https://github.com/coobird/thumbnailator)

maven 저장소에서 Thumbnailator 라이브러리를 검색해서 pom.xml에 추가한다.

예제) pom.xml에 thumbnailator 라이브러리 추가
<!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator -->
		<dependency>
		    <groupId>net.coobird</groupId>
		    <artifactId>thumbnailator</artifactId>
		    <version>0.4.8</version>
		</dependency>

UploadController에서는 다음고 같은 단계를 이용해서 섬네일을 생성한다.

- 업로드된 파일이 이미지 종류의 파일인지 확인
- 이미지 파일의 경우에는 섬네일 이미지 생성 및 저장

이미지 파일의 판단
화면에서 약간의 검사를 통해서 업로드되는 파일의 확장자를 검사하기는 하지만, Ajax로 사용하는 호출은 반드시 브라우저만을 통해서 들어오는 것이 아니므로 확인할 필요가 있다.
서버에 업로드된 파일은 조금 시간이 걸리더라도 파일 자체가 이미지인지를 정확히 체크한 뒤에 저장하는 것이 좋다.

특정한 파일이 이미지 타입인지를 검사하는 별도의 checkImageType() 메서드를 추가한다.

예제) UploadController checkImageType() 메서드 추가
// 특정한 파일이 이미지 타입인지 검사하는 checkImageType() 메소드
	private boolean checkImageType(File file) {
		
		try {
			String contentType = Files.probeContentType(file.toPath());
			
			return contentType.startsWith("image");
		} catch (IOException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		return false;
	}

만일 이미지 타입이라면 섬네일을 생성하도록 코드를 수정

예제) UploadController uploadAjaxPost() 섬네일 생성하도록 코드수정

	@PostMapping( "/uploadAjaxAction")
	public void uploadAjaxPost(MultipartFile[] uploadFile) {
		
		
		String uploadFolder = "C:\\upload";
		
		
		// make folder --------
		File uploadPath = new File(uploadFolder, getFolder());
		log.info("upload path: " + uploadPath);
		
		
		
		if (uploadPath.exists() == false) {
			uploadPath.mkdirs();
		}
		// make yyyy/MM/dd folder
		
		for(MultipartFile multipartFile : uploadFile) {
			
			
			
			log.info("----------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			
			String uploadFileName = multipartFile.getOriginalFilename();
			
			// IE has file path
			uploadFileName = uploadFileName.substring(uploadFileName.lastIndexOf("\\") + 1);
			
			log.info("only file name : " + uploadFileName);
			
			// 중복 방지를 위한 UUID 적용
			UUID uuid = UUID.randomUUID();
			
			uploadFileName = uuid.toString() + "_" + uploadFileName;

			//p.509 폴더생성으로 경로 변경 주석처리
			//File saveFile = new File(uploadFolder, uploadFileName);
		
			
			try {
				File saveFile = new File(uploadPath, uploadFileName);				

				multipartFile.transferTo(saveFile);
				if (checkImageType(saveFile)) {
					
					
					FileOutputStream thumnail = new FileOutputStream(new File(uploadPath, "s_" + uploadFileName));
					
					Thumbnailator.createThumbnail(multipartFile.getInputStream(), thumnail, 100, 100);
					
					thumnail.close();
				}
				
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			} // end catch
			
		}// end for
		
	}

Thumbnailator는 InputStream과 Java.io.File 객체를 이용해서 파일을 생성할 수 있고, 뒤에 사이즈에 대한 부분을 파라미터로 width와 height를 지정할 수 있다.

이제 /uploadAjax를 이용해서 이미지 파일을 업로드하면 원본 파일은 그대로 저장되고, 파일 이름이 's_'로 시작하는 섬네일 파일이 생성되는 것을 볼 수 있다.
반면에 일반 파일의 경우는 그냥 파일만 업로드되는 것을 볼 수 있다.

업로드된 결과를 보면 이미지 파일의 경우에는 앞에 's_'로 시작하는 것을 확인할 수 있다.

업로드된 파일의 데이터 반환
첨부파일 데이터의 업로드가 완료되었지만, 아직도 많은 작업이 남아있다.
Ajax를 이용해서 파일을 업로드했지만, 아직 브라우저 쪽에 아무런 데이터도 전달하지 않았기 때문에 브라우저에서는 어떠한 피드백도 받을 수 없는 상황이다.

서버에서 Ajax의 결과로 전달해야 하는 데이터는 업로드된 파일의 경로가 포함된 파일의 이름이다. 섬네일의 경우에는 's_'로 시작한다는 규칙만 알고 있으면 필요할 때 사용할 수 있다.

브라우저로 전송해야 하는 데이터는 다음과 같은 정보를 포함하도록 설계해야 한다.
- 업로드된 파일의 이름과 원본 파일의 이름
- 파일이 저장된 경로
- 업로드된 파일이 이미지인지 아닌지에 대한 정보

이에 대한 모든 정보를 처리하는 방법은
1) 업로드된 경로가 포함된 파일 이름을 반환하는 방식
2) 별도의 객체를 생성해서 처리하는 방법

1)의 경우에는 브라우저 쪽에서 해야하는 일이 많기 때문에 
2)의 방식으로 구성하도록 한다.

예제)pom.xml에 jackson-databind 관련 라이브러리를 추가한다.
		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
		<dependency>
		    <groupId>com.fasterxml.jackson.core</groupId>
		    <artifactId>jackson-databind</artifactId>
		    <version>2.9.6</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml -->
		<dependency>
		    <groupId>com.fasterxml.jackson.dataformat</groupId>
		    <artifactId>jackson-dataformat-xml</artifactId>
		    <version>2.9.6</version>
		</dependency>
		
AttachFileDTO 클래스
org.zerock.domain 패키지에 첨부파일의 정보들을 저장하는 AttachFileDTO 클래스를 작성
예제) AttachFileDTO 생성
package org.zerock.controller;

import lombok.Data;

@Data
public class AttachFileDTO {
	
	private String fileName;		// 파일 이름
	private String uploadPath;		// 파일 경로
	private String uuid;			// uuid값
	private boolean image; 			// 이미지 여부
}

AttachFileDTO 클래스에는 원본 파일의 이름(fileName), 업로드 경로 (uploadPath), UUID값(uuid), 이미지 여부(image)정보를 하나로 묶어서 전달하는 용도로 사용한다.

UploadController는 AttachFileDTO의 리스트를 반환하는 구조로 변경해야 한다.

예제) UploadController uploadAjaxPost() 함수 수정
@PostMapping(value = "/uploadAjaxAction",
				produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
		@ResponseBody
	public ResponseEntity<List<AttachFileDTO>> uploadAjaxPost(MultipartFile[] uploadFile) {
		
		
		log.info("update ajax post.....");
		
		List<AttachFileDTO> list = new ArrayList<AttachFileDTO>();
		String uploadFolder = "C:\\upload";
		
		String uploadFolderPath = getFolder();
		// make folder --------
		File uploadPath = new File(uploadFolder, getFolder());
		log.info("upload path: " + uploadPath);
		log.info("upload path: " + uploadPath.exists());
		
		
		if (uploadPath.exists() == false) {
			uploadPath.mkdirs();
		}
		// make yyyy/MM/dd folder
		
		for(MultipartFile multipartFile : uploadFile) {
			
			AttachFileDTO attachDTO = new AttachFileDTO();
			
			log.info("----------------------");
			log.info("Upload File Name: " + multipartFile.getOriginalFilename()); // 업로드되는 파일의 이름
			log.info("Upload File Size: " + multipartFile.getSize());	// 업로드되는 파일의 크기
			
			String uploadFileName = multipartFile.getOriginalFilename();
			
			// IE has file path
			uploadFileName = uploadFileName.substring(uploadFileName.lastIndexOf("\\") + 1);
			
			log.info("only file name : " + uploadFileName);
			attachDTO.setFileName(uploadFileName);
			
			// 중복 방지를 위한 UUID 적용
			UUID uuid = UUID.randomUUID();
			
			uploadFileName = uuid.toString() + "_" + uploadFileName;
			
			//p.509 폴더생성으로 경로 변경 주석처리
			//File saveFile = new File(uploadFolder, uploadFileName);
			
			
			try {
				File saveFile = new File(uploadPath, uploadFileName);
				multipartFile.transferTo(saveFile);
				attachDTO.setUuid(uuid.toString());
				attachDTO.setUploadPath(uploadFolderPath);
				
				if (checkImageType(saveFile)) {
					
					attachDTO.setImage(true);
					
					FileOutputStream thumnail = new FileOutputStream(new File(uploadPath, "s_" + uploadFileName));
					
					Thumbnailator.createThumbnail(multipartFile.getInputStream(), thumnail, 100, 100);
					
					thumnail.close();
				}
				
				// add to List
				list.add(attachDTO);
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			} // end catch
			
		}// end for
		
		return new ResponseEntity<List<AttachFileDTO>>(list, HttpStatus.OK);
	}

uploadAjaxPost()는 기존과 달리 ResponseEntity<List<AttachFileDTO>>를 반환하는 형태로 수정하고, JSON데이터를 반환하도록 변경된다.
내부에서는 각 파일에 맞게 AttachFileDTO를 생성해서 전달하는 구조로 변경된다.

브라우저에서 Ajax 처리
/uploadAjax에서는 결과 데이터를 JavaScript를 이용해서 반환된 정보를 처리하도록 수정한다.
예제) UploadAjax.jsp에 id= uploadBtn 이벤트 수정
				$.ajax({
					url: '/uploadAjaxAction',
					processData: false,
					contentType: false,
					data: formData,
					type: 'POST',
					dataType :'json',
					success: function(result){

						console.log(result);
						
					}
				}); // $.ajax

Ajax를 호출했을 때의 결과 타입(dataType)은 'json'으로 변경하고, 결과를 console.log()로 찍도록 변경한다.
첨부파일을 업로드한 후에는 브라우저에서 결과를 아래와 같이 확인할 수 있다.
console.log 확인 시
fileName, image, uploadPath, uuid 값 확인(AttachFileDTO)필드 값들

브라우저에서 섬네일 처리
브라우저에서 첨부파일의 업로드 결과가 위와 같이 JSON 객체로 반환되었다면, 남은 작업은 다음과 같다
- 업로드 후에 업로드 부분을 초기화 시키는 작업
- 결과 데이터를 이용해서 화면에 섬네일이나 파일 이미지를 보여주는 작업

현재 업로드는 <input type='file'>을 통해서 이루어지기 때문에 한 번 업로드가 끝난 후에는 이를 초기화 시켜주는 작업과 업로드된 결과를 화면에 반영해 줄 필요가 있다.

<input type='file'>의 초기화
<input type='file'>은 다른 DOM 요소들과 조금 다르게 readOnly라 안쪽의 내용을 수정할 수 없기 때문에 별도의 방법으로 초기화 시켜서 또 다른 첨부파일을 추가할 수 있도록 만들어야 한다.

예제) uploadAjax.jsp 추가
	var cloneObj = $(".uploadDiv").clone();
			
			$("#uploadBtn").on("click", function(e) {
				
				var formData = new FormData();

우선 첨부파일을 업로드하기 전에 아무 내용이 없는 <input type='file'>객체가 포함된 <div>를 복사(clone)한다.
첨부파일을 업로드한 뒤에는 복사된 객체를 <div> 내에 다시 추가해서 첨부파일 부분을 초기화 시킨다.

				$.ajax({
					url: '/uploadAjaxAction',
					processData: false,
					contentType: false,
					data: formData,
					type: 'POST',
					dataType :'json',
					success: function(result){

						console.log(result);
						
						
						// 업로드가 완료되면 초기화
						$(".uploadDiv").html(cloneObj.html());
					}
				}); // $.ajax

화면에서 첨부파일을 추가하고 버튼을 클릭하면 이전과 달리 첨부파일을 다시 추가할 수 있는 형태로 변경되는 것을 확인할 수 있다.

업로드된 이미지 처리
업로드도니 결과는 JSON 형태로 받아왔기 때문에 이를 이용해서 화면에 적절한 섬네일을 보여주거나 화면에 파일 아이콘 등을 보여주어서 결과를 피드백해줄 필요가 있다.
Ajax의 처리결과를 보여주도록 수정

파일 이름 출력
uploadAjax.jsp에는 별도의 JavaScript 함수를 추가해서 특정한 <ul> 태그 내에 업로드된 파일의 이름을 보여주도록 한다.

화면에는 <ul> 태그를 작성해서 첨부파일 이름을 목록으로 처리할 수 있도록 준비한다.
예제) uploadAjax.jsp html부분 추가
	<div class="uploadDiv">
		<input type="file" name="uploadFile" multiple>
	</div>
	
	<div class="uploadResult">
		<ul>
		
		</ul>
	</div>

JavaScript에서는 목록을 보여주는 부분을 별도의 함수로 처리한다.
예제) uploadAjax.jsp script 부분 추가

			var uploadResult = $(".uploadResult ul");
			
			function showUploadedFile(uploadResultArr) {
				
				var str = "";
				
				$(uploadResultArr).each(function (i, obj) {
					
					
					str += "<li>" + obj.fileName + "</li>";
					
					
					
				});
				
				uploadResult.append(str);
			}

showUploadFile()은 JSON 데이터를 받아서 해당 파일의 이름을 추가한다.
Ajax결과에서는 받은 JSON 데이터를 showUploadFile()을 호출하도록 수정한다.

예제) uploadAjax.jsp Ajax 수정
				$.ajax({
					url: '/uploadAjaxAction',
					processData: false,
					contentType: false,
					data: formData,
					type: 'POST',
					dataType :'json',
					success: function(result){

						console.log(result);
						
						showUploadedFile(result);
						
						// 업로드가 완료되면 초기화
						$(".uploadDiv").html(cloneObj.html());
					}
				}); // $.ajax

화면에서는 업로드 후에 단순하게 업로드된 파일의 이름들이 보이는 것을 확인할 수 있다.

일반 파일의 파일 처리
첨부파일의 섬네일 이미지를 보여주는 작업은 조금 더 복잡하므로 우선적으로 일반 파일이 업로드된 상황에서 첨부파일의 아이콘 등을 보여주도록 수정한다.

기존의 webapp및에 resources 폴더의 내용을 그대로 추가하고, img 폴더를 생성한다.
일반 첨부파일의 이미지를 보여줄 attach.png 파일을 추가한다.
(이미지는 https://pixabay.com/ko/에서 무료로 다운 가능)

uploadAjax.jsp에서 일반 파일의 경우에는 attach.png 이미지가 보이게 수정한다.
화면에는 약간의 스타일을 적용해서 첨부파일 영역을 처리한다.
예제) uploadAjax.jsp에 <style> 을 만들어 css 처리
<style>
	.uploadResult{
		
		width:100%;
		background-color: gray;
	}
	
	.uploadResult ul{
		
		display: flex;
		flex-flow: row;
		justify-content: center;
		align-items: center
	}
	
	.uploadResult ul li{
		list-style: none;
		padding: 10px;
	}
	
	.uploadResult ul li img {
		width: 20px;
	}
	
</style>

<div class="uploadResult">
		<ul>
		
		</ul>
</div>

			function showUploadedFile(uploadResultArr) {
				
				var str = "";
				
				$(uploadResultArr).each(function (i, obj) {
					
					if (!obj.image) {
						str += "<li><img src='/resources/img/attach1.png'>" + obj.fileName + "</li>";
					}else{
						str += "<li>" + obj.fileName + "</li>";
					
					}
					
				});
				
				uploadResult.append(str);
			}

showUploadedFile()은 이미지 파일이 아닌 경우에 파일 아이콘을 보여주는 형태로 작성된다.

섬네일 이미지 보여주기
일반 파일의 경우에는 단순히 파일 이미지만을 보여주지만 이미지 파일의 경우에는 섬네일 파일을 보여주어야 한다.
섬네일 서버를 통해서 특정 URI를 호출하면 보여줄수 있도록 처리하는데, 해당 파일의 경로와 uuid가 붙은 파일의 이름이 필요하므로 조금 복잡해진다.
서버에서 섬네일은 GET방식을 통해서 가져올 수 있도록 처리한다.
특정한 URI 뒤에 파일 이름을 추가하면 이미지 파일 데이터를 가져와서 <img> 태그를 작성하는 과정을 통해서 처리한다.

서버에 전송하는 데이터는 '파일의 경로 ' + 's_' + 'uuid'가 붙은 파일 이름이다.
이떄 주의해야 하는 항목은 경로나 파일 이름에 한글 혹은 공백 등의 문자가 들어가면 문제가 발생할 수 있으므로 JavaScript의 encodeURIComponent() 함수를 이용해서 URI에 문제가 없는 문자열을 
생성해서 처리한다.

UploadController에서 섬네일 데이터 전송하기
UploadController 에서는 특정한 파일 이름을 받아서 이미지 데이터를 전송하는 코드를 우선 생성한다.

예제) UploadController getFile() 메서드 추가
	// UploadController에서 섬네일 데이터 전송하기
	
	@GetMapping("/display")
		@ResponseBody
	public ResponseEntity<byte[]> getFile(String fileName){
		
		log.info("fileName : " + fileName);
		
		File file = new File("C:\\upload\\" + fileName);
		
		log.info("file : " + file);
		
		ResponseEntity<byte[]> result = null;
		
		try {
			HttpHeaders header = new HttpHeaders();
			
			header.add("Content-Type", Files.probeContentType(file.toPath()));
			result = new ResponseEntity<byte[]>(FileCopyUtils.copyToByteArray(file),header,HttpStatus.OK);
		} catch (IOException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		return result;
	}

getFile()은 문자열로 파일의 경로가 포함된 fileName을 파라미터로 받고 byte[]를 전송한다.
byte[]로 이미지 파일의 데이터를 전송할 때 신경 쓰이는 것은 브라우저에 보여주는 MIME 타입이 파일의 종류에 따라 달라지는 점이다.
이 부분을 해결하기 위해서 probeContentType()을 이용해서 적절한 MIME 타입 데이터를 Http의 헤더 메시지에 포함할 수 있도록 처리한다.

getFile()의 테스트는 upload폴더 밑에 테스트할 수 있는 영문 이름의 파일들을 추가하고, 브라우저에서 http://localhost:8081/display?fileName= 2023/10/24/test3.jpg
와 같이 경로와 파일 이름을 같이 전달해 보이는 방식으로 테스트할 수 있다.

uuid가 있으면 호출할 때 복잡하므로 단순한 이름의 파일을 업로드와 관계된 경로에 추가한다.
테스트를 위해서 확장자가 jpg인 파일들과 png 파일들을 폴더에 넣어둔다.

호출은 '/display?fileName ='뒤에 '년/월/일/파일이름'의 형태로 호출한다.

헤더를 보면 파일의 확장자에 따라서 MIME 타입이 다르게 처리된다.(Contend-Type)

브라우저에서는 올바르게 이미지가 보이고, 파일의 확장자에 맞게 MIME 타입이 변경되는 것을 볼 수있다.

JavaScript 처리
브라우저에서 GET방식으로 첨부파일의 이름을 사용할 떄에는 항상 파일 이름에 포함된 공백 문자나 한글 이름 등이 문제가 될 수 있다.
이를 수정하기 위해서는 encodeURIComponent()를 이용해서 URI 호출에 적합한 문자열로 인코딩 처리해야 한다.
(크롬과 IE 의 경우 서로 다르게 처리되어서 첨부파일에 문제가 있을 수 있기 때문이다.

예제) uploadAjax.jsp showUploadFile() 수정

			function showUploadedFile(uploadResultArr) {
				
				var str = "";
				
				$(uploadResultArr).each(function (i, obj) {
					
					if (!obj.image) {
						str += "<li><img src='/resources/img/attach1.png'>" + obj.fileName + "</li>";
					}else{
					//	str += "<li>" + obj.fileName + "</li>";
					
					var fileCallPath = encodeURIComponent(obj.uploadPath + "/s_"+ obj.uuid+"_"+obj.fileName); -- 공백이나 한글등을 URI 호출에 적합한 문자열로 인코딩하는 펑션
					str += "<li><img src='/display?fileName="+fileCallPath+"'></li>";
					}
					
				});
				
				uploadResult.append(str);
			}


첨부파일의 다운로드 혹은 원본 보여주기

첨부파일의 업로드가 처리되는 과정도 복잡하지만, 이를 사용자가 사용하는 과정 역시 신경 써야 하는 일이 많다.
브라우저에서 보이는 첨부파일은 크게 
1) 이미지 종류와 
2) 일반 파일로 구분되므로 사용자의 첨부파일과 관련된 행위도 종류에 따라 다르게 처리되어야 한다.

만일 첨부파일이 이미지인 경우에는 섬네일 이미지를 클릭했을 때 화면에 크게 원본 파일을 보여주는 형태로 처리되어야 한다.
이 경우 브라우저에서 새로운 <div> 등을 생성해서 처리하는 방식을 이용하는데 흔히 "light-box"라고 한다.
"light-box"는 jQuery를 이용하는 많은 플러그인들이 있으므로, 이를 이용하거나 직접 구현할 수 있다.
예제는 직접 구현하는 방식으로 한다.

첨부파일이 이미지가 아닌 경우에는 기본은 다운로드이다. 사용자가 파일을 선택하면 다운로드가 실행되면서 해당 파일의 이름으로 다운로드가 가능해야 한다.
(한글 이름 처리등이 이슈가 될 수 있다.)

첨부파일의 다운로드

이미지를 처리하기 전에 우선 좀 더 간단한 첨부파일의 다운로드부터 처리하도록 한다.
첨부파일의 다운로드는 서버에서 MIME 타입을 다운로드 타입으로 지정하고, 적절한 헤더 메시지를 통해서 다운로드 이름을 지정하게 처리한다.
이미지와 달리 다운로드는 MIME 타입이 고정되기 때문에 메서드는 아래와 같이 시작하게 된다.

예제) UploadController downloadFile() 메서드 생성

	@GetMapping(value = "/download", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	@ResponseBody
	public ResponseEntity<Resource> downloadFile(@RequestHeader("User-Agent") String userAgent, String fileName){
		
		log.info("download file: " + fileName);
		
		FileSystemResource resource = new FileSystemResource("C:\\upload\\" + fileName);
		
		log.info("resoruce: " + resource);

		return null;
	}

ResponseEntity<>의 타입은 byte[] 등을 사용할 수 있으나, 이번 예제에서는 oreg.springframework.core.io.Resource 타입을 이용해서 좀 더 간단히 처리하도록 한다.

테스트를 위해서 C:\upload 폴더에 영문 파일을 하나 두고, '/download?fileName=파일이름'의 형태로 호출한다.
브라우저에는 아무런 반응이 없지만, 서버에는 로그가 기록되는 것을 먼저 확인한다.

서버에 로그가 기록되는 것을 확인후 서버에서 파일이 정상적으로 인식되었다는 것이 확인되면 ResponseEntity<> 처리한다.
이때 HttpHeaders 객체를 이용해서 다운로드 시 파일의 이름을 처리하도록 한다.

예제) UploadController에 downloadFile() 메서드 추가
@GetMapping(value = "/download", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	@ResponseBody
	public ResponseEntity<Resource> downloadFile( String fileName){
		
		log.info("download file: " + fileName);
		
		Resource resource = new FileSystemResource("C:\\upload\\" + fileName);
		
		log.info("resoruce: " + resource);
		
		
		
		String resourceName = resource.getFilename();
		
		
		HttpHeaders headers = new HttpHeaders();
		
		try {			
			headers.add("Content-Disposition", "attachment; filename=" + new String(resourceName.getBytes("UTF-8),
			"ISO-8859-1"));

		} catch (UnsupportedEncodingException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		
		return new ResponseEntity<Resource>(resource, headers, HttpStatus.OK);
	}

MIME 타입은 다운로드를 할 수 있는 'application/octet-steream'으로 지정하고, 다운로드 시 저장되는 이름은 'Content-Disposition'을 이용해서 지정한다.
파일 이름에 대한 문자열 처리는 파일 이름이 한글인 경우 저장할 때 깨지는 문제를 막기 위해서이다.
크롬 브라우저에서 C:\upload 폴더에 있는 파일의 이름과 확장자로 '/download?fileName=xxx'와 같이 호출하면 브라우저는 자동으로 해당 파일을 다운로드하는 것을 볼 수 있다.
IE 계열에서는 파일 다운로드가 호출이 안되는 문제가 발생한다.

IE/Edge 브라우저의 문제
첨부파일의 다운로드 시 chrome 브라우저와 달리 IE에서는 한글 이름이 제대로 다운로드 되지 않는다.
이것은 'Content-Disposition'의 값을 처리하는 방식이 IE의 경우 인코딩 방식이 다르기 때문이다.

IE를 같이 서비스해야 한다면 HttpServletResquest에 포함된 헤더 정보들을 이용해서 요청이 발생한 브라우저가 IE 계열인지 확인해서 다르게 처리하는 방식으로 처리한다.
HTTP 헤더 메시지 중에서 디바이스의 정보를 알 수 있는 헤더는 'User-Agent' 값을 이용한다.
(이를 이용해서 브라우저의 종류나 모바일인지 데스크톱인지 혹은 브라우저 프로그램의 종류를 구분할 수 있다.)

기존의 downlodFile()은 'User-Agent' 정보를 파라미터로 수집하고, IE에 대한 처리를 추가한다.
Edge 브라우저는 IE와 또 다르게 처리되므로 주의한다.

예제) UploadController downloadFile() 메서드 수정
@GetMapping(value = "/download", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	@ResponseBody
	public ResponseEntity<Resource> downloadFile(@RequestHeader("User-Agent") String userAgent, String fileName){
		
		log.info("download file: " + fileName);
		
		Resource resource = new FileSystemResource("C:\\upload\\" + fileName);
		
		log.info("resoruce: " + resource);
		
		if (resource.exists() == false) {
			log.info("존재하지 않는다.");
			return new ResponseEntity<Resource>(HttpStatus.NOT_FOUND);
		}
		
		String resourceName = resource.getFilename();
		
		
		log.info("다운받을 file 이름 === " + resourceName);
		
		HttpHeaders headers = new HttpHeaders();
		
		try {
			String downloadName = null;
			
			if (userAgent.contains("Trident")) {
				
				log.info("IE browser");
				
				downloadName = URLEncoder.encode(resourceOriginalName, "UTF-8").replace("\\", " ");
			}else if (userAgent.contains("Edge")) {
				
				log.info("Edge browser");
				
				downloadName = URLEncoder.encode(resourceOriginalName, "UTF-8");
				
				log.info("Edge name: " + downloadName);
			}else {
				
				log.info("Chrome browser");
				
				downloadName = new String(resourceOriginalName.getBytes("UTF-8"), "ISO-8859-1");
				log.info("Chrome browser ====  " + downloadName);
			}
			
			headers.add("Content-Disposition", "attachment; filename=" + downloadName);
		} catch (UnsupportedEncodingException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		
		return new ResponseEntity<Resource>(resource, headers, HttpStatus.OK);
	}

downloadFile()은 @RequestHeader를 이용해서 필요한 HTTP 헤더 메시지의 내용을 수집할 수 있다.
이를 이용해서 'User-Agent'의 정보를 파악하고, 값이 'MSIE'혹은 'Trident'(IE 브라우저의 엔진 이름 - IE11처리)인 경우네는 다른 방식으로 처리하도록 한다.

위의 코드가 적용되면 우선은 Chrome에서 한글 파일의 다운로드를 먼저 시도한 후에 인터넷 등을 이용해서 URL 주소로 인코딩 하는 페이지를 이용해서 파일 이름을 변환해 본다.
IE에서 주소창에 한글을 적으면 400에러가 발생한다.
IE에서 테스트를 진행하고 싶다면 URL Encoding 작업을 해야하는데 검색을 통해서 웹페이지를 쉽게 찾을 수 있다.
(URL Encoding 한글을 유니코드로 변경해주는 사이트)


실행 결과를 보면 IE와 Chrome 모두 정상적으로 파일 이름이 반영되는 것을 볼 수 있다.
IE와 비슷해 보이지만 Edge 브라우저에서는 
-userAgent 내에 'Edge'라는 문자열이 있는지 확인
- 다운로드하는 파일 이름에 'ISO-8859-1'인코딩을 적용하지 않는다.

업로드 된 후 다운로드 처리
다운로드 자체에 대한 처리는 완료되었으므로, /uploadAjax 화면에서 업로드된 후 파일 이미지를 클릭한 경우에 다운로드가 될 수 있도록 처리한다.
이미지 파일이 아닌 경우는 첨부파일 아이콘(이미지)이 보이게 된다.

예제) uploadAjax showUploadFile() 함수 수정

function showUploadedFile(uploadResultArr) {
				
				var str = "";
				
				$(uploadResultArr).each(function (i, obj) {
					
					if (!obj.image) {
						// 파일이 이미지가아닐때
						var fileCallPath = encodeURIComponent(obj.uploadPath +"/"+ obj.uuid+"_"+obj.fileName);
						
						// repacle로 경로 \\ 를 /로 변경
						var fileLink = fileCallPath.replace(new RegExp(/\\/g), "/");
						
						str += "<li><a href='/download?fileName="+fileCallPath+"'>"
								+"<img src='/resources/img/attach1.png'>"+obj.fileName+"</a></li>";
					
		
						
					}else{
						//	str += "<li>" + obj.fileName + "</li>";
						// 파일이 이미지일때
						
						var fileCallPath = encodeURIComponent(obj.uploadPath + "/s_"+ obj.uuid+"_"+obj.fileName);
						
					 	
					 	//str += "<li><img src='/display?fileName="+fileCallPath+"'></li>";
					 	
					}
					
					
				});
				
				uploadResult.append(str);
			}


브라우저에서는 <img> 태그를 클릭하게 되면 자동으로 다운로드가 되는 것을 확인할 수 있다.

다운로드가 정상적으로 이루어지는 것을 확인했다면 마지막으로 서버에서 파일 이름에 UUID가 붙은 부분을 제거하고 순순하게 다운로드되는 파일의 이름을 저장될 수 있도록 한다.

예제) UploadController downloadFile() 메서드 수정
	@GetMapping(value = "/download", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	@ResponseBody
	public ResponseEntity<Resource> downloadFile(@RequestHeader("User-Agent") String userAgent, String fileName){
		
		log.info("download file: " + fileName);
		
		Resource resource = new FileSystemResource("C:\\upload\\" + fileName);
		
		log.info("resoruce: " + resource);
		
		if (resource.exists() == false) {
			log.info("존재하지 않는다.");
			return new ResponseEntity<Resource>(HttpStatus.NOT_FOUND);
		}
		
		String resourceName = resource.getFilename();
		
		// remove UUID
		String resourceOriginalName = resourceName.substring(resourceName.indexOf("_")+1);
		
		log.info("다운받을 file 이름 === " + resourceName);
		
		HttpHeaders headers = new HttpHeaders();
		
		try {
			String downloadName = null;
			
			if (userAgent.contains("Trident")) {
				
				log.info("IE browser");
				
				downloadName = URLEncoder.encode(resourceOriginalName, "UTF-8").replace("\\", " ");
			}else if (userAgent.contains("Edge")) {
				
				log.info("Edge browser");
				
				downloadName = URLEncoder.encode(resourceOriginalName, "UTF-8");
				
				log.info("Edge name: " + downloadName);
			}else {
				
				log.info("Chrome browser");
				
				downloadName = new String(resourceOriginalName.getBytes("UTF-8"), "ISO-8859-1");
				log.info("Chrome browser ====  " + downloadName);
			}
			
			headers.add("Content-Disposition", "attachment; filename=" + downloadName);
		} catch (UnsupportedEncodingException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		
		return new ResponseEntity<Resource>(resource, headers, HttpStatus.OK);
	}
	

수정된 부분은 resourceOriginalName을 생성해서 UUID 부분을 잘라낸 상태의 파일 이름으로 저장하도록 하는 것이다.
브라우저에서는 순수한 파일 이름으로 다운로드 되는 것을 확인할 수 있다.

원본 이미지 보여주기
일반 첨부파일과 달리 섬네일이 보여지는 이미지 파일의 경우 섬네일을 클릭하면 원본이미지를 볼 수 있게 처리한다.
섬네일의 이미지가 '업로드된 경로 + /s_ + UUID_ + 파일 이름'이었다면, 원본 이미지의 이름은 중간데 '/s_'가 '/'로 변경되는 점이 다르다.
원본 이미지를 화면에서 보기 위해서는 동적 <div>를 생성(== right-box)하고, 해당 <div>에 이미지 태그를 작성해서 넣어주는 작업과 이를 환면상에서 절대 위치를 이용해서 보여줄 필요가 있다.

원본 이미지를 보여줄 <div> 처리
이미지의 경우 일반 파일과 달리 이미 이미지 파일 데이터는 섬네일과 동일한 방식으로 처리될 수 있기 때문에 사실상 핵심적인 부분은 이미지를 보여주는 <div>를 처리하는 부분이 핵심이다.

<div>를 처맇는 부분은 섬네일 파일을 클릭할 때 이루어 지도록 JavaScript 함수를 작성한다.

예제) uploadAjax showImage() 메서드 추가
	function showImage(fileCallPath){
		
			alert(fileCallPath);
				
		}

showImage() 함수는 jQuery의 $(document).ready()의 바깥쪽에 작성한다.
이렇게 하는 이유는 나중에 <a> 태그에서 직접 showImage()를 호출할 수 있는 방식으로 작성하기 위해서다.

섬네일 이미지를 보여주도록 처리하는 JavaScript 코드에서는 섬네일의 클릭시 showImage()가 호출될 수 있는 코드를 추가

예제) showUploadFile() showImage() 호출 코드 추가
function showUploadedFile(uploadResultArr) {
				
				var str = "";
				
				$(uploadResultArr).each(function (i, obj) {
					
					if (!obj.image) {
						// 파일이 이미지가아닐때
						var fileCallPath = encodeURIComponent(obj.uploadPath +"/"+ obj.uuid+"_"+obj.fileName);
						

						
						str += "<li><a href='/download?fileName="+fileCallPath+"'>"
								+"<img src='/resources/img/attach1.png'>"+obj.fileName+"</li>";
					
						
					}else{
						//	str += "<li>" + obj.fileName + "</li>";
						// 파일이 이미지일때
						
						var fileCallPath = encodeURIComponent(obj.uploadPath + "/s_"+ obj.uuid+"_"+obj.fileName);
						
						var originPath = obj.uploadPath + "\\"+ obj.uuid + "_" + obj.fileName;
						
					 	originPath = originPath.replace(new RegExp(/\\/g), "/")
					 	
					 	str += "<li><a href=\"javascript:showImage(\'"+originPath+"\')\"><img src='/display?fileName="+fileCallPath+"'></li>";
					 	
					}
					
					
				});
				
				uploadResult.append(str);
			}

이미지 첨부파일의 경우 업로드된 경로와 UUID가 붙은 파일의 이름이 필요하기 때문에 originPath라는 변수를 통해서 하나의 문자열로 생성한다.
생성된 문자열은 \ 기호 때문에 일반 문자열과는 다르게 처리되므로, '/'로 변환한 뒤 showImage()에 파라미터로 전달한다.

브라우저에서는 파일 업로드 이후에 섬네일을 클릭하면 showImage()가 호출되는 것을 alert로 확인할 수 있다.

CSS 와 HTML 처리

예제) uploadAjax.jsp에 실제 원본 이미지를 보여주는 tag 추가

html  -

<div class="bigPictureWrapper">
		<div class="bigPicture">
		</div>
	</div>

css - 
	<style>
	.uploadResult{
		
		width:100%;
		background-color: gray;
	}
	
	.uploadResult ul{
		
		display: flex;
		flex-flow: row;
		justify-content: center;
		align-items: center
	}
	
	.uploadResult ul li{
		list-style: none;
		padding: 10px;
		align-content: center;
		text-align: center;
	}
	
	.uploadResult ul li img {
		width: 20px;
	}
	.bigPictureWrapper{
		position: absolute;;
		display: none;
		justify-content: center;
		align-items: center;
		top : 0%;
		width: 100%;
		height: 100%;
		background-color: gray;
		z-index: 100;
		background: rgba(255,255,255,0.5);
	}
	
	.bigPicture{
		position: relative;
		display: flex;
		justify-content: center;
		align-items: center;
	}
	
	.bigPicture img {
		width: 600px;
	}
	

	</style>


실제 이미지는 '.bigPicture' 안에 <img> 태그를 생성해서 넣게 된다.
이때 CSS의 flex 기능을 이용하면 화면의 정중앙에 배티하는 것은 손쉽게 처리된다.
showImage() 함수에서는 약간의 코드를 이용해서 화면에 원본 이미지를 보여줄 수 있다.

예제) uploadAjax.jsp showImage() 수정
function showImage(fileCallPath){
		
				//alert(fileCallPath);
				
				$(".bigPictureWrapper").css("display", "flex").show();
				
				$(".bigPicture")
				.html("<img src='display?fileName="+ encodeURI(fileCallPath)+ "'>")
				.animate({width:'100%', height:'100%'}, 1000);
			
				
		}

showImage()는 내부적으로 화면 가운데 배치하는 작업 후 <img> 태그를 추가하고, jQuery의 animate()를 이용해서 지정된 시간 동안 화면에서 열리는 효과를 처리한다.

<div> 이벤트 처리
원본 이미지가 보여지는 <div>는 전체 화면을 차지하기 때문에 다시 한번 클릭하면 사라지도록 이벤트 처리를 한다.

			
예제) uploadAjax.jsp
// 화살표 함수는 ES6의 기능이다.
			// Chrome에서는 정상 작동하지만 IE에서는 제대로 동작이 안될수 있어 변경이 필요하다.
			$(".bigPictureWrapper").on("click", function(e) {
				$(".bigPicture").animate({width:'0%', height:'0%'}, 1000);
				setTimeout(() => {
					$(this).hide();
				
				}, 1000);
			});

원본 이미지 혹은 주변 배경을 선택하면 우선은 이미지를 화면 중앙으로 작게 점차 줄여준다.(1초 동안)
jQuery의 애니메이션이 끝난 후 이벤트를 감지하는 방식도 있지만, 
예제는 1초 후에 자동으로 배경창을 안 보이도록 처리하는 방식을 이용한다.

setTimeout()에 적용된 '=>(ES6의 화살표 함수)' Chrome에서는 정상 작동하지만,
IE 11에서는 제대로 동작하지 않으므로 필요하다면 다음의 코드로 내용을 변경해서 사용한다.
// 화살표 함수는 ES6의 기능이다.
			// Chrome에서는 정상 작동하지만 IE에서는 제대로 동작이 안될수 있어 변경이 필요하다.
			$(".bigPictureWrapper").on("click", function(e) {
				$(".bigPicture").animate({width:'0%', height:'0%'}, 1000);
				setTimeout(() => {
				//	$(this).hide();
					$(".bigPictureWrapper").hide();
				}, 1000);
			});

첨부파일 삭제

첨부파일 삭제는 생각보다 많은 고민이 필요한 작업이다. 단순히 파일 하나만을 삭제한다고 생각할 수 있지만 실제로는 다음과 같은 문제점들을 고민해야 한다.
- 이미지 파일의 경우에는 섬네일까지 같이 삭제되어야 하는점

- 파일을 삭제한 후에는 브라우저에서도 섬네일이나 파일 아이콘이 삭제되도록 처리하는 점

- 비정상적으로 브라우저의 종료 시 업로드된 파일의 처리

일반 파일과 이미지 파일의 삭제
업로드된 첨부파일의 삭제는 Ajax를 이용하거나 <form> 태그를 이용하는 방식 모두를 적용할 수 있다.
이미 업로드된 첨부파일의 삭제는 일반 파일의 경우에는 업로드된 파일만을 삭제하면 되지만, 이미지의 경우에는 생성된 섬네일 파일과 원본 파일을 같이 삭제해야 한다.

서버 측에서 삭제하려는 파일의 확장자를 검사해서 일반 파일인지 이미지 파일인지를 파악하거나 파라미터로 파일의 종류를 파악하고, 이를 이용해서 처리를 다르게 한다.

화면에서 삭제 기능

첨부파일이 업로드된 후에 생기는 이미지 파일 옆에 'x' 표시를 추가하돌록 아래와 같이 수정한다.

예제) uploadAjax.jsp
function showUploadedFile(uploadResultArr) {
				
				var str = "";
				
				$(uploadResultArr).each(function (i, obj) {
					
					if (!obj.image) {
						// 파일이 이미지가아닐때
						var fileCallPath = encodeURIComponent(obj.uploadPath +"/"+ obj.uuid+"_"+obj.fileName);
						
						// repacle로 경로 \\ 를 /로 변경
						var fileLink = fileCallPath.replace(new RegExp(/\\/g), "/");
						
						//str += "<li><a href='/download?fileName="+fileCallPath+"'>"
						//		+"<img src='/resources/img/attach1.png'>"+obj.fileName+"</li>";
					
						str += "<li><div><a href='/download?fileName="+fileCallPath+"'>"
						+"<img src='/resources/img/attach1.png'>"+obj.fileName+"</a>" + 
						"<span data-file=\'" + fileCallPath+"\' data-type='file'> x </span>"
						+"</div></li>";
						
						
						
					}else{
						//	str += "<li>" + obj.fileName + "</li>";
						// 파일이 이미지일때
						
						var fileCallPath = encodeURIComponent(obj.uploadPath + "/s_"+ obj.uuid+"_"+obj.fileName);
						
						var originPath = obj.uploadPath + "\\"+ obj.uuid + "_" + obj.fileName;
						
					 	originPath = originPath.replace(new RegExp(/\\/g), "/")
					 	
					 	//str += "<li><a href=\"javascript:showImage(\'"+originPath+"\')\"><img src='/display?fileName="+fileCallPath+"'></li>";
					 	str += "<li><a href=\"javascript:showImage(\'"+originPath+"\')\">"
						+"<img src='/display?fileName="+fileCallPath+"'></a>" + 
						"<span data-file=\'" + fileCallPath+"\' data-type='image'> x </span>"
						+"</li>";
					}
					
					
				});
				
				uploadResult.append(str);
			}

변경된 부분은 <span> 태그를 이용해서 섬네일이나 파일 아이콘 옆에 'x' 표시를 추가한 점과 <span> 태그에 'data-file'과 'data-type' 속성을 추가한 부분이다. 화면을 보면 디자인은 볼품 없지만,
테스트할 수 있도록 만든 'x' 표시가 보인다.

예제) uploadAjax.jsp 'x'표시에 대한 이벤트 처리
$(document).ready(function () {
			
			// 'x' 이미지/일반파일 x표시 클릭이벤트 처리
			$(".uploadResult").on("click","span", function(e) {
				
				var targetFile = $(this).data("file");
				var type = $(this).data("type");
				console.log(targetFile);
				
				$.ajax({
					url : '/deleteFile',
					data:{ fileName: targetFile, type: type},
					dataType : 'Text',
					type: "POST",
						sucecc: function(result) {
							alert(result);
							
						}
				}); // $.Ajax
			});

첨부파일의 삭제는 <spam>태그를 이용해서 처리하지만, 첨부파일의 업로드 후에 생성되기 때문에 '이벤트 위임' 방식으로 처리해야 한다.
이벤트 처리에서는 Ajax를 이용해서 첨부파일의 경로와 이름, 파일의 종류(이미지 혹은 일반)를 전송한다.

서버에서 첨부파일의 삭제
서버 측에서 첨부파일은 전달되는 파라미터의 이름과 종류를 파악해서  처리한다.

예제) UploadController deleteFile ()
// js에서 위임한 파일을 서버에서 위임받아 첨부파일의 삭제
	
	@PostMapping("/deleteFile")
	@ResponseBody
	public ResponseEntity<String> deleteFile(String fileName, String type){
		
		log.info("deleteFile: " + fileName);
		
		File file;
		
		try {
			file = new File("c:\\upload\\" + URLDecoder.decode(fileName, "UTF-8"));
			
			file.delete();
			
			if (type.equals("image")) {
				
				// File클래스에 getAbsolutePath()는 업로드시 파일의 디렉토리 경로와 객체 생성시 만들어졌던 파일경로를 다가지고 온다.
				// 절대경로를 반환하는 getAbsolutePath()
				String largeFileName = file.getAbsolutePath().replace("s_", "");
				
				log.info("largeFileName: " + largeFileName);
				
				file = new File(largeFileName);
				
				file.delete();
			}
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			return new ResponseEntity<String>(HttpStatus.NOT_FOUND);
		}
		
		return new ResponseEntity<String>("delete", HttpStatus.OK);
	}
}

deleteFile()은 브라우저에서 전송하는 파일 이름과 종류를 파라미터로 받아서 파일의 종류에 따라 다르게 동작한다.
브라우저에서 전송되는 파일 이름은 '경로 + UUID + _ + 파일이름'으로  구성되어 있으므로, 일반 파일의 경우에는 파일만 삭제한다.
이미지의 경우 섬네일이 존재하므로, 파일 이름의 중간에 's_'가 들어가 있다.
일반 이미지 파일의 경우 's_'가 없도록 되어 있으므로, 이 부분을 변경해서 원본 이미지 파일도 같이 삭제하도록 처리한다.

첨부파일의 삭제 고민
첨부파일을 삭제하는 작업의 최대 고민은 사용자가 비정상적으로 브라우저를 종료하고 나가는 행위이다.
서버에는 Ajax를 이용해서 업로드했기 때문에 이미 저장이 된 상태지만, 사용자가 '작업 관리자'나 전원 버튼을 누르는 등의 조치를해서 브라우저 자체를 
종료해 버린다면 이를 감지할 수 있는 적당한 방법이 없다.
(브라우저의 창이 닫히는 이벤트는 가능하긴 하지만 비정상적인 종료는 문제가 된다.)

이에 대한 가장 좋은 해결책은 실제 최종적인 결과와 서버에 업로드된 파일의 목록을 비교해서 처리하는 것
이런 작업은 보통 spring-batch나 Quartz 라이브러리를 이용해서 처리한다.
