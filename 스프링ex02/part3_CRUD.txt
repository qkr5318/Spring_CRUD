기본적인 웹 게시물 관리
CRUD (등록, 수정, 삭제, 조회)와 페이징 처리, 검색기능의 게시물 관리 개발

작업의 순서를 어떤식으로 구성하는가에 따라서 소요시간이나 결과물이 다르게 나온다
즉, 단순히 각 기능의 코드가 아닌 작업 순서에 중점을 두고 학습해야한다.

- MVC를 이용하는 웹 프로젝트 전체 구조에 대한 이해
- 개발의 각 단계에 필요한 설정 및 테스트 환경
- 기본적인 등록, 수정, 삭제, 조회, 리스트 구현
- 목록(리스트) 화면의 페이징(paging)처리 
- 검색 처리와 페이지 이동

스프링 MVC 프로젝트의 기본구성

MVC 프로젝트의 구성을 이해야한다.
프로젝트의 구성을 이해해야만 전체 데이터의 흐름을 볼 수 있다. 
브라우저에서 전송한 데이터를 스프링MVC의 어떤 단계를 거쳐서 실행되는지를 이해한다면 
문제가 발생했을 때 빠른 대처와 대안을 찾을 수 있다.

일반적으로 웹 프로젝트는 3-tier 방식으로 구성한다.

Persentation  <--> Business <--> Persistence tier

Persentation Tier(화면 계층)은 화면에 보여주는 기술을 사용하는 영역이다.(Servlet/JSP나 스프링 MVC)

Buisness Tier(비즈니스 계층) 순수한 비즈니스 로직을 담고있는 영역이다.
이 영역이 중요한 이유는 고객이 원하는 요구 사항을 반영하는 계층이기 때문.(Service로직)

Persistence Tier(영속 계층 or 데이터 계층) 데이터를 어떤 방식으로 보관하고, 사용하는가에 대한 설계가 들어가는 계층이다.
일반적인 경우에는 데이터베이스를 많이 이용한다.(myBatis와 myBatis-spring)

스프링 MVC 영역은 Persentation Tier를 구성하게 되는데, 각 영역은 사실 별도의 설정을 가지는 단위로 볼 수 있다. 
화면 영역 담당 설정 파일은 Servlet-context.xml이 담당이다.
스프링의 의존성 주입을 이용해서 객체간의 연관구조를 완성해서 사용한다.

MyBatis 영역(SQL에 대한 처리를 담당하는 구조)은 현실적으로는 myBatis-spring을 이용해서 구성하는 영역이다.  데이터베이스(SQL) 영역 담당 설정 파일은 root-context.xml이 담당

각 여역의 Naming Convention(명명 규칙)
- 프로젝트를 위와 같이 3-tier로 구성하는 가장 일반적인 설명은 '유지 보수'에 대한 필요성 때문이다.
 각 영역은 독립적으로 설계되어 나중에 특정한 기술이 변하더라도 필요한 부분을 전자제품의 부품처럼 쉽게 교환할 수 있게 하는 방식이다.
따라서 각 영역은 설계 당시부터 영역을 구분하고, 해당 연결 부위는 인터페이스를 이용해서 설계하는 것이 일반적인 구성방식이다.

 네이밍 규칙
- xxxController : 스프링 MVC에서 동작하는 Controller 클래스를 설계할 때
- xxxService, xxxServiceImpl : 비즈니스 여역을 담당하는 인터페이스는 service을 사용, 인터페이스를 구현한 클래스는 serviceImpl을 사용한다.
-xxxDAO, xxxRepository : DAO(Data-Access-Object)나 Repository(저장소)라는 이름으로 영역을 따로 구성하는 것이 보편적이다.
-VO, DTO : VO와 DTO는 일반적으로 유사한 의미로 사용하는 용어로, 데이터를 담고 있는 객체를 의미한다. 다만 VO의 경우는 주로 ReadOnly의 목적이 강하고, 데이터 자체도 Immutable(불변)하게 설계 하는것이 정석이다.
DTO는 주로 데이터 수집의 용도가 좀 더 강하다. 로그인하는 정보를 DTO로 처리하는 방식을 사용한다.

패키지 Naming
-config : 프로젝트와 관련된 설정 클래스들의 보관 패키지
- controller : 스프링 MVC의 Controller들의 보관 패키지
- service : 스프링의 Service 인터페이스와 구현 클래스 패키지
- domain : VO, DTO 클래스들의 패키지
- presistence : Mybatis Mapper 인터페이스 패키지 DAO
- exception : 웹 관련 예외처리 패키지
- aop : 스프링의 AOP 관련 패키지 (관점 분리)
- security : 스프링 Security 관련 패키지
- util : 각종 유틸리티 클래스 관련 패키지 
※ package 네이밍은 소문자로 사용

요구사항에 따른 화면 설계 (스토리 보드)
-- 주로 Mock-up(목업) 툴을 이용하는 경우가 많다.
대표적으로 PowerPoint, Balsamiq studio, Pencil Mockup등 
화면을 설계하는 단계에서는 사용자가 입력해야하는 값과 함께 전체 페이지의 흐름이 설계된다.
이 화면이ㅡ 흐름을 URL로 구성하게 되는데 이 경우에는 GET/POST 방식에 대해 같이 생각해야한다.

게시물 화면의 흐름
게시물 -> 등록 -> 결과
      -> 조회 -> 삭제/ 수정 -> 결과

ex02 프로젝트 생성(게시물)
Legacy project에 MVC로 프로젝트 생성하고 pom.xml 수정

스프링 관련된 spring-tx, spring-jdbc, spring-test 라이브러리를 추가

<!-- 스프링 관련된 라이브러리 spring-tx, spring-jdbc, spring-test 추가 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
		<dependency>
		    <groupId>org.springframework</groupId>
		    <artifactId>spring-jdbc</artifactId>
		    <version>${org.springframework-version}</version>
		</dependency>
				
		
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-test -->
		<dependency>
		    <groupId>org.springframework</groupId>
		    <artifactId>spring-test</artifactId>
		    <version>${org.springframework-version}</version>
		</dependency>

Mybatis이용하기 때문에 HikariCP, MyBatis, mybatis-spring, Log4jdbc 라이브러리 추가

		<!-- mybatis관련 라이브러리 HikariCP, Mybatis, mybatis-spring, Log4jdbc -->
		<!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP -->
		<dependency>
		    <groupId>com.zaxxer</groupId>
		    <artifactId>HikariCP</artifactId>
		    <version>2.7.4</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis</artifactId>
		    <version>3.4.6</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis-spring</artifactId>
		    <version>1.3.2</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/org.bgee.log4jdbc-log4j2/log4jdbc-log4j2-jdbc4 -->
		<dependency>
		    <groupId>org.bgee.log4jdbc-log4j2</groupId>
		    <artifactId>log4jdbc-log4j2-jdbc4</artifactId>
		    <version>1.16</version>
		</dependency>

테스트와 Lombok을 위해서 jUit 버전을 변경(나는 4.0)및 추가

		<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
		<dependency>
		    <groupId>org.projectlombok</groupId>
		    <artifactId>lombok</artifactId>
		    <version>1.18.0</version>
		    <scope>1.2.17</scope>
		</dependency>

		<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>  

그리고 plugin maven 버전을 현재 사요하는 자바 버전으로 맞춘다. ${java-version}
그 후 maven update 실행
마직막으로 Oracle JDBC Driver(ojdbc8.jar)를 프로젝트의 BulidPath에 추가하고, DeploymentAssembly에도 추가 

테이블 생성과 Dummy(더미) 데이터 생성
게시물은 각 게시물마다 고유의 번호가 필요하다. 오라클의 경우 시퀀스를 이용해서 이러한 작업을 한다.

create SEQUENCE seq_board;

- 시퀀스를 생성할 때는 데이터 베이스의 다른 오브젝트들과 구분하기 위해서 'seq_'와 같이 시작하는 것이 일반적이다. 

create table tbl_board(
    bno number(10,0),
    title varchar2(200) not null,
    content varchar2(2000) not null,
    writer varchar2(50) not null,
    regdate date default sysdate,
    updatedate date default sysdate
);

- 테이블을 생성할 때는 'tbl_'로 시작하거나 't_'와 같이 구분이 가능한 단어를 아에 붙여주는 것이 좋다.
테이블을 설계할 때는 가능하면 레코드의 생성 시간과 최종 수정 시간을 같이 기록하는 것이 좋기 때문에 생성시간(regdate)와 레코드의 최종 수정 시간(updatedate)칼럼을 만들고 기본값으로
sysdate를 지정해서 레코드가 생성된 시간은 자동으로 기록될 수 있게한다.

alter table tbl_board add CONSTRAINT pk_board primary key (bno);

- 테이블의 생성 이후에는'alter table'을 이용하여 수정을 하는데 테이블에 Primary key(PK)를 지정해 준다. PK를 지정할때 'pk_board'라고 이름을 부여하는데, 이 이름은 뒤에서 중요하게 사용되므로 반드시 의미를 구분할 수 있게 생성해준다.

테스트 데이터 추가
insert into tbl_board (bno, title, content, writer) values (seq_board.nextval, '테스트 제목', '테스트 내용', 'user00'); -- 8번정도 insert후 commit;하셈

- tbl_board에 bno는 매번 새로운 값이 들어가야 하므로 seq_board.nextval을 이용해서 매번 새로운 번호를 얻는다.

오라클 DB는 MySQL과 달리 데이터 작업후 반드시 commit을 수동으로 처리해야 한다. 


- 데이터베이스 관련 설정 및 테스트
root-context.xml에는 mybatis-spring 네임스페이스를 추가하고, PART1에서 작성한 DateSource의 설정과 MyBatis의 설정을 추가

		<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
	<!-- 
		<property name="driverClassName" value = "oracle.jdbc.driver.OracleDriver"></property>
		<property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:orcl"></property>
	-->
		<property name="driverClassName" value ="net.sf.log4jdbc.sql.jdbcapi.DriverSpy"></property>
		<property name="jdbcUrl" value="jdbc:log4jdbc:oracle:thin:@localhost:1521:orcl"></property>
		<property name="username" value="book_ex"></property>
		<property name="password" value="book_ex"></property>
		
	</bean>
	
	<!-- HikariCP configuration -->
	<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
	<constructor-arg ref="hikariConfig"/>
	</bean>
	
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"></property>
	</bean>
	
	<mybatis-spring:scan base-package="org.zelock.mapper"/>


root-context.xml은 내부적으로 Log4jdbc를 이용하는 방식으로 구성되어 있으므로 log4jdbc.log4j2.properties 파일을 추가해준다.

log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator

정상적으로 연결이 되는지 DataSourceTests 클래스와 JDBCTests 클래스를 테스트 패키지에 추가하고
테스트를 통해 확인!


영속/ 비즈니스 계층의 CRUD 구현

영속 계층의 구현 준비
- 거의 모든 웹 애플리케이션의 최종 목적은 데이터베이스에 데이터를 기록하거나, 원하는 데이터를 가져오는 것이 목적이기 때문에
 개발할 때 어느정도의 설계가 진행되면 데이터베이터 관련 작업을 하게된다.

※ Mybatis 자바의 관계형 DB 프로그래밍을 좀더 쉽게 할 수 있게 도와주는 프레임 워크
1) jdbc를 총해 DB에 access 작업을 캡슐화 한다.
2) SQL 쿼리 저장, 프로시져, 및 고급 맵핑을 지원
3) 모든 jdbc 코드밑 매개변수의 중복 제거
4) My batis에서는 프로그램에 있는 sql쿼리들을 한 구성 파일에 구성하여 프로그램 코드와 SQL을 분리 시킨다.

VO 클래스의 작성

예제) boardVO 클래스 생성

package org.zerock.domain;

import java.util.Date;

import lombok.Data;

@Data
public class BoardVO {
	
	private Long bno;
	private String title;
	private String content;
	private String writer;
	private Date regdate;
	private Date updateDate;
}


Mapper 인터페이스와 Mapper XML
myBatis는  SQL을 처리하는데 어노테이션이나 XML을 이용할 수 있다. 
간단한 SQL이라면 어노테이션을 이용해서 처리하는 것이 무난하지만, 복잡한 SQL문이 처리되는 경우에는 어노테이션은 그다지 유용하지 못하다는 단점이 있다.
XML의 경우 단순 텍스트를 수정하는 과정만으로 처리가 끝나지만, 어노테이션의 경우 코드를 수정하고 다시 빌드 하는 등의 유지 보수성이 떨어지기 때문이다.

Mapper 인터페이스 
root-context.xml에 추가 작성

<mybatis-spring:scan base-package="org.zerock.mapper"/>
패키지를 스캔하여 하도록 설정

org.zerock.mapper에 BoardMapper 인터페이스 생성
리스트(select)조회와 등록(insert) 작성

예제)
package org.zerock.mapper;

import java.util.List;


import org.zerock.domain.BoardVO;

public interface BoardMapper {

	@Select("select * from tbl_board where bno > 0")
	public List<BoardVO> getList();	
	
}
SQL을 어노테이션의 속성값으로 처리(SQL을 작성할 때는 반디스 ';'이 없도록 작성해야 한다.
SQL Delveloper에서 먼저 쿼리를 날려 데이터까지 확인한 후 작성하는게 좋다.
그 이유는 
1) SQL이 문제가 없이 실행 가능한지를 확인하기 위한 용도와
2) 데이터베이스의 commit을 하지 않았다면 나중에 테스트 결과가 달라지기 때문에 이를 먼저 비교할 수 있도록 하기 위함

인터페이스를 테스트 할 수 있게 
src/test/java에 org.zerock.mapper 패키지를 적상하고 Junittest를 만든다.

예제 ) BoardMapperTests.java
package org.zerock.mapper;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.zerock.domain.BoardVO;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringJUnit4ClassRunner.class)
// Junit을 테스트할 때 xml설정 파일을 지정해주는거 XML파일만 인식 class는 에러 발생
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
@Log4j	// log확인을 하기 위한 어노테이션
public class BoardMapperTests {

	
	@Setter(onMethod_ = @Autowired) // 의존성 주입
	private BoardMapper mapper;	// BoardMapper 인터페이스

	@Test	// 테스트 메소드라는걸 명시
	public void testGetList() {
		mapper.getList().forEach(board -> log.info(board));
	}
	
}

BoardMapperTests 클래스는 스프링을 이용해서 BoardMapper 인터페이스의 구현체를 주입받아서 동작한다.
Java 설정 시에는 RootConfig 클래스를 이용해서 스프링의 설정을 이용하고 있음을 명시
여기서 testGetList() 메소드의 결과가 SQL Developer와의 결과와 동일하게 작동해야만 정상적으로 동작한 거다.

어노테이션 @Select("select * from tbl_board where bno > 0")을 사용하지 않고
XML파일을 생성하여 반복 동일되거나 복잡한 SQL문을 작성하여 사용하는 방법
(이 방법을 제일 많이 사용)

Mapper.XML 파일 생성
src/main.resources 내에 패키지와 동일한 org/zerock/mapper 단계의 폴더를 생성하고 XML 파일을 작성한다.
(폴더를 생성할 때 한 번에 생성하지 말고 하나씩 생성해야 하는 점을 주의해야 한다.)
파일의 폴더 구조나 이름은 무방하지만 패키지와 클래스 이름과 동일하게 해주면 나중에 혼란스러운 상황을 피할 수 있다.

예제) boardMapper.xml 생성

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC 
"-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.zerock.mapper.BoardMapper">

<select id="getList" resultType="org.zerock.domain.BoardVO">
<![CDATA[
SELECT * FROM tbl_board where bno > 0
]]>
</select>

xml을 작성할 때는 반드시 <mapper>의 namespace 속성값을 Mapper 인터페이스와 동일한 이름을 주는 것에 주의하고, <select> 태그의 Id 속성값은 메서드의 이름과 일치하게 작성한다.
resultType 속성의 값은 select 쿼리의 결과를  특정 클래스의 객체로 만들기 위해서 설정한다.
※ xml에 사용한 CDATA 부분은 부등호를 사용하기 위해서 사용한다.

인터페이스 수정 후에는 반드시 기존의 테스트 코드를 통해서 기존과 동일하게 동작하는지 확인해야 한다.

※ statement 동작 방식
select * from table명;
첫번째 - 구문 분석 parse
1) 검사(문법, 의미, 권한), 실행계획

두번째 - 치환(bind)
1) 값을 입력받아 변수 선언 

세번째 - 실행(excute)
1) 디스크에서 블록을 찾아서 버퍼에 복사

네번째 - 인출(patch)
1) 블록에서 원하는 데이터를 추출하는 과정


영속 영역의 CRUD 구현
- 웹 프로젝트 구조에서 마지막 영역이 영속 영역이지만, 실제로 구현을 가장 먼저 할 수 있는 영역도 영속 영역이다. 
영속 영역은 기본적으로 CRUD 작업을 하기 때문에 테이블과 VO(DTO)등 약간의 준비만으로도 비즈니스 로직과 무관하게 CRUD 작업을 작성할 수 있다.
MyBatis는 내부적으로 JDBC의 PreparedStatement를 활용하고 필요한 파라미터를 처리하는 '?'에 대한 치환은 '#{속성}'을 이용해서 처리한다.

※ statement와 PreparedStatment 클래스 

Statement 클래스
- SQL 구문을 실행하는 역할
- 스스로는 SQL 구문 이해 못함(구문해석 X) -> 전달역할
- SQL 관리 O + 연결 정보 X

PreparedStatement 클래스
- Statement 클래스의 기능 향상
- 인자와 관련된 작업이 특화(매개변수)
- 코드 안정성 높음. 가독성 높음.
- 코드량이 증가 -> 매개변수를 set해줘야하기 때문에..
- 텍스트 SQL 호출

create(insert) 처리
tbl_board 테이블은 PK 칼럼으로 bno를 이용하고, 시퀀스를 이용해서 자동으로 데이터가 추가될 때 번호가 만들어지는 방식을 사용한다.
이처럼 자동으로 PK 값이 정해지는 경우 2가지 방식으로 처리할 수 있다.
1. insert만 처리되고 생성된 PK 값을 알 필요도 없는 경우
2. insert문이 실행되고 생성된 PK 값을 알아야 하는 경우

BoardMapper 인터페이스 메소드 추가

예제)
package org.zerock.mapper;

import java.util.List;


import org.zerock.domain.BoardVO;

public interface BoardMapper {

	//@Select("select * from tbl_board where bno > 0")
	public List<BoardVO> getList();	
	
	public void insert(BoardVO board);
	
	public void insertSelectKey(BoardVO board);
}

BoardMapper.xml에도 추가

예제)
<insert id="insert">
	insert into tbl_board (bno, title, content, writer)
	values (seq_board.nextVal, #{title}, #{content}, #{writer})
</insert>

<insert id="insertSelectKey">
	<selectKey keyProperty="bno" order="BEFORE" resultType="long">
		select seq_board.nextVal from dual
	</selectKey>
	
	insert into tbl_board (bno, title, content, writer)
	values (#{bno}, #{title}, #{content}, #{writer})

</insert>

BoardMapper의 insert() 메소드는 단순히 시퀀스의 다음 값을 구해서 insert 할 때 사용한다.
insert문은 몇 건의 데이터가 변경되었는지만을 알려주기 때문에 추가된 데이터의 PK값을 알 수는 없지만, 1번의 SQL처리만으로도 작업이 완료되는 장점이 있다.

insertSelectKey()는 @SelectKey라는 MyBatis의 어노테이션을 이용한다.
@SelectKey는 주로 PK 값을 미리(before) SQL을 통해서 처리해 두고 특정한 이름으로 결과를 보관하느 ㄴ방식이다.
@Insert 할 때 SQL문을 보면 #{bno}와 같이 미리 처리된 결과를 이용하는 것을 볼 수 있다.

BoardMapperTests클래스에 추가

예제)
	@Test
	public void testInsert() {
		BoardVO board = new BoardVO();
		board.setTitle("새로 작성하는 글");
		board.setContent("새로 작성하는 내용");
		board.setWriter("newbie");
		
		mapper.insert(board);
		
		log.info(board);
	}
테스트 코드의 마지막에 log.info(board)를 작성하는 이유는 Lombok이 만들어주는 toString()을 이용해서 bno멤버 변수(인스턴스 변수)의 값을 알아보기 위함이다. 	
// insert문이 실행되고 생성된 PK 값을 알아야하는 경우 selectKey메소드를 이용하여 bno 다음 값 저장전 확인
	@Test
	public void testInsertSelectKey() {
		
		BoardVO board = new BoardVO();
		board.setTitle("새로 작성하는 글 Select key");
		board.setContent("새로 작성하는 내용 Select key");
		board.setWriter("newbie");
		
		mapper.insertSelectKey(board);
		
		log.info(board);
	}

실행되는 결과를 보면 'select seq_board.nextVal from dual' 쿼리가 먼저 실행되고 여기서 생성된 결과를 이용해서 bno 값으로 처리되는 것을 볼 수 있다.
BoardMapper의 insertSelectKey()의 @Insert 문의 SQL을 보면 'insert into tbl_board(bno, title, content, writer) vlaues (#{bno}, #{title}, #{content}, #{writer})'와 같이 파라미터로 전달되는 BoardVO의 bno값을 사용하게 되어 있다.
테스트 코드의 마지막 부분을 보면 BoardVO 객체의 bno값이 이전과 달리 지정된 것을 볼 수 있다.
(시퀀스는 자동으로 값이 바뀌는 nextVal로 되어있어 값이 계속 변경되어 저장된다
시퀀스 값은 중복 없는 값을 위한 것일 뿐 다른 의미가 있지는 않다.)
@SelectKey를 이용하는 방식은 SQL을 한 번 더 실행하는 부담이 있기는 하지만 자동으로 추가되는 PK 값을 확인해야 하는 상황에서는 유용하게 사용될 수 있다.

read(select)처리
- insert가 된 데이터를 조회하는 작업은 PK를 이용해서 처리하므로 BoardMapper의 파라미터 역시 BoardVO 클래스의 bno 타입 정보를 이용해서 처리한다.

예제) boardMapper인터페이스 메소드 추가

	public BoardVO read(Long bno);

예제) boardMapper.xml에 추가 <select>
<!-- Read(Select)처리 조회 -->
<select id="read" resultType="org.zerock.domain.BoardVO">
 select * from tbl_board where bno = #{bno}
</select>

MyBatis는 Mapper 인터페이스의 리턴 타입에 맞게 select의 결과를 처리하기 때문에 tbl_board의 모든 칼럼은 BoardVO의 'bno,title,content,writer,regdate,updataDate' 속성값으로 처리된다.
즉, bno라는 컬럼이 존재하면 인스턴스의 'setBno()'를 호출하게 된다.
Mybatis의 모든 파라미터와 리턴 타입의 처리는 get 파라미터명(), set 칼럼명()의 규칙으로 호출된다. 다만 위와 같이 #{속성}이 1개만 존재하는 경우에는 별도의 get파라미터명()을 사용하지 않고 처리된다.

예제) BoardMapperTests클래스의 read()함수 추가 조회 테스트 
	@Test
	public void testRead() {
		// 존재하는 게시물 번호로 테스트
		BoardVO board = mapper.read(3L);
		
		log.info(board);
	}

mapper.read()를 호출할 경우에는 현재 테이블에 있는 데이터의 bno값이 존재하는지 여부를 반드시 확인해야 한다.

delete 처리
특정한 데이터를 삭제하는 작업 역시 PK 값을 이용해서 처리하므로 조회하는 작업과 유사하게 처리한다.
등록, 삭제, 수정과 같은 DML 작업은 '몇 건의 데이터가 삭제(혹은 수정) 되었는지를 반환할 수 있다.
※DML(Date Manipulation Language, 데이터 조작어)
- select,insert, update, delete 정의된 데이터 베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할을 하는 언어를 말한다.

- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용하는 언어이다.

- 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.

예제) BoardMapper 인터페이스 속성 추가

	public int delete(Long bno);

예제) BoardMapper.xml 추가
<!-- delete삭제 처리 -->
<delete id="delete">
	delete from tbl_board where bno = #{bno}
</delete>

delete()메서드 리턴 타입은 int로 지정해서 만일 정상적으로 데이터가 삭제되면 1 이상의 값을 가지도록 작성한다.
테스트 코드는 현재 테이블에 존재하는 번호이 데이터를 삭제하고 '1'이라는 값이 출력되는지 확인한다.
만일 게시물이 없다면 '0'이 출력된다.

예제) BoardMapperTests클래스 추가
	@Test
	public void testDelete() {
		
		log.info("DELECT COUNT : " + mapper.delete(5L));
	}
	

update 처리 
- 업데이트할 때는 최종 수정시간을 데이터베이스 내 현재 시간으로 수정한다.
Update는 delete와 마찬가지로 '몇 개의 데이터가 수정되었는가'를 처리할 수 있게 int 타입으로 메서드를 설계한다.

예제) BoardMapper 인터페이스 update속성 추가
	public int update(BoardVO board);

예제) BoardMapper.xml <update> 추가
<!-- update 수정 -->
<update id="update">
update tbl_board 
set title = #{title},
content = #{content},
writer = #{writer},
updateDate = sysdate
where bno = #{bno} 
</update>

SQL에서 주의 깊게 봐야 하는 부분은 update 칼럼이 최종 수정 시간을 의미하는 칼럼이기 때문에 현재 시간으로 변경해 주고 있다는 점과, regdate 칼럼은 최초 생성 시간이므로 건드리지 않는다는 점이다.
#{title}과 같은 부분은 파라미터로 전달된 BoardVO 객체의 getTitle()과 같은 메서드들을 호출해서 파라미터들이 처리된다.

테스트 코드는 read()를 이용해서 가져온 BoardVO 객체의 일부를 수정하는 방식이나 직접 BoardVO 객체를 생성해서 처리할 수있다.

예제) BoardMapperTests update추가
	@Test
	public void testUpdate() {
		
		BoardVO board = new BoardVO();
		// 실행전 존재하는 번호인지 확인할 것
		board.setBno(3L);
		board.setTitle("수정된 제목");
		board.setContent("수정된 내용");
		board.setWriter("park");
		
		int count = mapper.update(board);
		log.info("UPDATE COUNT : " + count);
	}


비지니스 계층 

- 비즈니스 계층은 고객의 요구사항을 반영하는 계층으로 프레젠테이션 계층과 영속 계층의 중간 다리 역할을 하게 된다. 영속 계층은 데이터베이스를 기준으로 해서 설계를 나눠 구현하지만, 비즈니스 계층은 로직을 기준으로 해서 처리하게 된다.

비즈니스(구매 서비스) <-> Persistence tier ( 상품 처리 객체)
		    <-> 		      ( 회원 처리 객체)

현재 예제는 단일한 테이블을 이용하고 있기 때문에 위와 같은 구조는 아니지만 설계를 할 때는 원칙적으로 영역을 구분해서 작성해야한다. 
일반적으로 비즈니스 영역에 있는 객체들은 '서비스(Service)'라는 용어를 많이 사용한다.


비즈니스 계층의 설정 
org.zerock.service 패키지 생성
※ 설계를 할 때 각 계층 간의 연결은 인터페이스를 이용해서 느슨한(loose) 연결(결합)을 한다.
게시물 BoardService 인터페이스와 인터페이스를 구현한 BoardServiceImpl클래스를 선언한다.

예제) BoardService 인터페이스 생성
package org.zerock.service;

import java.util.List;

import org.zerock.domain.BoardVO;

public interface BoardService {

	public void register(BoardVO board);
	
	public BoardVO get(Long bno);
	
	public boolean modify(BoardVO board);
	
	public boolean remove(Long bno);
	
	public List<BoardVO> getList();
}
BoardService 메서드를 설계할 때 메서드 이름은 현실적인 로직의 이름을 붙이는 것이 관례이다.
명백하게 반환해야 할 데이터가 있는 'select'를 해야하는 메서드는 리턴 타입을 지정할 수 있다.
게시물은 특정한 게시물을 가져오는 get() 메서드와 전체 리스트를 가져오는 getList()의 경우 처음부터 메서드의 리턴타입을 결정해서 진행할 수 있다.

BoardService 인터페이스를 구현하는 구현체는 BoardServiceImpl이라는 클래스로 작성한다.

예제) BoardServiceImpl 구현 클래스 생성
package org.zerock.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.zerock.domain.BoardVO;
import org.zerock.mapper.BoardMapper;


import lombok.Setter;
import lombok.extern.log4j.Log4j;


@Service // 비즈니스 영역을 담당하는 객체임을 표시
@Log4j
public class BoardServiceImple implements BoardService{
	
	@Setter(onMethod_ = @Autowired)(데이터를 가져와 BoardService 메소드를 정상적으로 실행시키기 위해 BoardMapper객체가 필요 의존성 주입)D.I
	private BoardMapper mapper;

	@Override
	public void register(BoardVO board) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public BoardVO get(Long bno) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean modify(BoardVO board) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean remove(Long bno) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public List<BoardVO> getList() {
		// TODO Auto-generated method stub
		return null;
	}
	
}

BoardServiceImpl 클래스에 가장 중요한 부분은 @Service라는 어노테이션이다.
@Service는 계층 구조상 주로 비즈니스 영역을 담당하는 객체임을 표시하기 위해 사용한다. 작성된 어노테이션은 패키지를 읽어 들이는 동안 처리된다.
BoardServiceImpl이 정상적으로 동작하기 위해서는 BoardMapper 객체(의존성 주입)가 필요하다.

이는 @AutoWierd와 같이 직접 설정해 줄 수 있고, Setter를 이용해서 처리할 수 도 있고 Lombok을 이용하여 @Setter(onMethod_ = @AutoWierd)같은 방식으로도 사용할 수 있다.

스프링 4.3부터는 단일 파라미터를 받는 생성자의 경우에는 필요한 파라미터를 자동으로 주입할 수 있다. @AllConstructor는 모든 파라미터를 이용하는 생성자를 만들기 때문에 실제 코드는 
BoardMapper를 주입받는 생성자가 만들어지게된다. 

스프링의 서비스 객체 설정(root-context.xml)
- 비지니스 계층의 인터페이스와 구현 클래스가 작성되었다면, 이를 스프링의 빈(객체)로 인식하기 위해서 root-context.xml에 @Service 어노테이션이 있는 org.zerock.service 패키지를 스캔(조사)
하도록 추가해야한다.

예제) root-context.xml에 추가
	<context:component-scan base-package="org.zerock.service"></context:component-scan>

추가후에 namespace에 context를 체크하면 빈 그래프를 보면 객체가 생성되어 있다.


비지니스 계층의 구현과 테스트 
- BoardMapper와 BoardService, BoardServieceImpl에 대한 구조 설정이 완료되었으면 테스트를 작성한다.

예제) BoardServiceTests 생성
package org.zerock.service;

import static org.junit.Assert.assertNotNull;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.zerock.domain.BoardVO;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
@Log4j
public class BoardServiceTests {

	@Setter(onMethod_ = @Autowired)(BoardService 의존성 주입)
	private BoardService service;	
	
//	@Test
	public void testExist() {
		(객체가 잘 생성되었는지 Exist()메소드로 확인)
		log.info(service);
		assertNotNull(service);
	}
	
}
BoardServiceTests의 첫 테스트는 BoardService 객체가 제대로 주입이 가능한지 확인하는 작업으로 정상적으로 BoardService 객체가 생성되고 BoardMapper가 주입되었다면
객체와 데이터 베이스 관련 로그가 같이 출력된다.

등록 작업의 구현과 테스트
- 등록 작업은 BoardServiceImpl 구현 클래스에서 파라미터로 전달되는 BoardVO 타입의 객체를 BoardMapper를 통해서 처리한다. 

예제) BoardServiceImpl 메소드 수정

@Override
	public void register(BoardVO board) {
		
		log.info("register....... " + board);
		
		mapper.insertSelectKey(board);
		
	}

BoardServiceImpl는 void 타입으로 설계되었으므로 mapper.insertSelectKey()의 반환 값이 int를 사용하지 않고 있지만, 필요하다면 예외 처리나 void 대신에 int 타입을 이용해서 사용할 수도 있다.

mapper의 insertSelectKey()메소드를 이용해서 나중에 생성된 게시물의 번호를 확인할 수 있게 작성했다.

예제) BoardServiceTests insertSelectKey() 메소드 추가

	@Test
	public void testRegister() {
		
		BoardVO board = new BoardVO();
		board.setTitle("새로 작성하는 글");
		board.setContent("새로 작성하는 내용");
		board.setWriter("나야나!");
		
		service.register(board);
		
		log.info("생성된 게시물의 번호 : " + board.getBno());
	}

testRegister() 메소드의 테스트 결과는 생성된 게시물의 번호를 확인할 수 있다.

목록(리스트) 작업의 구현과 테스트
BoardServiceImpl 클래스에서 현재 테이블에 저장된 모든 데이터를 가져오는 getList() 

예제) BoardServiceImpl 클래스 getList() 메소드 수정

	@Override
	public List<BoardVO> getList() {
	
		log.info("getList..........................");
		return mapper.getList();
	}
	

예제) BoardServiceTests getList()메소드 추가
	@Test
	public void testGetList() {
		
		service.getList().forEach(board -> log.info(board));
	}

forEach()함수로 테이블에 저장된 모든 데이터를 각각 로그로 볼 수 있게 람다식으로 작성

조회 작업의 구현과 테스트
조회는 게시물의 번호가 파라미터이고 BoardVO의 인스턴스가 리턴이 된다.

예제) BoardServiceImpl 메소드 수정

@Override
		public BoardVO get(Long bno) {
			log.info("get....... " + bno);
			return mapper.read(bno);
		}

예제) BoardServiceTests get()메소드 추가
	@Test
	public void testGet() {
		
		
		log.info("조회한 게시물의 번호 : " + service.get(3L));
	}

get()메소드는 코딩 설계는 bno가 타입이 Long타입의 3번이 primary Key로 파라미터 값을 보내 검색후 그 bno만 찾는다.

삭제/ 수정 구현과 테스트 
삭제/ 수정은 메서드의 리턴 타입을 void로 설계할 수도 있지만 엄격하게 처리하기 위해서 Boolean 타입으로 처리한다.

예제) BoardServiceTests getList()메소드 추가
	@Test
	public void testGetList() {
		
		service.getList().forEach(board -> log.info(board));
	}

forEach()함수로 테이블에 저장된 모든 데이터를 각각 로그로 볼 수 있게 람다식으로 작성

조회 작업의 구현과 테스트
조회는 게시물의 번호가 파라미터이고 BoardVO의 인스턴스가 리턴이 된다.

예제) BoardServiceImpl modify(), remove() 메소드 수정

	@Override
	public boolean modify(BoardVO board) {
		log.info("modify....... " + board);
		return mapper.update(board) == 1;
	}

	@Override
	public boolean remove(Long bno) {
		log.info("remove....... " + bno);
		
		return mapper.delete(bno) == 1;
	}

정상적으로 수정과 삭제가 이루어지면 1이라는 값이 반환되기 때무에 '==' 연산자를 이용해서 true/false를 처리할 수 있다
예제) BoardServiceTests testDelete(), testUpdate() 메소드 추가
	
	@Test
	public void testDelete() {
		
		
		log.info("REMOVE RESULT : " + service.remove(3L));
	}
	
	@Test
	public void testUpdate() {
		
		BoardVO board = service.get(2L);
		
		if (board == null) {
			return;
		}
		
		board.setTitle("제목 수정합니다.");
		log.info("MODIFY RESULT : " + service.modify(board));
	}

testDelete()의 경우에는 해당 게시물이 존재할 때 true를 반환하는 것을 확인할 수 있고, testUpdate()의 경우에는 특정한 게시물을 먼저 조회하고, title 값을 수정한 후 이를 업데이트를 한다.



프레젠테이션(웹) 계층의 CRUD 구현 

Controller의 작성
- 스프링 MVC의 Controller는 하나의 클래스 내에서 여러 메서드를 작성하고, @RequestMapping등을 이용해서 URL을 분기하는 구조로 작성할 수 있기때문에 하나의 클래스에서 필요한 만큼 메서드의 분기를 이용하는 구조로 작성한다.
테스트는 WAS로 실행하지 않고 Controller를 테스트를 할 수 있는 방법으로 구현한다.
WebApplicationContext와 MockMvc를 이용

BoardController의 분석

task - 전체목록      , 등록처리	  , 조회, 삭제처리, 수정 처리
URL - /board list ,/board/register, /board/get, /board/remove, /board/modify 
Method - GET	 , POST		 , GET	     , POST	    , POST
Parameter - 	 , 모든 항목	 , bno = 123  , bno	    , 모든 항목
Form - 		 , 입력 화면 필요  , 	     , 입력화면 필요  , 입력화면 필요
URL 이동 - 	 , 이동		 , 	     , 이동	      , 이동


테이블에서 From 항목은 해당 URL을 호출하기 위해서 별도의 입력화면이 필요하다는 것을 의미한다. 

BoardController의 작성

예제) BoardController 생성

package org.zerock.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
import org.zerock.domain.BoardVO;
import org.zerock.service.BoardService;

import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Controller // Controller라는 스프링의 빈으로 인식할 수 있게 한다.
@Log4j
@RequestMapping("/board/*") // @RequestMapping을 통해서 "/board/*" 로 시작하는 모든 처리를 BoardController가 하도록 지정
@AllArgsConstructor // BoardService 타입의 객체와 같이 연동해야 하므로 의존성에 대한 처리로 @Allconstructor를 이용해서 생상자를 만들고 자동으로 주입
// 생성자를 만들지 않을 경우에는 @Setter(onMethod_ = @AutoWierd)를 이용해서 처리
public class BoardController {
	
}


목록에 대한 처리와 테스트

예제) BoardController클래스에 list() 메소드 추가

private BoardService service;
	
	// list()는 나중에 게시물의 목록을 전달해야 하므로 Model을 파라미터로 지정하고, 이를 통해서 BoardServiceImpl 객체의 getList() 결과를 담아 전달(addAttribute)
	@GetMapping("/list")
	public void list(Model model) {
		
		log.info("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" + "list");
		
		model.addAttribute("list", service.getList());
	}

- BoardController에서 전체 목록을 가져오는 처리를 먼저 작성 BoardController는 BoardService 타입의 객체와 같이 연동해야 하므로 의존성에 대한 처리도 같이 진행한다.
BoardController는 BoardService에 대해서 의존적이므로 @AllArgsConstructor를 BoardService 타입의 객체와 같이 연동해야 하므로 의존성에 대한 처리로 
@Allconstructor를 이용해서 생상자를 만들고 자동으로 주입. (생성자를 만들지 않을 경우에는 @Setter(onMethod_ = @AutoWierd)를 이용해서 처리)



※ Junit 테스트 코드 (WAS를 이용하지 않고 사용하는 이유)
WAS를 사용하지 않고 테스트를 하는 이유는 웹을 개발할 때 매번 URL을 테스트하기 위해서 Tomcat과 같은 WAS를 실행하는 불편한 단계를 생략하기 위해서이다.
스프링의 테스트 기능을 활용하면 개발 당시에 WAS를 실행하지 않고도 스프링과 웹 URL을 테스트할 수 있다.

예제) BoardControllerTests클래스 생성

package org.zerock.controller;



import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
import org.zerock.domain.BoardVO;

import lombok.Setter;
import lombok.extern.log4j.Log4j;
@RunWith(SpringJUnit4ClassRunner.class)

// Test for Controller
@WebAppConfiguration
@ContextConfiguration({
	"file:src/main/webapp/WEB-INF/spring/root-context.xml",
	"file:src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml"
})
@Log4j
public class BoardControllerTests {
// 톰캣(WAS)를 서버실행하지 않고 테스트 용으로 스프링과 웹URL을 테스트할 수 있도록 작성
	@Setter(onMethod_ = @Autowired)
	private WebApplicationContext ctx;
	
	private MockMvc mockMvc;
	
	@Before
	public void setup() {
		this.mockMvc = MockMvcBuilders.webAppContextSetup(ctx).build();
	}
	
	//@Test
	public void testList() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/board/list"))
		.andReturn()
		.getModelAndView()
		.getModelMap();
}

테스트 클래스의 선언부에는 @WebAppConfiguration을 적용한다. @WebConfigRation은 Servlet의 ServletContext를 이용하기 위해서인데, 스프링에서는 WebApplicationContext라는 존재를 이용하기
위해서이다.
@Before이 적용된 setUp()에서는 Import 할 때 JUnit을 이용해야 한다.
@Before가 적용된 메서드는 모든 테스트 전에 매번 실행되는 메서드가 된다.

MockMvc는 말 그대로 '가짜 mvc'라고 생각하면된다. 가짜로 URL과 파라미터 등을 브라우저에서 사용하는 것처럼 만들어서 Controller를 실행해 볼 수 있다.
testList()는 MockMvcRequestBuilders라는 존재를 이용해서 GET방식의 호출을 한다.
이후에는 BoardController의 getList()에서 반환된 결과를 이용해서 Model에 어떤 데이터들이 담겨 있는지 확인
Tomcat을 통해서 실행되는 것이 아니라 기존의 코드를 실행하는 것과 동일하게 테스트 실행하는 것이다.

등록 처리와 테스트

예제) BoardController에 POST 방식으로 처리되는 register() 메소드 추가

	@PostMapping("register")
	public String register(BoardVO board, RedirectAttributes rttr) {
		
		log.info("register : " + board);
		
		service.register(board);
		
		rttr.addFlashAttribute("result", board.getBno());
		
		return "redirect:/board/list";
	}

register() 메소드는 조금 다르게 String을 리턴 타입으로 지정하고, RedirectAttributes를 파라미터로 지정한다.
이는 등록 작업이 끝난 후 다시 목록 화면으로 이동하기 위함인데, 추가적으로 새롭게 등록된 게시물의 번호를 같이 전달하기 위해서 RedirectAttributes를 이용한다.
리턴 시에는 'redirect:'접두어를 사용하는데 이를 이용하면 스프링MVC가 내부적으로 response, sendRedirect()를 처리해 주기 때문에 편리하다.

예제) BoardControllerTests에 testRegister() 메소드 추가

	//@Test
	public void testRegister()throws Exception{
		String resultPage = mockMvc.perform(MockMvcRequestBuilders.post("/board/register")
				.param("title", "테스트 새글 제목")
				.param("content", "테스트 새글 내용")
				.param("writer", "park"))
				.andReturn().getModelAndView().getViewName();
		
		log.info(resultPage);
	}

테스트할 때 MockMvcRequestBuilder의 post()를 이용하면 POST 방식으로 데이터를 전달할 수 있고, param()을 이용해서 전달해야 하는 
파라미터들을 지정할 수 있다.(<input> 태그와 유사한 역할).


조회 처리와 테스트
-등록 처리와 유사하게 조회 처리도 BoardController를 이용해서 처리할 수 있다. 특별한 경우가 아니라면 조회는 GET방식으로 처리하므로,
@GetMapping을 이용한다.

예제) BoardController get()메소드 추가

@GetMapping("/get")
	public void get(@RequestParam("bno") Long bno, Model model) {
		
		log.info("/get");
		model.addAttribute("board", service.get(bno));
	}
	

BoardController의 get()메소드에는 bno 값을 좀 더 명시적으로 처리하는 @RequestParam을 이용해서 지정한다.(파라미터 이름과 변수이름을 기준으로 동작하기 때문에 생략해도 무방하다.)
또한 화면 쪽으로 해당 번호의 게시물을 전달해야 하므로 Model을 파라미터로 지정한다.

예제) BoardControllerTests testGet()메소드 추가
	//@Test
	public void testGet() throws Exception{
		
		log.info(mockMvc.perform(MockMvcRequestBuilders
				.get("/board/get")
				.param("bno", "2"))
				.andReturn()
				.getModelAndView()
				.getModelMap());
	}

특정 게시물을 조회할 때 반드시 'bno'(uniq한 key)라는 파라미터가 필요하므로 param()을 통해서 추가하고 실행한다.

수정 처리와 테스트
-수정 작업은 등록과 유사하다. 변경된 내용을 수집해서 BoardVO파라미터로 처리하고, BoardService를 호출한다. 수정 작업을 시작하는 화면의 경우에는 GET방식으로 접근하지만
실제 작업은 POST 방식으로 동작하므로 @PostMapping을 이용해서 처리한다.

예제) BoardController modify()메서드 추가

	@PostMapping("/modify")
	public String modify(BoardVO board, RedirectAttributes rttr) {
		
		log.info("modify : " + board);
		
		if (service.modify(board)) {
			rttr.addFlashAttribute("result", "success");
			
		}
		return "redirect:/board/list";
	}

service.modify()는 수정 여부를 boolean으로 처리하므로 성공한 경우에만 RedirectAttribute에 추가한다.(성공 = 1, 실패 = 0)


예제) BoardControllerTests testModify() 추가

	//@Test
	public void testModify() throws Exception{
		
		String resultPage = mockMvc
				.perform(MockMvcRequestBuilders.post("/board/modify")
						.param("bno", "2")
						.param("title", "수정된 테스트 새글 제목")
						.param("content", "수정된 새글 내용")
						.param("writer", "park01"))
				.andReturn().getModelAndView().getViewName();
		
		log.info(resultPage);
						
	}


삭제 처리와 테스트
- 삭제 처리도 조회와 유사하게 BoardController와 테스트 코드를 작성한다. 삭제는 반드시 POST방식으로만 처리한다.

예제) BoardController remove()메서드 추가

	@PostMapping("/remove")
	public String remove(@RequestParam("bno") Long bno, RedirectAttributes rttr) {
		
		log.info("remove : " + bno);
		if (service.remove(bno)) {
			rttr.addFlashAttribute("result", "success");
		}
		return "redirect:/board/list";
	}

BoardController의 remove()는 삭제 후 페이지의 이동이 필요하므로 RedirectAttributes를 파리미터로 사용하고 'redirect'를 이용해서 삭제 처리 후에 다시 목록 페이지로 이동

예제) BoardControllerTests testRemove()메서드 추가

	@Test
	public void testRemove()throws Exception{
		// 삭제전 데이터 베이스에 게시물 번호 확인할 것
		String resultPage = mockMvc.perform(MockMvcRequestBuilders.post("/board/remove")
				.param("bno", "19")
				).andReturn().getModelAndView().getViewName();
		log.info(resultPage );
	}

MockMvc를 이용해서 파라미터를 전달할 때에는 문자열로만 처리해야 한다.
테스트 전에 게시물의 번호가 존재하는지 확인하고 테스트를 실행한다.


경우에 따라서는 Controller에 대한 테스트 코드를 작성하는 것에 대해서 거부감을 가지는 경우도 많다.
대부분은 일정에 여유가 없다는 이유로 테스트를 작성하지 않는 경우가 많은데 프로젝트를 진행하는 멤버들의 경험치가 낮을수록 테스트를 먼저 진행하는 습관ㄹ을 가지는 것이 좋다.
반복적으로 입력과 수정, WAS의 재시작 시간을 고려해보면 Controller에 대한 테스트를 진행하는 선택이 더 빠른 개발의 결과를 낳는 경우가 많다.

화면 처리

영역
1) 영속계층(데이터)
2) 서비스 계층   == > 1), 2) 백
3) 화면 계층 ==> 프론 

각 영역에 대한 모든 처리와 체스트가 완료되었다. 
만일 이제부터 에러가 발생한다면 모든 문제는 화면 쪽에서만 발생한다고 말할 수 잇다.
화면에는 JSP와 JavaScript(jQuery), CSS, HTML을 이용해서 작성한다.

※ 화면을 개발하기 전에 꼭 고려해야할 것
- 반드시 화면의 전체 레이아웃이나 디자인이 반영된 상태에서 개발하는 것을 추천한다.
그 이유는 화면 설계도가 제대로 짜여 있지 않다면 크기나 구성하는 것이 각 페이지마다 틀리게 되고 일관성이 없어 화면들이 직관적이지 못할 것이다.
(그냥 내생각)

예제는 BootStrap을 이용한 무료 디자인 화면으로 개발을 진행한다.
(https://startbootstrap.com/template-categories/all/)
디자인 'SB Admin2'을 이용(# 디자인의 변경으로 cafe 자료실에서 다운 http://cafe.naver.com/gugucoding)

목록 페이지 작업과 includes
스프링 MVC의 JSP를 처리하는 것은 servlet-context.xml에서 한다.
설정
예제) servlet-context.xml에 jsp 처리하는 빈객체 설정  ==> mvc로 프로젝트 생성시 기본으로 설정이 잡혀있다.
<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>

스프링 MVC의 설정에서 화면 설정은 ViewResolver라는 객체를 총해 이루어진다.
앞에 고정으로 설정한 경로는 /WEB-INF/views이고 사용할 파일명을 .jsp로 설정하였다.
*/WEB-INF/ 경로는 브라우저에서 직접 접근을 할 수 없는 경로이므로 반드시 controller를 이용하는 모델 2방식에서는 기본적으로 사용하는 방식이다.
여기서 엔터프라이즈 경량용 frameWork 스프링을 이용하는 이유 알아서 프로젝트 경로를 만들어 준다(뼈대)

게시물 리스트의 URL은 '/board/list'이므로 최종적인 '/WEB-INF/views/board/list.jsp'가 된다.
해당 경로에 list.jsp생성

예제) list.jsp 생성
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html"; charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h1>List Page</h1>
</body>
</html>

list.jsp는 우선 정상적으로 URL 처리가 되는지를 확이해야 하므로, Tomcat으로 실행해서 확인한다.
'ex02' 프로젝트를 선택하고 , Run on Server를 통하여 실행
실행이되면 'http://localhost:8081/controller/board/list'로 접근한다.
// 항상 절대 경로를 사용하는 것을 권장 
// 그이유는 CSS, js, 이미지 파일들의 경로에 치명적인 영향을 주기 때문에 처음부터 절대 경로 or 상대 경로에 대해서 명확히 결정한 후에 프로젝트를 진행해야한다.
Server에 Web Modules에서 path에 /controller라고 되어잇는데 /로 변경후 apply
변경후 server 실행시
'http://localhost:8081/board/list' 정상적으로 호출이 되었는지 확인

SB Admin2 페이지 적용하기
정상적으로 '/board/list' 페이지가 동작하면 SB Admin2의 pages 폴더에 있는 tables.html의 내용을 list.jsp의 내용으로 복사해서 수정하고 실행한다.

예제) list.jsp 수정 --> 상단에 있는 JSP의 Page 지시자는 지우지 않도록 한다.

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%> <!-- JSP 페이지 지시자 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %><!-- 변주지원, 제어문 페이지 관련처리 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %><!-- 다국어 문서처리 -->


<%@include file="../includes/header.jsp" %>
 <div class="row">
		<div class="col-lg-12">
		  	 <h1 class="page-header">Tables</h1>
		</div>
    <!-- /.col-lg-12 -->
	</div>
		  <!-- /.row -->
		  <div class="row">
		      <div class="col-lg-12">
		          <div class="panel panel-default">
		              <div class="panel-heading"> Board List Page
<.....> 이하 생략

css와 js 파일들의 경로를 수정하는 작업은 브라우저의 개발자 도구를 통해서 확인하며 진행한다.
개발자 도구(F12)를 통해서 현재 브러우저의 Network 부분을 확인하고, 페이지를 '새로고침'하면 잘못된 URL의 정보를 확인할 수 있다.
개발자 도구에서 network를 보면 호출(request/요청)한 부분을 볼 수 있다.

SB admin2의 CSS의 경로는 'http://localhost:8081/vendor/bootstrap/csss/bootstrap.min.css'경로이므로 현재 프로젝트에서는 제대로 서비스될 수 없다.
org.zerock.config.WebConfig 클래스에는 CSS나 JS 파일과 같이 정적인(static) 자원(resource)들의 경로를 'resources' 라는 경로로 지정하고 있다.

<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<resources mapping="/resources/**" location="/resources/" />
SB Admin2의 압축을 풀어둔 모든 폴더를 프로젝트 내 webapp 밑의 resources 폴더로 복사해 넣는다.
resources라는 폴더가 여러 개 존재하므로 주의한다.
WEB-INF라는 경로를 기준으로 찾는 것이 좋다.
파일들을 resources 경로로 넣어도 아직은 페이지에서 경로를 수정하지 않았기 때문에 문제가 생기는 것은 동일하다.
list.jsp 파일에서 CSS나 js 파일의 경로를 '/resources'로 시작하도록 수정 
간단한 방법은 ctrl + f 키를 눌러 Find/Replace를 이용하는 방법이다.

현재 경로는 ../되어 있는데 '/resources/' 로 변경해준다.

수정 후 브라우저를 통해서 'board/list'를 호출하면 다음과 같이 CSS가 정상적으로 적용된 것을 볼 수 있다.
CSS, js 파일들의 링크는 모든 페이지에서 사용될 것이므로 화면에서 디자인이 깨지지 않는 것을 확인한 후에 진행하도록 한다.

includes 적용
JSP를 작성할 때마다 많은 양의 HTML 코드를 이용하는 것을 피하기 위해 JSP의 include 지시자를 활용해서 페이지 제작 시에 필요한 내용만을 작성할 수 있게 사전에 작업한다.

현재 프로젝트 views 폴더에 includes 폴더를 생성하고 , header.jsp와 footer.jsp를 선언한다.(공통으로 사용될 코드를 반복해서 사용해야 하기 위해 반복적인 코드 대신 include를 사용한다.)

예제) header.jsp 적용
header.jsp 는 페이지에서 핵심적인 부분이 아닌 영역 중에서 위쪽의 HTML 내용을 처리하기 위해서 작성한다. 
브라우저에서 '검사' 기능을 활용하면 특정한 <div>가 어떤 부분을 의미하는지 확인할 수 있다.

SB Admin2는 <div>들 중에서 id 속성값이 'page-wrapper'부터가 핵심적인 페이지의 내용이므로 list.jsp 파일의 처음 부분에서 <div id='page-wrapper'> 라인까지 잘라서
header.jsp의 내용으로 처리한다.

<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>SB Admin 2 - Bootstrap Admin Theme</title>

    <!-- Bootstrap Core CSS -->
    <link href="/resources/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- MetisMenu CSS -->
    <link href="/resources/vendor/metisMenu/metisMenu.min.css" rel="stylesheet">

    <!-- DataTables CSS -->
    <link href="/resources/vendor/datatables-plugins/dataTables.bootstrap.css" rel="stylesheet">

    <!-- DataTables Responsive CSS -->
    <link href="/resources/vendor/datatables-responsive/dataTables.responsive.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="/resources/dist/css/sb-admin-2.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="/resources/vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <div id="wrapper">

        <!-- Navigation -->
        <nav class="navbar navbar-default navbar-static-top" role="navigation" style="margin-bottom: 0">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">SB Admin v2.0</a>
            </div>
            <!-- /.navbar-header -->

            <ul class="nav navbar-top-links navbar-right">
                <li class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                        <i class="fa fa-envelope fa-fw"></i> <i class="fa fa-caret-down"></i>
                    </a>
                    <ul class="dropdown-menu dropdown-messages">
                        <li>
                            <a href="#">
                                <div>
                                    <strong>John Smith</strong>
                                    <span class="pull-right text-muted">
                                        <em>Yesterday</em>
                                    </span>
                                </div>
                                <div>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque eleifend...</div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <strong>John Smith</strong>
                                    <span class="pull-right text-muted">
                                        <em>Yesterday</em>
                                    </span>
                                </div>
                                <div>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque eleifend...</div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <strong>John Smith</strong>
                                    <span class="pull-right text-muted">
                                        <em>Yesterday</em>
                                    </span>
                                </div>
                                <div>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque eleifend...</div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a class="text-center" href="#">
                                <strong>Read All Messages</strong>
                                <i class="fa fa-angle-right"></i>
                            </a>
                        </li>
                    </ul>
                    <!-- /.dropdown-messages -->
                </li>
                <!-- /.dropdown -->
                <li class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                        <i class="fa fa-tasks fa-fw"></i> <i class="fa fa-caret-down"></i>
                    </a>
                    <ul class="dropdown-menu dropdown-tasks">
                        <li>
                            <a href="#">
                                <div>
                                    <p>
                                        <strong>Task 1</strong>
                                        <span class="pull-right text-muted">40% Complete</span>
                                    </p>
                                    <div class="progress progress-striped active">
                                        <div class="progress-bar progress-bar-success" role="progressbar" aria-valuenow="40" aria-valuemin="0" aria-valuemax="100" style="width: 40%">
                                            <span class="sr-only">40% Complete (success)</span>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <p>
                                        <strong>Task 2</strong>
                                        <span class="pull-right text-muted">20% Complete</span>
                                    </p>
                                    <div class="progress progress-striped active">
                                        <div class="progress-bar progress-bar-info" role="progressbar" aria-valuenow="20" aria-valuemin="0" aria-valuemax="100" style="width: 20%">
                                            <span class="sr-only">20% Complete</span>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <p>
                                        <strong>Task 3</strong>
                                        <span class="pull-right text-muted">60% Complete</span>
                                    </p>
                                    <div class="progress progress-striped active">
                                        <div class="progress-bar progress-bar-warning" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 60%">
                                            <span class="sr-only">60% Complete (warning)</span>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <p>
                                        <strong>Task 4</strong>
                                        <span class="pull-right text-muted">80% Complete</span>
                                    </p>
                                    <div class="progress progress-striped active">
                                        <div class="progress-bar progress-bar-danger" role="progressbar" aria-valuenow="80" aria-valuemin="0" aria-valuemax="100" style="width: 80%">
                                            <span class="sr-only">80% Complete (danger)</span>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a class="text-center" href="#">
                                <strong>See All Tasks</strong>
                                <i class="fa fa-angle-right"></i>
                            </a>
                        </li>
                    </ul>
                    <!-- /.dropdown-tasks -->
                </li>
                <!-- /.dropdown -->
                <li class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                        <i class="fa fa-bell fa-fw"></i> <i class="fa fa-caret-down"></i>
                    </a>
                    <ul class="dropdown-menu dropdown-alerts">
                        <li>
                            <a href="#">
                                <div>
                                    <i class="fa fa-comment fa-fw"></i> New Comment
                                    <span class="pull-right text-muted small">4 minutes ago</span>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <i class="fa fa-twitter fa-fw"></i> 3 New Followers
                                    <span class="pull-right text-muted small">12 minutes ago</span>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <i class="fa fa-envelope fa-fw"></i> Message Sent
                                    <span class="pull-right text-muted small">4 minutes ago</span>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <i class="fa fa-tasks fa-fw"></i> New Task
                                    <span class="pull-right text-muted small">4 minutes ago</span>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a href="#">
                                <div>
                                    <i class="fa fa-upload fa-fw"></i> Server Rebooted
                                    <span class="pull-right text-muted small">4 minutes ago</span>
                                </div>
                            </a>
                        </li>
                        <li class="divider"></li>
                        <li>
                            <a class="text-center" href="#">
                                <strong>See All Alerts</strong>
                                <i class="fa fa-angle-right"></i>
                            </a>
                        </li>
                    </ul>
                    <!-- /.dropdown-alerts -->
                </li>
                <!-- /.dropdown -->
                <li class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                        <i class="fa fa-user fa-fw"></i> <i class="fa fa-caret-down"></i>
                    </a>
                    <ul class="dropdown-menu dropdown-user">
                        <li><a href="#"><i class="fa fa-user fa-fw"></i> User Profile</a>
                        </li>
                        <li><a href="#"><i class="fa fa-gear fa-fw"></i> Settings</a>
                        </li>
                        <li class="divider"></li>
                        <li><a href="login.html"><i class="fa fa-sign-out fa-fw"></i> Logout</a>
                        </li>
                    </ul>
                    <!-- /.dropdown-user -->
                </li>
                <!-- /.dropdown -->
            </ul>
            <!-- /.navbar-top-links -->

            <div class="navbar-default sidebar" role="navigation">
                <div class="sidebar-nav navbar-collapse">
                    <ul class="nav" id="side-menu">
                        <li class="sidebar-search">
                            <div class="input-group custom-search-form">
                                <input type="text" class="form-control" placeholder="Search...">
                                <span class="input-group-btn">
                                <button class="btn btn-default" type="button">
                                    <i class="fa fa-search"></i>
                                </button>
                            </span>
                            </div>
                            <!-- /input-group -->
                        </li>
                        <li>
                            <a href="index.html"><i class="fa fa-dashboard fa-fw"></i> Dashboard</a>
                        </li>
                        <li>
                            <a href="#"><i class="fa fa-bar-chart-o fa-fw"></i> Charts<span class="fa arrow"></span></a>
                            <ul class="nav nav-second-level">
                                <li>
                                    <a href="flot.html">Flot Charts</a>
                                </li>
                                <li>
                                    <a href="morris.html">Morris.js Charts</a>
                                </li>
                            </ul>
                            <!-- /.nav-second-level -->
                        </li>
                        <li>
                            <a href="tables.html"><i class="fa fa-table fa-fw"></i> Tables</a>
                        </li>
                        <li>
                            <a href="forms.html"><i class="fa fa-edit fa-fw"></i> Forms</a>
                        </li>
                        <li>
                            <a href="#"><i class="fa fa-wrench fa-fw"></i> UI Elements<span class="fa arrow"></span></a>
                            <ul class="nav nav-second-level">
                                <li>
                                    <a href="panels-wells.html">Panels and Wells</a>
                                </li>
                                <li>
                                    <a href="buttons.html">Buttons</a>
                                </li>
                                <li>
                                    <a href="notifications.html">Notifications</a>
                                </li>
                                <li>
                                    <a href="typography.html">Typography</a>
                                </li>
                                <li>
                                    <a href="icons.html"> Icons</a>
                                </li>
                                <li>
                                    <a href="grid.html">Grid</a>
                                </li>
                            </ul>
                            <!-- /.nav-second-level -->
                        </li>
                        <li>
                            <a href="#"><i class="fa fa-sitemap fa-fw"></i> Multi-Level Dropdown<span class="fa arrow"></span></a>
                            <ul class="nav nav-second-level">
                                <li>
                                    <a href="#">Second Level Item</a>
                                </li>
                                <li>
                                    <a href="#">Second Level Item</a>
                                </li>
                                <li>
                                    <a href="#">Third Level <span class="fa arrow"></span></a>
                                    <ul class="nav nav-third-level">
                                        <li>
                                            <a href="#">Third Level Item</a>
                                        </li>
                                        <li>
                                            <a href="#">Third Level Item</a>
                                        </li>
                                        <li>
                                            <a href="#">Third Level Item</a>
                                        </li>
                                        <li>
                                            <a href="#">Third Level Item</a>
                                        </li>
                                    </ul>
                                    <!-- /.nav-third-level -->
                                </li>
                            </ul>
                            <!-- /.nav-second-level -->
                        </li>
                        <li>
                            <a href="#"><i class="fa fa-files-o fa-fw"></i> Sample Pages<span class="fa arrow"></span></a>
                            <ul class="nav nav-second-level">
                                <li>
                                    <a href="blank.html">Blank Page</a>
                                </li>
                                <li>
                                    <a href="login.html">Login Page</a>
                                </li>
                            </ul>
                            <!-- /.nav-second-level -->
                        </li>
                    </ul>
                </div>
                <!-- /.sidebar-collapse -->
            </div>
            <!-- /.navbar-static-side -->
        </nav>

        <div id="page-wrapper">

header.jsp를 '<%@include ...'로 처리한 후에는 다시 브라우저에서 화면이 깨지지 않는지 확인해야 한다.
list.jsp에 <%@include file="../includes/header.jsp" %> 추가로 넣는다.

예제) footer.jsp 적용
includes 폴더에 footer.jsp 생성하고 list.jsp에 하단에 있는 <div id='page-wrapper'>가 끝나는 태그부터 마지막까지 footer.jsp의 내용으로 작성한다.



         </div>
        <!-- /#page-wrapper -->

    </div>
    <!-- /#wrapper -->
   
    <!-- Bootstrap Core JavaScript -->
    <script src="/resources/vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Metis Menu Plugin JavaScript -->
    <script src="/resources/vendor/metisMenu/metisMenu.min.js"></script>

    <!-- DataTables JavaScript -->
    <script src="/resources/vendor/datatables/js/jquery.dataTables.min.js"></script>
    <script src="/resources/vendor/datatables-plugins/dataTables.bootstrap.min.js"></script>
    <script src="/resources/vendor/datatables-responsive/dataTables.responsive.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="/resources/dist/js/sb-admin-2.js"></script>

list.jsp에 <%@include file="../includes/footer.jsp" %>로 추가로  넣는다.

header.jsp와 마찬가지로 수정한 뒤에는 브라우저를 통해서 정상적으로 동작하는지 확인해야 한다.

jQuery 라이브러리 변경
jsp페이지를 작성하다 보면 JavaScript로 브라우저 내에서의 조작이 필요한 경우가 많다.
예제는 jQuery를 이용할 것인데, 문제는 위의 방식대로 처리했을 때 jQuery라이브러리가 footer.jsp 내에 포함되어 있다는 점이다.
성능을 조금 손해 보더라도 jQuery를 header.jsp에 선언해 두면 작성하는 JSP에 자유롭게 사용할 수 있으므로 수정해야한다.

footer.jsp의 상단에 있는 jquery.min.js 파일의 <script> 태그를 제거한다.
jQuery는 인터넷을 통해서 다운로드 받을 수 있게 jQuery의 링크를 검색해서 header.jsp 내에 추가해야 한다.
(https://developers.google.com/speed/libraries/와 같은 페이지를 이용한다.)

예제) header.jsp의 마지막 부분에 추가(jQeury)
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

반응형 웹 처리
SB Admin2는 반응형으로 설계되어 있어서 브라우저의 크기에 맞게 모바일 용으로 자동으로 변경되지만 jQuery의 최신 버전을 사용한 상태에서는 모바일 크기에서 '새로고침'시 메뉴가 펼쳐지는 문제가 
발생한다.
이 문제를 해결하기 위해서 includes 폴더 내 footer.jsp에 아래와 같은 코드를 기존 코드에 대신 추가한다.

예제) footer.jsp 추가
    <!-- Page-Level Demo Scripts - Tables - Use for reference -->
    <script>
    $(document).ready(function() {
        $('#dataTables-example').DataTable({// (클래스DataTable).DataTable 표시건수 제어기능, 페이징 기능, 정렬기능, 폴더기능 스크롤 기능이 CSS, js, jquery에 코딩되어있다.
            responsive: true
        });
        $(".sidebar-nav")
        .attr("class", "sidebar-nave navbar-collapse collapse")
        .attr("aria-expanded", "false")
        .attr("style", "height:1px");
    });
    </script>

목록 화면 처리
list.jsp 페이지의 일부를 include 하는 방식으로 처리했음에도 많은 HTML의 내용들이 존재하므로 아래와 같이 최소한의 태그들만 적용한다.
list.jsp에는 JSTL의 출력과 포맷을 적용할 수 있는 태그 라이브러리를 추가한다.
(JSTL 자주 사용될 수 있는 커스텀 태그들을 모아서 표준으로 모아둔 태그 라이브러리)https://mkil.tistory.com/249 개념 정리되어 있다.

예제) list.jsp JSTL 추가

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%> <!-- JSP 페이지 지시자 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %><!-- 변주지원, 제어문 페이지 관련처리 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %><!-- 다국어 문서처리 -->

<%@include file="../includes/header.jsp" %>
 <div class="row">
		<div class="col-lg-12">
		  	 <h1 class="page-header">Tables</h1>
		</div>
    <!-- /.col-lg-12 -->
	</div>
		  <!-- /.row -->
		  <div class="row">
		      <div class="col-lg-12">
		          <div class="panel panel-default">
		              <div class="panel-heading"> Board List Page
		              <button id="regBtn" type="button" class="btn btn-xs pull-right">Register New Board</button>
		              </div>
		              <!-- /.panel-heading -->
		              <div class="panel-body">
		                  <table  class="table table-striped table-bordered table-hover" >
		                      <thead>
		                          <tr>
		                              <th>#번호</th>
		                              <th>제목</th>
		                              <th>작성자</th>
		                              <th>작성일</th>
		                              <th>수정일</th>
		                          </tr>
		                      </thead>
				  </table>		                      
		    	             
		                <!-- /.table-responsive -->
		            </div>
		            <!-- /end panel-body -->
		        </div>
		        <!-- /end panel -->
		    </div>
		    <!-- /.col-lg-6 -->
	</div>
<!-- /.row -->

<%@include file="../includes/footer.jsp" %>            
  
수정된 list.jsp를 저장하고 브라우저를 통해서 원하는 형태로 출력되는지 확인

Model에 담긴 데이터 출력 
'/board/list'를 실행했을 때 이미 BoardController는 Model을 이용해서 게시물의 목록을 'list'라는 이름으로 담아서 전달했으므로 list.jsp에서는 이를 출력한다.
출력은 JSTL을 이용해서 처리한다.


예제) list.jsp 내에 <tbody> 태그와 각 <tr>을 추가

		                  <table  class="table table-striped table-bordered table-hover" >
		                      <thead>
		                          <tr>
		                              <th>#번호</th>
		                              <th>제목</th>
		                              <th>작성자</th>
		                              <th>작성일</th>
		                              <th>수정일</th>
		                          </tr>
		                      </thead>
		                      
		                      <c:forEach items="${list}" var="board">
		                      <tr>
		                      	<td><c:out value="${board.bno }"/></td>
		                      	<td><a href="/board/get?bno=<c:out value='${board.bno }'/>">
		                      	<c:out value="${board.title }"/> </a> </td>
		                      	<td><c:out value="${board.writer }"/></td>
		                      	<td><fmt:formatDate pattern="yyyy-MM-dd" value="${board.regdate }"/></td>
		                      	<td><fmt:formatDate pattern="yyyy-MM-dd" value="${board.updateDate }"/></td>
   		                      </tr>		                      
		                      </c:forEach>		       
		                    </table>

https://localhost/8081/board/list를 호출하면
BoardController에 list()메소드를 호출 service.getList()를 호출하여 mapper에 getList 실행 bno > 0 일때 DB tbl_table(테이블)에 데이터들을 조회하는 쿼리문이 실행된다.
브라우저를 통해서 결과를 확인하면 데이터 베이스에 있는 전체 목록이 출력된다.

등록 입력 페이지와 등록 처리
게시물의 등록 작업은 POST 방식으로 처리하지만, 화면에서 입력을 받아야 하므로 GET 방식으로 입력페이지를 볼 수 있도록 BoardController에 메서드를 추가한다.
GET방식은 호출Request(요청)을 하기 때문에 브라우저 페이지를 보려면 GET을 이용하고 POST는 입력받은 value값들을 DB로 보내줘야하기 때문에 POST를 사용한다.
즉, 기존 게시물을 보고 등록 하려고 추가

controller에 register() 메서드 추가와 register.jsp 폼 태그에 input과 textarea name 값을 BoardVO변수와 일치

예제) BoardController의 register() 메서드 추가
@GetMapping("/register")
	public void register() {
		
	}
화면에서 입력을 받아야 하므로 GET방식으로 입력 페이지를 볼 수 있게 @GetMapping 어노테이션 정의 

register()는 입력 페이지를 보여주는 역할만을 하기 때문에 별도의 처리가 필요하지 않는다.
views 폴더에는 includes를 적용한 입력 페이지를 작성한다.

예제) board폴더에 register.jsp 생성(list.jsp 코드 복사후 붙여넣기)

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%> <!-- JSP 페이지 지시자 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %><!-- 변주지원, 제어문 페이지 관련처리 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %><!-- 다국어 문서처리 -->

<%@include file="../includes/header.jsp" %>
 <div class="row">
		<div class="col-lg-12">
		  	 <h1 class="page-header">Board Register</h1>
		</div>
    <!-- /.col-lg-12 -->
	</div>
		  <!-- /.row -->
		  <div class="row">
		      <div class="col-lg-12">
		          <div class="panel panel-default">
		              <div class="panel-heading"> Board Register</div>
		              <!-- /.panel-heading -->
		              <div class="panel-body">
		              
		              	<form role="form" action="/board/register" method="post">
		              		<div class="form-group">
		              			<label>Title</label><input class="form-control" name="title">		           
		              		</div>
		              		
		              		<div class="form-group">
		              			<label>Text area</label>
		              			<textarea rows="3" class="form-control" name="content"></textarea>
		              		</div>
		              		
		              		<div class="form-group">
		              			<label>Writer</label><input class="form-control" name="writer">
						<!-- name 값을 BoardVO 클래스의 변수와 일치 시켜준다. 
							title, content, writer 키값인(primary key) *bno는 자동생성하므로 따로 입력값을 받지 않아도 된다.-->
		              		</div>
		              		
		              		<button type="submit" class="btn btn-default">Submit Button</button>
		              		<button type="reset" class="btn btn-default">Reset Button</button>
		              		
		              	</form>
		              
			            </div>
			            <!-- /end panel-body -->
			        </div>
			        <!-- /end panel -->
			    </div>
			    <!-- /.col-lg-6 -->
			</div>
		<!-- /.row -->

<%@include file="../includes/footer.jsp" %>            
  
register.jsp 페이지에서는 <form> 태그를 이용해서 필요한 데이터를 전송한다.
<input>이나 <textarea> 태그의 name 속성은 BoardVO 클래스의 변수와 일치시켜준다.
브라우저를 통해'/board/register' 화면이 제대로 출력되는지 확인한다.

화면이 정상적으로 보인다면 입력 항목을 넣어서 새로운 게시물이 등록되는지를 확인한다.
BoardController의 POST 방식으로 동작하는 register()는 redirect 시키는 방식을 이용하므로, 게시물의 등록 후에는 다시 'board/list'로 이동하게 된다.(POST 방식 --> 등록, 수정, 삭제)

한글 문제와 UTF-8 필터 처리

게시물의 등록은 정상적으로 이루어지지만 한글이 깨지는 문제가 발생한다.
새로운 게시물을 등록했을 때 만일 한글 입력에 문제가 있다는 것을 발견하면
1) 브라우저에서 한글이 깨져서 전송되는지를 확인한다.
2) 1)이 문제가 없다면 스프링 MVC 쪽에서 한글을 처리하는 필터를 등록해야 한다.

브라우저에서 전송되는 데이터는 F12(개발자 도구)를 이용해서 확인할 수 있다.
F12에 Network 탭을 열어둔 상태에서 데이터를 보내면 해당 내용을 볼 수 있으므로 이때 POST 방식으로 제대로 전송되었는지, 한글이 깨진 상태로 전송된 것인지를 확인
한글을 문제없이 보냈음을 확인하면, 문제는 Controller 혹은 데이터베이스 쪽이라는 것을 알 수 있다.
BoardController와 BoardServiceImpl을 개발할 때는 이미 Lombok의 로그를 이용해서 필요한 기능들을 기록하는 log.info()을 사용했으므로 확인
로그 확인시 BoardController에 전달도리 때 이미 한글이 깨진 상태로 처리된 것을 확인할 수 있다.

이 문제를 해결하기 위해서 web.xml에 필터를 추가한다.
예제) web.xml에 필터 추가
	<!-- UTF-8 필터처리 (controller에서 절달될 때 이미 한글이 깨진 상태를 해결하기 위한) -->
	<filter>
		<filter-name>encoding</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
	</filter>
	
	<filter-mapping>
		<filter-name>encoding</filter-name>
		<servlet-name>appServlet</servlet-name>
	</filter-mapping>

한글에 대한 처리가 끝난 후 다시 게시물을 작성해 보면 한글에 문제가 없이 입력되는 것을 확인할 수 있다.
이미 보내진 데이터는 깨진상태로 되고 필터 추가후 등록한 데이터들은 깨짐현상이 없어짐

재전송(redirect)처리
BoardController에서 register() 메서드는 'redirect:/board/list'를 전송하는데 브라우저는 이를 통보받은 후 '/board/list'로 이동하게 된다.
재전송을 하지 않는다면 사용자는 브라우저의 '새로고침'을 통해서 동일한 내용을 계속 서버에 등록할 수 있기 때문에(흔히 도배라고 표현하는) 문제가 발생한다.
브라우저에서는 이런 경우 경고창을 보여주기는 하지만 근본적으로 차단하지는 않는다.

따라서 등록, 수정, 삭제 작업은 처리가 완료된 후 다시 동일한 내용을 전송할 수 없도록 아예 브라우저의 URL을 이동하는 방식을 이용한다.
이러한 과정에서 하나 더 신경써야 하는 것은 브라우저에 등록, 수정, 삭제의 결과를 바로 알 수 있게 피드백을 줘야한다는 점이다.
경고창이나 <div>를 이용하는 모달창을 이용해서 이러한 작업을 처리한다.

※ redirect는 POST 방식으로 보내도 redirect가 발생하면 새로운 HTTP GET 요청이 시작된다.
때문에 redirect 실행 이전에 수행된 모델 데이터는 소멸하게 되어 redirect로 모델을 전달하는 것은 의미가 없다.
redirect attribute는 redirect 전에 모든 Flash Attribute을 session에 save한다.
BoardController에서 redirect 처리를 할 때 RedirectAttributes라는 특별한 타입의 객체를 이용했다.
addFlashAttribute()의 경우 이러한 처리에 적합한데, 그 이유는 일회성으로만 데이터를 전달하기 때문이다.
addFlashAttribute()로 보관된 데이터는 단 한 번만 사용할 수 있게 보관된다.
(내부적으로는 HttpSession을 이용해서 처리)


예제) views/board/list.jsp에 script 추가

<script type="text/javascript">
	$(document).ready(function(){
		
	var result = '<c:out value="${result}"/>';
	// <c:out> 태그를 이용하는 이유는 보안성 문제 html이나 스크립트가 실행되어 위험 ==> jstl에 core을 사용 (출력과 포맷을 사용하게 하는 태그 라이브러리)
	});
</script>

새로운 게시물이 등록된 직후에 위 script는 F12에서 확인할 수 있다.
result변수에 값 등록된 bno(번호)을 확인할 수 있다.

새로운 게시물의 번호는 addFlashAttribute()로 저장되었기 때문에 한 번도 사용된 적이 없다면 위와 같이 값을 만들어 내지만 '/board/list'/를 호출하거나, '새로고침'을 통해서 호출하는 경우는
아무런 내용이 없게된다.

addFlashAttribute()를 이용해서 일회성으로만 데이터를 사용할 수 있으므로 이를 이용해서 경고창이나 모달창 등을 보여주는 방식으로 처리할 수 있다.

모달(Modal)창 보여주기
최근에는 브라우에서 경고창(alert)을 띄우는 방식보다 모달창(Modal)을 보여주는 방식을 많이 사용한다.
BootStrap은 모달창을 간단하게 사용할 수 있으므로 목록 화면에서 필요한 메시지를 보여주는 방법을 사용해 본다.
모달창은 기본적으로 <div>를 화면에 특정 위치에 보여주고, 배경이 되는 <div>에 배경색을 입혀서 처리한다. 
모달창은 활성화된 <div>를 선택하지 않고는 다시 원래의 화면을 볼 수 없도록 막기 때문에 메시지를 보여주는데 효과적인 방식이다.

// 추가 설명 /
모달(Modal)이란, 사용자의 이목을 집중시키기 위한 그래픽 인터페이스 창이다.

좀 더 자세히 이야기하자면 하나의 페이지에서 하나의 작은 다른 페이지를 띄워 이 페이지에 대한 조작이 종료되기 전까지
부모페이지로 돌아가지 못하도록 만든 창이다. 그래서 모달 창을 이용하면 사용자의 상호작용을 요구로 하고, 사용자가 상호작용을 할 때까지 부모 페이지에 대한 어떠한 조작도 못하도록 되어있다.
그래서 사용자로부터 특정 동작/메세지에 대한 주목이 필요할 때 모달을 사용하게 된다.

팝업과 모달은 비슷하지만 팝업은 다른 브라우저 페이지를 열기 때문에 부모 페이지에 대한 조작을 할 수 있다.
모달은 CSS에서 position을 fix하고  부모 페이지를 전체로 뒤덮어 버린다.(display속성을 hidden으로 하여 보이지는 않는다.)


예제) list.jsp 모달창 추가

         <!-- Modal 추가-->
                            <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
                                <div class="modal-dialog">
                                    <div class="modal-content">
                                        <div class="modal-header">
                                            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                                            <h4 class="modal-title" id="myModalLabel">Modal title</h4>
                                        </div>
                                        <div class="modal-body">
                                            처리가 완료되었습니다.
                                        </div>
                                        <div class="modal-footer">
                                            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                                            <button type="button" class="btn btn-primary">Save changes</button>
                                        </div>
                                    </div>
                                    <!-- /.modal-content -->
                                </div>
                                <!-- /.modal-dialog -->
                            </div>
                            <!-- /.modal -->
		             
모달창을 보여주는 작업은 jQuery를 이용해서 처리할 수 있다.

script도 추가

<script type="text/javascript">
	$(document).ready(function(){
		
		var result = '<c:out value="${result}"/>';
		
		checkModal(result);
		
		function checkModal(result) {
			
			if (result === '') {
				return;
			}
			
			if (parseInt(result) > 0) {
				$(".modal-body").html("게시글 " + parseInt(result) + " 번이 등록되었습니다.");
			}	// <div class="modal-body>에 "처리가 완료되었습니다"라는 멘트를 "게시글 1번이 등록 되었습니다."로 변경
			
			$("#myModal").modal("show");
		}
		
	});
</script>

checkModal()함수는 파라미터에 따라서 모달창을 보여주거나 내용을 수정한 뒤 보이도록 작성
checkModal()에서는 새로운 게시글이 작성되는 경우 RedirectAttributes로 게시물의 번호가 전송되므로 이를 이용해서 모달창의 내용을 수정한다.
$("#modal").modal('show')를 호출하면 모달창이 보이게 된다.
이제 '/board/register'를 이용해서 새로운게시물을 작성하고 나면 자동으로 '/board/list'로 이동하면서 모달창이 보이게 된다.

목록에서 버튼으로 이동하기
게시물의 작성과 목록 페이지로 이동이 정상적으로 동작했다면, 마지막으로 목록 페이지 상단에 버튼을 추가해서 등록 작업을 시작할 수 있게 처리하는 것 이다.

예제) list.jsp 버튼 추가

<div class="panel-heading"> Board List 
	<button id="regBtn" type="button" class="btn btn-xs pull-right">Register New Board</button>
</div>

list.jsp 하단의 jQuery를 이용하는 부분에서 해당 버튼을 클릭했을 때의 동작을 정의한다.

<script type="text/javascript">
	$(document).ready(function(){
		
		var result = '<c:out value="${result}"/>';
		
		checkModal(result);
		
		function checkModal(result) {
			
			if (result === '') {
				return;
			}
			
			if (parseInt(result) > 0) {
				$(".modal-body").html("게시글 " + parseInt(result) + " 번이 등록되었습니다.");
			}	// <div class="modal-body>에 "처리가 완료되었습니다"라는 멘트를 "게시글 1번이 등록 되었습니다."로 변경
			
			$("#myModal").modal("show");
		}
		// 리스트 header에 Register New Button클릭시 발생하는 이벤트 처리
		$("#regBtn").on("click", function () {
			
			self.location = "/board/register"
			
		});
	});
</script>

Register New Board 버튼을 클릭하면 게시물의 등록 페이지로 이동할 수 있다.

조회 페이지와 이동
게시물의 등록과 리스트 처리가 끝났다면 가장 중요한 틀은 완성되었다고 볼 수 있다.
다음으로는 목록 페이지에서 링크를 통해서 GET방식으로 특정한 bno(번호)의 게시물을 조회할 수 있는 기능을 작성한다.

조회페이지 작성 
조회 페이지는 입력 페이지와 거의 유사하지만 게시물 번호(bno)가 출력된다는 점과 모든 데이터를 읽기 전용으로 처리된다는 점이 가장 큰 차이점이다.

게시물의 조회는 BoardController에서 get() 메서드로 구성되어 있다.

@GetMapping("/get")
	public void get(@RequestParam("bno") Long bno, Model model) {
		
		log.info("/get");
		model.addAttribute("board", service.get(bno));
	}

예제) views/board 폴더 내 get.jsp를 register.jsp(생성)를 복사해서 작성한다.
get.jsp는 게시물 번호를 보여줄 수 있는 필드를 추가하고, 모든 데이터는 readonly를 지정해서 작성한다.
register.jsp에 있던 <form> 태그는 조회 페이지에서는 그다지 필요하지 않으므로 제거하는 대신 마지막에는 수정/삭제 페이지로 이동하거나
원래의 목록 페이지로 이동할 수 있는 버튼을 추가
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%> <!-- JSP 페이지 지시자 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %><!-- 변주지원, 제어문 페이지 관련처리 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %><!-- 다국어 문서처리 -->

<%@include file="../includes/header.jsp" %>
 <div class="row">
		<div class="col-lg-12">
		  	 <h1 class="page-header">Board Read</h1>
		</div>
    <!-- /.col-lg-12 -->
	</div>
		  <!-- /.row -->
		  <div class="row">
		      <div class="col-lg-12">
		          <div class="panel panel-default">
		              <div class="panel-heading"> Board Read Page</div>		              
		              <!-- /.panel-heading -->
		              <div class="panel-body">
		                  
		                  <div class="form-group">
		                  	<label>Bno </label>
		                  	<input class="form-control" name="bno" value="<c:out value='${board.bno }'/>" readonly="readonly"> 
		                  </div>
		                  
		                  <div class="form-group">
		                  	<label>Title </label>
		                  	<input class="form-control" name="title" value="<c:out value='${board.title }'/>" readonly="readonly"> 
		                  </div>
		                  
		                  <div class="form-group">
		                  	<label>Text area </label>
		                  	<textarea class="form-control" rows="3" name="content" readonly="readonly"><c:out value='${board.title }'/></textarea> 
		                  </div>
		                  
		                  <div class="form-group">
		                  	<label>Writer </label>
		                  	<input class="form-control" name="writer" value="<c:out value='${board.writer }'/>" readonly="readonly"> 
		                  </div>
		                  
		                  <button data-oper="modify" class="btn btn-default" onclick="location.href='/board/modify?bno=<c:out value="${board.bno }"/>'">Modify</button>
		                  <button data-oper="list" class="btn btn-info" onclick="location.href='/board/list'">List</button>
		                  	                    
		                </div>
		                <!-- /.table-responsive -->
		            </div>
		            <!-- /end panel-body -->
		        </div>
		        <!-- /end panel -->
		    </div>
		    <!-- /.col-lg-6 -->
	</div>
<!-- /.row -->

<%@include file="../includes/footer.jsp" %>            

브라우저에서는 '/board/get?bno=1'과 같이 게시물의 번호를 반드시 파라미터로 전달해야 한다.
파라미터로 전달하는 bno 값이 존재한다면 해당 페이지에서 데이터를 볼 수 있다.

화면 하단의 버튼은 '/board/list'와 '/board/modify?bno=xx'와 같이 이동하는 링크를 추가한다.

 
목록 페이지와 뒤로 가기 문제

목록 페이지에서 각 게시물 제목에 <a> 태그를 적용해서 조회 페이지로 이동하게 처리한다.
최근에 웹페이지들은 사용자들의 트래픽을 고려해 목록 페이지에서 새창을 띄워서 조회 페이지로 이동하는 방식을 선호하지만 전통적인 방식에서는 현재창 내에서 이동하는 방식을 사용한다.

조금 관심을 가지고 웹페이지들을 이용하다 보면 의외로 이러한 처리가 제대로 되지 않는 경우를 많이 보게된다.
예를들어, '뒤로 가기'를 하면 다시 다운로드를 시도하거나 경고창이 뜨는 경험들을 할 수 있다.
'뒤로 가기'의 해결은 조금 어려운 내용들이 나올수 있으므로 학습에 어려움이 있다면 건너뛰는 선택도 나쁘지 않다.

목록에서 조회 페이지로의 이동

예제) list.jsp 페이지 <a>태그 추가
<td><a href="/board/get?bno=<c:out value='${board.bno }'/>">
<c:out value="${board.title }"/> </a> </td>

브라우저를 통해서 화면을 확인해 보면 각 게시물의 제목에 링크가 걸리는 것을 확인할 수 있고, 제목을 클릭하면 정상적으로 조회 페이지로 이동하는 것을 볼 수 있다.
조회 페이지로의 이동은 JavaScript를 이용해서 처리할 수도 있고, 위와 같이 직접<a> 태그를 이용해서도 처리가 가능하다.
만일 조회 페이지를 이동하는 방식이 아니라 '새창'을 통해서 보고 싶다면, <a> 태그의 속성으로 target='_blank'를 지정하면 된다.
<a> 태그와 <form> 태그에는 target 속성을 지정할 수 있는데 '_blank'는 새로운 창에서 처리된다.

목록에서 target='_blank'를 지정했을 때 새로운 창이 옆에 뜨는 모습이다.

뒤로 가기의 문제 

동일한 페이지 내에서 목록 페이지와 조회 페이지의 이동은 정상적으로 처리된 것 같아 보이지만 문제가 남아 잇다.
'등록 -> 목록 -> 조회' 까지는 순조롭지만 브라우저의 '뒤로 가기'를 선택하는 순간 다시 게시물의 등록 결과를 확인하는 방식으로 동작한다는 것이다.
이러한 문제가 생기는 원인은 브라우저에서 '뒤로 가기'나 '앞으로 가기'를 하면 서버를ㄹ 다시 호출하는 게 아니라 과거에 자신이 가진 모든 데이터를 활용하기 때문이다.
브라우저에서 조회 페이지와 목록 페이지를 여러 번 앞으로 혹은 뒤로 이동해도 서버에는 처음에 호출을 제외하고 별다른 변화가 없는 것을 확인할 수 있다.

이 문제를 해결하려면 window의 histroy 객체를 이용해서 현재 페이지의 모달창을 띄울 필요가 없다고 표시를 해 두는 방식을 이용한다.
window의 histroy 객체는 스택 구조로 동작한다.

예제) list.jsp script 추가

<script type="text/javascript">
	$(document).ready(function(){
		
		var result = '<c:out value="${result}"/>';
		
		checkModal(result);
		
		// 뒤로가기 문제 오류 수정 여기서 부터 
		history.replaceState({}, null, null);
		
		function checkModal(result) {
			
			if (result === '') {
				return;
			}
			
			if (parseInt(result) > 0) {
				$(".modal-body").html("게시글 " + parseInt(result) + " 번이 등록되었습니다.");
			}
		// 여기까지 코드 수정
			$("#myModal").modal("show");
		}
		
		// 리스트 header에 Register New Button클릭시 발생하는 이벤트 처리
		$("#regBtn").on("click", function () {
			
			self.location = "/board/register"
			
		});
		
	});

</script>

기존과 달라진 점은 맨 마지막에 추가도니 history.State() 부분과 checkModal()에서 histroy.state를 체크하는 부분
JavaScript의 처리는 우선 checkModal()을 실행하는데, 만일 등록된 후에 이동한 것이라면 모달창이 보이게 된다.

모달창이 보이는 여부와 관계업이 JavaScript의 모든 처리가 끝나게 되면 histroy에 쌓이는 상태는 모달창을 보여줄 필요가 없는 상태가 된다.

게시물의 수정/삭제 처리
게시물의 수정 작업은 일반적으로 
1) 조회 페이지에서 직접 처리하는 방식이나 
2) 별도의 수정/삭제 페이지를 만들어서 해당 페이지에서 수정과 삭제를 처리하는 방식을 많이 사용한다.
최근에는 게시물의 조회 페이지에서 댓글 등에 대한 처리가 많아지면서 수정과 삭제는 별개의 페이지에서 하는 것이 일반적이다.

조회페이지에서는 GET 방식으로 URL을 통해서 수정/삭제 버튼이 존재하는 화면을 볼 수 있게 제작해야 한다.
수정 혹은 삭제 작업은 POST 방식으로 처리되고, 결과는 다시 목록 화면에서 확인할 수 있는 형태로 제작한다.

수정/삭제 페이지로 이동
BoardController에서 수정/삭제가 가능한 화면으로 이동하는 것은 조회 페이지와 같다.

예제) BoardController 기존의 get()메소드를 수정

	//@GetMapping이나 @PostMapping 등에는 URL을 배열로 처리할 수 있다.
	// 즉, 하나의 메소드로 여러개의 URL을 처리할 수 있다.
	@GetMapping({"/get", "/modify"})
	public void get(@RequestParam("bno") Long bno, Model model) {
		
		log.info("/get or modify");
		model.addAttribute("board", service.get(bno));
	}

@GetMapping이나 @PostMapping 등에는 URL을 배열로 처리할 수 있으므로, 위와 같이 하나의 메서드로 여러 URL을 처리할 수 있다.

브라우저에서는 'board/modify?bno=30'과 같은 방식으로 처리하므로, views 폴더 내 modify.jsp를 작성한다.
modify.jsp는 get.jsp와 같지만 수정이 가능한 '제목'이나 '내용' 등이 readonly 속성이 없도록 작성한다.
POST 방식으로 처리하는 부분을 위해서는 <form> 태그로 내용들을 감싸게 한다.

예제) modify.jsp 제목과 내용이 수정이 가능하게 readonly 속성을 없앤다.

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%> <!-- JSP 페이지 지시자 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %><!-- 변주지원, 제어문 페이지 관련처리 -->
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %><!-- 다국어 문서처리 -->

<%@include file="../includes/header.jsp" %>
 <div class="row">
		<div class="col-lg-12">
		  	 <h1 class="page-header">Board Modify Page</h1>
		</div>
    <!-- /.col-lg-12 -->
	</div>
		  <!-- /.row -->
		  <div class="row">
		      <div class="col-lg-12">
		          <div class="panel panel-default">
		              <div class="panel-heading"> Board Modify Page</div>		              
		              <!-- /.panel-heading -->
		              <div class="panel-body">
		                  <form role="form" action="/board/modify" method="post">
		                  	
		                  	<div class="form-group">
		                  	<label>Bno </label>
		                  	<input class="form-control" name="bno" value="<c:out value='${board.bno }'/>" readonly="readonly"> 
		                  </div>
		                  
		              		<div class="form-group">
		              			<label>Title</label>
		              			<input class="form-control" name="title" value="<c:out value='${board.title }'/>">		           
		              		</div>
		              		
		              		<div class="form-group">
		              			<label>Text area</label>
		              			<textarea rows="3" class="form-control" name="content"><c:out value='${board.content }'/></textarea>
		              			
		              		</div>
		              		
		              		<div class="form-group">
		              			<label>Writer</label>
		              			<input class="form-control" name="writer" value="<c:out value='${board.writer}'/>" readonly="readonly" >
		              		</div>
		              		
		              	
		              		<button type="submit" data-oper="modify" class="btn btn-default" >Modify</button>
		              		<button type="submit" data-oper="remove" class="btn btn-danger" >Remove</button>
		              		<button type="submit" data-oper="list" class="btn btn-info" >List</button>
		              	</form>
		            	                    
		                </div>
		                <!-- /.table-responsive -->
		            </div>
		            <!-- /end panel-body -->
		        </div>
		        <!-- /end panel -->
		    </div>
		    <!-- /.col-lg-6 -->
	</div>
<!-- /.row -->

<%@include file="../includes/footer.jsp" %>       

<form> 태그는 action 속성을 'board/modify'로 지정했지만, 삭제를 하면 '/board/remove'와 같이 action 속성의 내용을 수정해서 사용한다.
게시물의 '제목', '내용'은 수정이 가능한 형태로사용해서 사용자가 편집할 수 있게 한다.
등록일과 수정일은 나중에 BoardVO로 수집되어야 하므로 날짜 포맷을 'yyyy/mm/dd'의 포맷으로 해야한다.
(만일 포맷이 맞지 않으면 파라미터 수집 부분에 문제가 생기므로 주의가 필요)
마지막에는 '수정/삭제/목록'등의 버튼을 추가한다.

브라우저에서는 'http://localhost:8081/board/modify?bno=19(존재하는 게시물 번호)와 같이 게시물 번호를 이용해서 수정 페이지가 정상적으로 출력되는지 확인한다.

스크립트 부분에서는 위의 버튼에 따라서 다른 동작을 할 수 있도록 수정한다.

예제) modify.jsp script 추가

<%@include file="../includes/footer.jsp" %>            
<script type="text/javascript">

	$(document).ready(function () {
		var formObj = $("form");
		
		$('button').on("click", function (e) {
			
			e.preventDefault();
			
			var operation = $(this).data("oper");
			
			console.log(operation);
			
			if (operation === 'remove') {
				formObj.attr("action", "/board/remove");
			}
			else if (operation === "list") {
				// move to list 
				//self.location = "/board/list"; p266 페이지에서 수정하기 전 list버튼 클릭시 로직
				formObj.attr("action", "/board/list").attr("method", "get");
				formObj.empty();
			}
			formObj.submit();
		});
		
	});

</script>


게시물 수정/삭제 확인

화면에서 게시물을 수정한 후에 'modify' 버튼을 통해서 BoardController에 수정을 요청 Modify 버튼을 클릭하면 BoardController에서는 주어진 파라미터들을 BoardVO로 처리하게 되고, 
수정된 값이 수집된다.

게시물이 수정된 후에는 다시 'Board/list' 화면으로 이동하게 된다.
이경우에 대한 처리는 이미 완료되었으므로 모달창을 통해서 메시지를 확인할 수 있다.

화면에서 'Remove' 버튼을 클릭하게 되면 <form> 태그의 action값이 '/board/remove'가 되고 데이터들이 전송된다. 물로 BoardController에서는 bno 값 하나만 필요하지만 처리에는 문제가 없다.
삭제할 때 목록 페이지로 이동하게 된다.

조회 페이지에서 <form> 처리 
게시물의 조회 페이지에서는 수정과 삭제가 필요한 페이지로 링크를 처리해야 한다.
직접 버튼에 링크를 처리하는 방식을 사용하여 처리하였지만, 나중에 다양한 상황을 처리하기 위해서 <form> 태그를 이용해서 수정해 본다.

예제) views/board/get.jsp <form> 태크 수정
 
  <button data-oper="modify" class="btn btn-default" onclick="location.href='/board/modify?bno=<c:out value="${board.bno }"/>'">Modify</button>
  <button data-oper="list" class="btn btn-info" onclick="location.href='/board/list'">List</button>
   
  <form id="operForm" action="/board/modify" method="get">
  	<input type="hidden" id="bno" name="bno" value="<c:out value='${board.bno}'/>">
  </form>

브라우저에는 <form> 태그의 내용은 보이지 않고 버튼만 보이게 된다.(hidden 속성)		                    

예제) get.jsp script 추가 
	     ( 사용자가 버튼을 클릭하면 operForm이라는 id를 가진 <form> 태그를 전송해야 하므로 추가적인 javaScript 처리가 필요하다.

<script type="text/javascript">
	$(document).ready(function () {
		
		var operFrom = $("#operForm");
		
		$("button[data-oper='modify']").on("click", function (e) {
			
			operForm.attr("action", "/board/modify").submit();
			
		});
		
		$("button[data-oper='list']").on("click", function (e) {
			
			operForm.find("#bno").remove();
			operForm.attr("action", "/board/list");
			operFrom.submit();
			
		});
	});	
</script>  

사용자가 수정 버튼을 누르는 경우에는 bno 값을 같이 전달하고 <form> 태그를 submit 시켜서 처리한다. 
만일 사용자가 list로 이동하는 경우에는 아직 아무런 데이터도 필요하지 않으므로 <form> 태그 내의 bno 태그를 지우고 submit을 통해서 리스트 페이지로 이동한다.

수정 페이지에서 링크 처리
수정 페이지에서는 사용자가 다시 목록 페이지로 이동할 수 있도록 하기 위해서 JavaScript의 내용을 조금 수정한다.

예제) views/board/modify.jsp script 수정

<script type="text/javascript">

	$(document).ready(function () {
		var formObj = $("form");
		
		$('button').on("click", function (e) {
			
			e.preventDefault();
			
			var operation = $(this).data("oper");
			
			console.log(operation);
			
			if (operation === 'remove') {
				formObj.attr("action", "/board/remove");
			}
			else if (operation === "list") {
				// move to list 
				formObj.attr("action", "/board/list").attr("method", "get");
				formObj.empty();
			}
			formObj.submit();
		});
		
	});

수정도니 내용은 클릭한 버튼이 List인 경우 action 속성과 method 속성을 변경한다.

'/board/list'로의 이동은 아무런 파라미터가 없기 때문에 <form> 태그의 모든 내용은 삭제한 상태에서 submit()을 진행한다. 
이후에는 코드는 실행되지 않도록 return을 통해서 제어한다.

오라클 데이터베이스 페이징 처리

구현된 기능들 중  가장 미숙한 부분은 목록 페이지이다.
목록 페이지는 기본적으로 페이징(paging) 처리가 필요한데 상식적으로 생각해 봐도 수많은 데이터를 한 페이지에서 보여주면, 처리 성능에 영향을 미친다.
또한, 브라우저에서도 역시 데이터의 양이날 처리 속도에 문제를 일으키게 된다.

일반적으로 페이징 처리는 크게 번호를 이용하거나 '계속 보기'의 형태로 구현된다.
번호를 이용한 페이징 처리는 과거 웹 초기부터 이어오던 방식이고, '계속 보기'는 Ajax와 앱이 등장한 이후에 '무한 스크롤'이나 '더 보기'와 같은 형태로 구현된다.
오라클에서 페이징 처리하는 것은 MySQL에 비해서 추가적인 지식이 필요하다.
-- 개인적인 생각
페이징은 order by(정렬)을 위함이다.
SQL에서 많은 데이터를 order by를 하게 되면 데이터를 찾는 시간이 오래걸려 성능에 문제를 줄 수 있다.
그것을 개선하기 위해 index를 사용한다. pk_table를 만들어 본 테이블에 접근하여 이미 정렬된 데이터를 빠르게 가져올 수 가 있다.
많은 데이터들을 정렬하여 가져와야 한다.
그러면 속도 개선이 필요한다.
1. 인덱스 처리
2. 힌트 처리(어떻게 처리할 거다--> 테이블 성능에는 영향을 주지 않는다.)
3. 필요한 데이터만 분리해서 가져온다.

order by의 문제
프로그램을 이용해서 정렬을 해 본 적이 있다면 데이터의 양이 많을수록 정렬이라는 작업이 얼마나 많은 리소스를 소모하는지 알 수 있다.
데이터베이스는 경우에 따라서 수백만 혹은 천 만개 이상의 데이터를 처리하기 때문에 이 경우 정렬을 하게 되면 엄청나게 많은 시간과 리소르를 소모하게 된다.

데이터베이스를 이용할 때 웹이나 애플리케이션에 가장 신경 쓰는 부분은 
1) 빠르게 처리되는 것
2) 필요한 양만큼만 데이터를 가져오는것

예를 들어, 거의 모든 웹페이지에서 페이징을 하는 이유는 최소한의 필요한 데이터만을 가져와서 빠르게 화면에 보여주기 위함이다.

만일 수백 만개의 데이터를 매번 정렬을 해야 하는 상황이라면 사용자는 정렬된 결과를 볼 때까지 오랜 시간을 기다려야만 하고,
특히 웹에서 동시에 여러 명의 사용자가 정렬이 필요한 데이터를 요청하게 된다면 시스템에는 많은 부하가 걸리게 되고 연결 가능한 커넥션의 개수가 점점 줄어서 
서비스가 멈추는 상황을 초래하게 된다.

빠르게 동작하는 SQL을 위해서는 먼저 order by를 이용하는 작업을 가능하면 하지말아야 한다.
order by는 데이터가 많은 경우에 엄청난 성능의 저하를 가져오기 때문에
1) 데이터가 적은 경우와
2) 정렬을 빠르게 할 수 있는 방법이 있는 경우가 아니라면 order by는 주의해야 한다.

실행 계획과 order by
오르칼의 페이징 처리를 제대로 이해하기 위해서 반드시 알아두어야 하는 것이 실행 계획(execution plan)이다.
실행 계획은 말 그대로 'SQL을 데이터베이스에서 어떻게 처리할 것인가?'에 대한 것이다.
SQL이 데이터베이스에 전달되면 데이터베이스는 여러 단계를 거쳐서 해당 SQL을 어떤 순서와 방식으로 처리할 것인지 계획을 세우게 된다.
SQL문 과정
SQL 파싱 -> SQL 최적화 -> SQL 실행

SQL 파싱 단계에서는 
1) SQL 구문에 오류가 있는지
2) SQL을 실행해야 하는 대상 객체(데이블, 제약 조건, 권한 등)가 존재하는지를 검사한다.

SQL 최적화 단계에서는 SQL이 실행하는데 필요한 비용(cost)을 계산하게 된다. 이 계산된 값을 기초로 해서 어떤 방식으로 실행하는 것이 가장 좋다는 것을 판단하는 '실행 계획(execution plan)'을 
세우게 된다.

SQL 실행 단계에서는 세워진 실행 계획을 통해서 메모리상에서 데이터를 읽거나 물리적인 공간에서 데이터를 로딩하는 등의 작업을 하게 된다.
개발자들은 도구를 이용하거나 SQL Plus 등을 이용햇 특정한 SQL에 대한 실행 계획을 알아볼 수 있다.

SQL Developer에서 확인

예제) select * from tbl_baord order by bno desc;

상단의 버튼 중에는 SQL에 대해서 '실행계획'을 쉽게 볼 수 있도록 버튼이 제공되어 있다.
F10을 눌러도 된다.

실행 계획을 보면 트리 구조로 방전 실행한 SQL이 어떻게 처리된 것인지를 알려준다. 
흔히 SQL 튜닝이라고 하는 작업은 이를 보고 어떤 방식이 더 효과적인지를 판단해서 수정하게 된다.

위 select 문을 실행후 실행 계획을 해석해 보면
'tbl_board' 테이블을 'FULL'로 접근하고 정렬했다는 것을 의미한다.
'FULL'이라는 의미는 테이블 내의 모든 데이터를 스캔(scan)했다는 의미이다.
실행계획을 세우는 것은 데이터 베이스에서 하는 역할이기 때문에 데이터의 양이나 제약 조건 등의 여러 상황에 따라서 데이터 베이스는 실행 계획을 다르게 작성한다.

테스트를 위해서 데이터가 좀 많아지도록 SQL을 여러 번 실행해서 데이터를 수 백 만개로 만든 후에 커밋
예제) 
-- 기존에 있던 데이터를 insert 하는 재귀 복사 
insert into tbl_board ( bno, title, content, writer)
    (select seq_board.nextval, title, content, writer from tbl_board);

위의 insert문을 여러 번 실행하게 되면 현재 tbl_board 테이블의 데이터 수만큼 다시 insert가 진행된다.
결과를 보면 insert문을 실행할 때마다 2배씩 데이터가 늘어나게 된다.

데이터가 많아지면 정렬에 그만큼의 시간을 소모하게 된다.
고의적으로 bno라는 칼럼의 값에다가 +1을 추가한 값을 역순으로 정렬하는 SQL을 만든다.
예제) 
select * from tbl_board order by bno +1 desc;

연산 작업이 추가되기는 했지만 SQL문의 결과가 나오는데 16초가 걸렸다.(실행 시간은 시스템 상황이나 DB의 상황에 따라 차이가 난다.)
실행 계획을 보면 데이블 전체를 스캔 (조사)하는 것을 볼 수 있다.
실행 계획에 왼쪽 트리 구조를 보면 'sort'가 일어난 것을 볼 수 있다. 이때 가장 많은 시간을 소모하는 작업은 정렬하는 작업이다.

위이 SQL에서 'order by bno +1 desc'라는 조건에서 '+1'을 하는 것은 정렬에 아무런 도움을 주지 않으므로 아래와 같이 수정후 실행한다.
예제) select * from tbl_board order by bno desc;

연산이라는 차이가 있기는 하지만 실행에 걸리는 시간은 차이가 많이 난다.
(연산이 빠지면 처리하는 시간이 단축 된다.)

기존의 SQL이 TBL_BOARD(테이블명) 테이블 전체를 스캔했지만, 이번에는 PK_BOARD라는 것을 이용해서 접근하고 기존과 달리 맨 위의 SORT 과정이 없는 것을 볼 수 있다.

이것을 이해하려면 데이터베이스의 index에 대해서 알아야 한다.

ORDER BY 보다는 인덱스

데이터가 많은 상태에서 정렬작업이 문제가 된다는 사실을 알았다.
가장 일반적인 해결책은 '인덱스(index)'를 이용해서 정렬을 생략하는 방법이다.
인덱스라는 존재가 이미 정렬된 구조이므로 이를 이용해서 별도의 정렬을 하지 않는 방법이다.

예제) 쿼리
select /*+ index_desc(tbl_board pk_board) */
    *
from
    tbl_board
where bno > 0;

SQL의 실행 계획에서 주의해서 봐야 하는 부분은 
1) SORT를 하지 않았다는 점
2) TBL_BOARD를 바로 접근하는 것이 아니라 PK_BOARD를 이용해서 접근한 점
3) RANGE SCAN DESCENDING, BY INDEX ROWID로 접근했다는 점
이다.

PK_BOARD라는 인덱스
테이블을 생성했을 떄 SQL
create table tbl_board(
    bno number(10,0),
    title varchar2(200) not null,
    content varchar2(2000) not null,
    writer varchar2(50) not null,
    regdate date default sysdate,
    updatedate date default sysdate
);

alter table tbl_board add CONSTRAINT pk_board primary key (bno);

테이블을 생성할 때 제약 조건으로 PK를 지정하고 PK의 이름이 'pk_board'라고 지정하였다.
데이터베이스에서 PK는 상당히 중요한 의미를 가지는데, 흔히 말하는 '식별자'의 의미와 '인덱스'의 의미를 가진다.

'인덱스'는 말그대로 '색인'이다. 우리가 가장 흔히 접하는 인덱스는 도서 뒤쪽에 정리되어 있는 색인이다.
즉, 책 맨 뒤쪽에 있는 찾아보기랑 같은 것이다.
색인은 사람들이 쉽게 찾아볼 수 있게 알파벳 순서나 한글 순서로 정렬한다.
이를 통해서 원하는 내용을 위에서부터 혹은 반대로 찾아나가는데 이를 '스캔(scan)'한다고 표현한다.

데이터베이스에 테이블을 만들 때 PK를 부여하면 지금까지 얘기한 '인덱스'라는 것이 만들어진다.
데이터베이스를 만들 때 PK를 지정하는 이유는 '식별'이라는 의미가 있지만,
구조상으로는 '인덱스'라는 존재(객체)가 만들어지는 것을 의미한다.
TBL_BOARD 테이블은 bno(primary key)라는 칼럼을 기준으로 인덱스를 생성하게 된다.

PK_BOARD(인덱스) 구조를 보면 
bno 값이 순서대로 정렬되어 있다. 
실제 테이블인 TBL_BOARD는 순서가 섞여 있다.
인덱스와 실제 테이블을 연결하는 고리는 ROWID라는 존재이다. 
ROWID는 데이터베이스 내의 주소에 해당하는데 모든 데이터는 자신만의 주소를 가지고 있다.

SQL을 통해서 bno 값이 100번인 데이터를 찾고자 할 때에는 SQL은 'where bno = 100'과 같은 조건을 주게 된다.
이를 처리하는 데이터베이스 입자에서는 tbl_board라는 책에서 bno 값이 100인 데이터를 찾아야만 한다.
데이터가 적으면 (FULL SCAN --> 전체를 살펴보는것)이 더 빠르다.
하지만 내용이 많고, 색인이 존재한다면 당연히 색인을 찾고 색인에서 주소를 찾아서 접근하는 방식이 더 빠를 것이다.

실행 계획을 보면 안쪽을 먼저 보면 PK_BOARD는 인덱스이므로 먼저 인덱스를 이용해서 100번 데이터가 어디에 있는지 ROWID를 찾아내고, 바깥쪽을 보면 
'BY INDEX ROWID'라고 되어 있는 말 그대로 ROWID를 통해서 테이블에 접근하게 된다.

인덱스를 이용하는 정렬(인덱스 -> 식별키가 생성되면 정렬이 자동으로 되어있음)

-인덱스에서 가장 중요한 개념 중 하나는 '정렬이 되어 있다는 점'이다.
정렬이 이미 되어있는 상태이므로 데이터를 찾아내서 이들을 SORT하는 과정을 생략할 수 있다.

'bno의 역순으로 정렬한 결과'를 원한다면 이미 정렬된 인덱스를 이용해서 뒤에서부터 찾아 올라가는 방식을 이용할 수 있다.
이때 '뒤에서부터 찾아 올라간다'는 개념이 'DECENDING'이다.
실행 계획을 보면 PK_BOARD라는 인덱스를 이용하는데 DESENDING을 하고 있는 것을 볼 수 있다.

인덱스를 역순으로 찾기 때무에 가장 먼저 찾은 bno 값은 가장 큰 값을 가진 데이터가 된다.
이후에는 테이블에 접근해서 데이터를 가져오게 되는데, 이런 과정이 반복되면 정렬을 하지 않아도 동일하게 정렬된 결과를 볼 수 있다.

만일 사용자가 'bno의 순서로 정렬해 달라'고 요구하는 상황이라면 PK_BOARD 인덱스가 앞에서부터 찾아서 내려가는 주고를 이용하는 것이 효율적이다.

실행 계획상으로 PK_BOARD 인덱스를 먼저 접근하고, TBL_BOARD를 이용하는 것을 볼 수 있다.
SORT가 없기 때문에 0초에 가까운 성능을 보여준다.
실무에서도 데이터의양이 많고 정렬이 필요한 상황이라면 우선적으로 생각하는 것이 '인덱스'를 작성하는 것이다.
데이터의 양이 수천, 수만개 정도의 정렬은 그다지 부하가 걸리지 않지만 그 이상의 데이터를 처리해야 하는 상황이라면 정렬을 안할 수 있는 방법(order by)에 대해서 고민해야한다.

인덱스와 오라클 힌트(hint)

웹페이지의 목록은 주로 시간의 역순으로 정렬된 결과를 보여준다.
최신 데이터가 가장 중요하기 때문에 시간의 역순으로 정렬해서 최신 게시물들을 보여주게 된다. 이 경우 개발자의 입장에서는 정렬을 안 하는 방식으로 select문을 실행하고 싶어 한다.

오라클은 select문을 전달할 때 '힌트(hint)'라는 것을 사용할 수 있다. 
힌트는 말 그대로 데이터베이스에 '지금 내가 전달한 select문을 이렇게 실행해 주면 좋겠다'라는 힌트이다.
힌트는 특이하게도 select문을 어떻게 처리하는지에 대한 얘기일 뿐 힌트 구문에서 에러가 나도 전혀 SQL 실행에 지장을 주지 않는다.
따라서 힌트를 이용한 select 문을 작성한 후에는 실행 계획을 통해서 개발자가 원하는 대로 SQL이 실행되는지를 확인하는 습관을 가져야 한다.

게시물 목록은 반드시 시간의 역순으로 나와야만 하기 때문에 SQL에서는 'order by bno desc'와 같은 구문을 추가할 수 있다.
문제는 'order by bno desc'와 같은 조건은 데이터베이스 상황에 따라서 테이블의 모든 데이터를 정렬하는 방식으로 동작할 수 있다는 점이다.

반면에 힌트는 개발자가 데이터베이스에 어떤 방식으로 실행해 줘야 하는지를 명시하기 때문에 조금 강제성이 부여되는 방식이다.

예제)  order by 형식과 힌트 방식 SQL문

select * from tbl_board order by bno desc; -- 힌트 적용안함

        -- 인덱스 방식으로 역순 처리
select /*+INDEX_DESC (tbl_board pk board) */* -- 힌트 적용
    from tbl_board;

두 select문은 동일한 결과를 생성하는 SQL문이다.

두 번째 select문은 order by 조건이 없어도 동일한 결과가 나온 것에 주목해야 한다.
select문에서 힌트를 부여했는데 힌트의 내용이 'tbl_board 테이블에 pk_board 인덱스를 역순으로 이용해 줄 것'이므로 실행 계획에서 이를 활용하고 있는 것을 확인할 수 있다.

오라클 데이터베이스에서 사용할 수 있는 힌트는 여러 종류가 있다. 

힌트 사용 문법
- select문을 작성할 때 힌트는 잘못 작성되어도 실행할 때는 무시되기만 하고 별도의 에러는 발생하지 않는다.
우선 힌트를 사용할 때에는 다음과 같은 문법을 사용한다.
SELECT 
/*+ Hint Name(param...) */ column name, ...
FROM
    table name
....

힌트 구문은 '/*+'로 시작하고 '/*'로 마무리 된다. 힌트 자체는 SQL로 처리되지 않기 때문에 위의 힌트문 처럼 칼럼명이 나오더라도 별도의 ','로 처리되지 않는다.

FULL 힌트
- 힌트 중에는 해당 select문을 실행할 때 테이블 전체를 스캔할 것으로 명시하는 FULL 힌트가 있다.
FULL 힌트는 테이블의 모든 데이터를 스캔하기 때문에 데이터가 많을 땐ㄴ 상당히 느리게 실행된다.
예를 들어, tbl_board 테이블을 FULL 스캔하도록 하고, 이 상태에서 정렬을 하려면 다음과 같이 작성할 수 있다.
select /*+ FULL(tbl board) */ * from tbl_board order by bno desc;

실행 계획을 보면 TBL_BOARD를 FULL로 접근하고, 다시 SORT가 적용된 것을 볼 수 있다.
실행 시간 역시 오래 걸리는 것을 볼 수 있다. (인덱스를 사용했을 때에 비해서 느리다는 것이다. 데이터 양에 따라 다르게 나온다.)

INDEX_ASC, INDEX_DESC 힌트
- 흔히 목록 페이지에서 가장 맣이 사용하는 힌트는 인덱스와 관련되 'INDEX_ASC, INDEX_DESC'힌트이다.
ASC/ DESC에서 알 수 있듯이 인덱스를 순서대로 이용할 것인지 역순으로 이용할 것이지를 지정하는 것이다.
INDEX_ASC/ DESC 힌트는 주로 'order by'를 위해서 사용한다고 생각하면 된다.
인덱스 자체가 정렬을 해둔 상태이므로 이를 통해서 SORT 과정을 생략하기 위한 용도이다.

INDEX_ASC/DESC 힌트는 테이블 이름과 인덱스 이름을 같이 파라미터로 사용한다.
select /*+ INDEX_ASC(tbl_board pk_board) */ * from tbl_board where bno > 0;

INDEX_ASC/DESC를 이용하는 경우에는 동일한 조건의 order by 구문을 작성하지 않아도 된다.
예를 들어, 위의 SQL에서 아무런 order by 조건이 없어도 bno의 순번을 통해서 접급하기 때문에 'order by bno asc'구문은 필요로 하지 않는다.

ROWNUM과 인라인 뷰
- 페이징 처리를 위해서 역순으로 게시물의 목록을 조회하는 작업이 성공했다면, 이제는 전체가 아닌 필요한 만큼의 데이터를 가져오는 방식으로 진행 하겠다.
오라클 데이터베이스는 페이지 처리를 위해서 ROWNUM이라는 특별한 키워드를 사용해서 데이터에 순번을 붙여서 사용한다.

ROWNUM은 쉽게 생각해서 SQL이 실행된 결과에 넘버링을 해준다고 생각하면 된다.
모든 SELECT 문에는 ROWNUM이라는 변수를 이용해서 해당 데이터가 몇 번째로 나오는지 알아낼 수 있다.
ROWNUM은 실제 데이터가 아니라 테이블에서 데이터를 추출한 후에 처리되는 변수이므로 상황에 따라서 그 값이 매번 달라질 수 있다.

우선 아무 조건을 적용하지 않고 tbl_board 테이블에 접근하고 각 데이터에 ROWNUM을 적용하면 다음과 같이 작성한다.
select rownum rn, bno, title, from tbl_board;

SQL에 아무런 조건이 없기 때문에 데이터는 테이블에 섞여 있는 상태 그대로 나오게 된다.
(테이블을 FULL 스캔한 것과 동일하다.)

ROWNUM은 테이블에 존재하지 않고(가상 NUM), 테이블에서 가져온 데이터를 이용해서 번호를 매기는 방식으로 위의 결과는 테이블에서 가장 먼저 가져올 수 있는 데이터들을 꺼내서 번호를
붙여주고 있다.
이때 번호는 현재 데이터베이스의 상황에 따라서 저장된 데이터를 로딩하는 것이므로 실습 환경에 따라 다른 값이 나온다.

결과에서 bno가 218번 데이터는 3번째로 꺼내진 데이터라고 해석할 수 있다.
만일 테이블에서 데이터를 가져온 후에 정렬을 하게 된다면 bno가 218번의 ROWNUM 값은 동일하게 3이 된다.
select /*+ FULL(tbl_board) */
 rownum rn, bno, title
from tbl_board where bno > 0
order by bno;

위의 SQL은 FULL 힌트를 이용해서 전체 데이터를 조회하고 다시 정렬한 방식이다.
결과를 보면 218번 데이터는 3번째로 접근되었지만 정렬 과정에서 뒤쪽으로 밀리는 것을 볼 수 있다.

이를 통해서 알 수 있는 사실은 ROWNUM이라는 것은 
1) 데이터를 가져올 때 적용하는 것이고
2) 이 이후에 정렬되는 과정세너는 ROWNUM이 변경되지 않는다는 것이다.
다른 말로는 정렬은 나중에 처리된다는 의미이기도 하다.

인덱스를 이용한 접근 시 ROWNUM
- ROWNUM의 의미가 테이블에서 데이터를 가져오면서 붙는 번호라는 사실을 기억해 보면 결국 문제는 테이블에 어떤 순서로 접근하는가에 따라서 ROWNUM 값을 바뀔 수 있다라는 뜻이 된다.
다시 말해, 위의 경우는 우선 FULL로 접근해서 218번 데이터를 찾았고 이후에는 정렬을 하는데 이미 데이터는 다 가져온 상태이므로 ROWNUM에는 아무런 영향을 주지 않느다.

만일 PK_BOARD 인덱스를 통해서 접근한다면 다음 과정으로 접근한다.
1) pk_board 인덱스를 통해서 테이블에 접근
2) 접근한 데이터에 ROWNUM 부여

1)의 과정에서 이미 정렬이 되어있기 때문에 218번의 접근 순서는 3번째가 아니라 한 참 뒤일 것이다. 이 경우 ROWNUM은 전혀 다른 값을 가지게 된다.
예제) 
select /*+ INDEX_ASC(tbl_board pk_board) */
 rownum rn, bno, title, content
from tbl_board;

위의 SQL은 인덱스를 찾는 순서가 다르다.
힌트를 이용해서 tbl_board 테이블을 pk_board의 순번으로 접근하게 되면 ROWNUM의 값이 달라진 것이 보인다.(실행 계획 참고)

만일 게시물의 역순으로 테이블을 접근하게 된다면 218번의 ROWNUM 값은 접근하는 순서가 뒤쪽이기 때문에 엄청나게 큰 값이 나오게 되다.
ROWNUM은 데이터에 접근하는 순서이기 때문에 가장 먼저 접근하는 데이터가 1번이 되는데, 이를 이용하면 테이블을 bno의 역순으로 접근해서 
bno 값이 가장 큰 데이터가 ROWNUM 값이 1이 되도록 작성할 수 있다.

예제) 
select /*+ INDEX_DESC(tbl_board pk_board) */
 rownum rn, bno, title, content
from tbl_board
where bno > 0;

위의 SQL은 pk_board 인덱스 역으로 타면서 테이블에 접근했기 때문에 bno 값이 가장 높은 데이터를 가장 먼저 가져오게 된다.
이 방식을 이용하면 각 게시물을 정렬하면서 순번을 매겨줄 수 있는데, 1페이지의 경우는 위의 sql문에서 rn이라는 칼럼의 값이 1부터 10에 해당한다고 볼 수 있다.
(10개씩 페이징을 한다는 전제). 

페이지 번호 1, 2의 데이터
한 페이지당 10개의 데이터를 출력하나고 가정하면 ROWNUM 조건은 WHERE 구문에 추가해서 다음과 같이 작성할 수 있다.

예제)
select /*+ INDEX_DESC(tbl_board pk_board) */
 rownum rn, bno, title, content
from
 tbl_board
where rownum <= 10;

where 구문에는 rownum 관련 조건을 줄 수 있다.
SQL의 실행 결과를 보면 가장 높은 번호의 게시물 10개만이 출력되는 것을 볼 수 있는데, 이때 실행 계획을 통해서 PK_BOARD 인덱스를 역순으로 접근하는 것을 확인할 수 있다.
WHERE 조건에서 특이하게 ROWNUM 조건은 테이블을 접근할 때 필터링 조건으로 적용된 것을 볼 수 있다.

1페이지 데이터를 구현했다면 흔히 동일한 방식으로 데이터를 구할 수 있을 것이라고 생각한다.
하지만 절대로 원하는 결과를 구할 수 없는데 그 원인을 알아야만 한다.

예제)
-- 아무런 결과가 나오지 않는다. 
select /*+ INDEX_DESC(tbl_board pk_board) */
 rownum rn, bno, title, content
from
 tbl_board
where rownum > 10 and rownum <= 20;

SQL을 보면 rownum이 10보다 크고 20보다 작거나 같은 데이터들을 가져올 것이라고 기대하지만 실제로는 아무런 결과가 나오지 않는다.
실행 계획은 안쪽에서 바깥쪽으로, 위에서부터 아래로 보게 되므로 위의 실행 계획은 우선 rownum > 10, 데이터들을 찾게 된다.
하지만 문제는 tbl_board에 처음으로 나오는 rownum의 값이 1이라는 것이다.
tbl_board에서 데이터를 찾고 rownum 값이 1이 된 데이터는 where 조건에 의해서 무효화가 된다.
이후에 다시 다른 데이터를 가져오면 새로운 데이터가 첫 번째 데이터가 되므로 다시 rownum은 1이 된다.
이 과정이 반복되면 rownum 값은 항상 1로 만들어지고 없어지는 과정이 반복되므로 테이블의 모든 데이터를 찾아내지만 결과는 아무것도 나오지 않게 된다.
이러한 이유로 sqL을 작성할 때 rownum 조건은 반드시 1이 포함되어야 한다.
※이때 인라인 뷰로 (1에서 10까지 데이터를 조회된 데이터 테이블) 사용해야만 한다.

예제)
-- rownum은 반드시 1이 함되도록 해야 한다.
select /*+ INDEX_DESC(tbl_board pk_board) */
 rownum rn, bno, title, content
from
 tbl_board
where rownum <= 20;

결과는 1~20개 데이터를 가져온다. 달라진 점은 rownum 조건이 1을 포함하도록 변경한 것뿐.

인라인 뷰(In-line View) 처리
- 10개씩 목록을 출력하는 경우 2페이지의 데이터를 20갸를 가져오는 데는 성공했지만, 1페이지의 내용이 같이 출력되는 문제가 있으므로 마지막으로
이 문제를 수정해야 한다.
이 문제를 해결하기 위해서는 인라인뷰라는 것을 이용하는데 
인라인 뷰란, 'SELECT문 안쪽 FROM에 다시 SELECT문'으로 이해할 수 있다.
인라인뷰는 논리적으로는 어떤 결과를 구하는 SELECT문이 있고, 그 결과를 다시 대상으로 삼아서 SELECT를 하는 것이다.

데이터베이스에서는 테이블이나 인덱스와 같이 뷰(view)라는 개념이 존재한다.
'뷰(View)'는 일종의 가상 테이블이다. 복잡한 select 처리를 하나의 뷰로 생성하고, 사용자들은 뷰를 통해서 복잡하게 만들어진 결과를 마치 하나의 테이블처럼 쉽게 조회한다는 개념이다.

인라인뷰는 이런한 뷰의 작성을 별도로 작성하지 않고 말 그대로 from 구문 안에 바로 작성하는 형태이다.
외부에서 select문은 인라인뷰로 작성된 결과를 마치 하나의 테이블처럼 사용한다.
예를 들어, 20개의 데이터를 가져오는 SQL을 하나의 테이블처럼 간주하고 바깥쪽에서 추가적인 처리를 하는 것이다.

select /*+ INDEX_DESC(tbl_board pk_board) */
 rownum rn, bno, title, content
from
 tbl_board
where rownum <= 10;
만일 위의 결과를 하나의 테이블로 보면 해당 테이블은 rn, bno, title, content라는 칼럼을 가지는 테이블이 된다.
이 경우 이 테이블에서 원하는 것은 rn 칼럼 값이 10보다 큰 데이터만 가져오면 된다.

인라인 뷰를 적용한 2페이지 데이터의 처리는 아래와 같다

예제)
select 
 bno,title,content
from
 ( select /*+ INDEX_DESC(tbl_board pk_board) */
	rownum rn, bno, title, content
   from 
	tbl_board
   where rownum <= 20
 )
where rn > 10;

이 과정을 정리하면 
1) 필요한 순서로 정렬된 데이터에 ROWNUM을 붙인다.
2) 처음부터 해당 페이지의 데이터를 'ROWNUM <= 30'과 같은 조건을 이용해서 구한다.
3) 구해놓은 데이터를 하나의 테이블처럼 간주하고 인라인 뷰로 처리한다.
4) 인라인뷰에서 필요한 데이터만을 남긴다.

MyBatis와 스프링에서 페이징 처리
- MyBatis는 SQL을 그대로 사용할 수 있기 때문에 인라인뷰를 이용하는 SQL을 작성하고 필요한 파라미터를 지정하는 방식으로 페이징 처리를 하게 된다.
주의할점
페이징 처리를 위해서 필요한 파라미터는
1) 페이지 번호(pageNum)
2) 한 페이지당 몇 개의 데이터(amount)를 보여줄 것인지 예) 1페이지당 10개씩 리스트
결정되어야만 한다.

페이지 번호와 몇 개의 데이터가 필요한지를 별도의 파라미터로 전달하는 방식도 나쁘지는 않지만, 아예 이 데이터들을 하나의 객체로 묶어서 전달하는 방식이
나중에 생각하면 좀더 expansion이 좋다.

예제) org.zerock.domain 패키지에 Criteria 클래스를 작성한다. criteria는 '검색의 기준'을 의미한다.

package org.zerock.domain;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
// Criteria는 '검색의 기준'을 의미
public class Criteria {

	private int pageNum;
	private int amount;
	
	public Criteria() {
		this(1,10);
	}
	
	
	public Criteria(int pageNum, int amount) {
		this.pageNum = pageNum;
		this.amount = amount;
	}
}

Criteria 클래스의 용도는 pageNum과 amount 값을 같이 전달하는 용도지만 생성자를 통해서
기본값을 1페이지, 10개로 지정해서 처리한다.즉 1페이지당 10씩 데이터를 조회해서 가져온다는 말
Lombok을 이용해서 getter/setter을 생성해 준다.

MyBatis 처리와 테스트
-BoardMapper는 인터페이스와 어노테이션을 이용하기 때문에 페이징 처리와 같이 경우에 따라 SQL 구문 처리가 필요한 상황에서는 복잡하게 작성된다.
(SQL문이 길어지고 복잡해지면 개인적으로는 XML로 처리하는 것이 더 알아보기 쉽고 관리하기도 쉽다)

예제) org.zerock.mapper 패키지의 BoardMapper에는 위에서 작성한 Criteria 타입을 파라미터로 사용하는 getListWithPaging() 메서드를 작성

// Criteria 추가 p.294
public List<BoardVO> getListWithPaging(Criteria cri);

예제) 기존에 만들어둔 BoardMapper.xml에 getListWithPaging에 해당하는 태그를 추가

<select id="getListWithPaging" resultType="org.zerock.domain.BoardVO">
<![CDATA[
SELECT
	bno, title, content, writer, regdate, updatedate
FROM
	(
	select /*+INDEX_DESC(tbl_board pk_board) */
	 	rownum rn, bno, title, content, writer, regdate, updatedate
	from 
		tbl_board
	where rownum <= 20
	) 
	where rn > 10
]]>

작성된 BoardMapper.xml에서는 XML의 CDATA 처리가 들어간다.
CDATA 섹션은 XML에서 사용할 수 없는 부등호를 사용하기 위함인데, XML을 사용할 경우에는 '<, >'는 태그로 인식하는데,
이로 인해 생기는 문제를 막기 위함이다.
(&lt; 나 &gt;와 같은 특수문자를 사용할 수도 있긴 하다.)

페이징 테스트와 수정
- MyBatis의 '#{}'를 적용하기 전에 XML 설정이 제대로 동작하는지 테스트를 먼저 진행하는 것이 좋다.
테스트 환경은 이미 준비되어 있으므로 간단히 테스트 코드만을 추가할 수 있다.

예제) BoardMapperTests.java에 메서드를 추가

	@Test
	public void testPaging() {
		Criteria cri = new Criteria();
		
		List<BoardVO> list = mapper.getListWithPaging(cri);
		
		list.forEach(board -> log.info(board));
	}
Criteria 클래스에 생성된 객체는 pageNum은 1, amount는 10이라는 기본값을 가지므로 별도의 파라미터 없이 생성한다.
현재는 파라미터 값이 반영되지 않으므로 2페이지의 내용이 정상적으로 나오는지 확인
(sql문은 20개의 데이터중 11부터 20까지 데이터를 보여주는 select문이기 때문에 2페이지에 내용부터 나온다.)

SQL에 문제가 없다는 것을 확인했다면 이제 Criteria 객체 내부의 값을 이용해서 SQL이 동작하도록 수정
20과 10이라는 값은 결국 pageNum과 amount를 이용해서 조절되는 값이다.

SELECT
	bno, title, content, writer, regdate, updatedate
FROM
	(
	select /*+INDEX_DESC(tbl_board pk_board) */
	 	rownum rn, bno, title, content, writer, regdate, updatedate
	from 
		tbl_board
	where rownum <= 20 --> pageNum * amount (1~20개의 데이터를 조회하는 조건절)
	) 
	where rn > 10 --> (pageNum - 1) * amount (where rn > 0 --> rownum가 0보다 큰 데이터를 조회하는 조건절)


예제) BoardMapper.xml을 수정 --> 페이지 번호(pageNum)과 데이터 수(amount)를 변경할 수 있게 수정

<select id="getListWithPaging" resultType="org.zerock.domain.BoardVO">
<![CDATA[
SELECT
	bno, title, content, writer, regdate, updatedate
FROM
	(
	select /*+INDEX_DESC(tbl_board pk_board) */
	 	rownum rn, bno, title, content, writer, regdate, updatedate
	from 
		tbl_board
	where rownum <= #{pageNum} * #{amount}
	) 
	where rn > (#{pageNum} -1) * #{amount}
]]>
</select>

SQL의 동작에 문제가 없는지 확인해야 한다. 

예제) BoardMapperTests.java에 testPaging() 메서드를 수정
	@Test
	public void testPaging() {
		Criteria cri = new Criteria();
		
		// 10개씩 3page
		cri.setPageNum(3);;
		cri.setAmount(10);
		List<BoardVO> list = mapper.getListWithPaging(cri);
		
		list.forEach(board -> log.info(board.getBno()));
	}
	
확인을 위해서 Criteria 객체를 생성할 때 파라미터를 추가해보거나, setter를 이용해서 내용을 수정한다.
위의 경우는 한 페이지당 10개씩 출력하는 3페이지에 해당하는 데이터를 구한 것이다.
테스트 코드가 동작한 후에는 SQL Developer에서 실행된 결과와 동일한지 체크하고 페이지 번호를 변경해서 정상적으로 번호가 처리되는지 확인한다.

BoardController와 BoardService 수정
- 페이징 처리는 브라우저에서 들어오는 정보들을 기준으로 동작하기 때문에 Board Controller와 BoardService역시 전달되는 파라미터들을 받는 형태로 수정해야 한다.
BoardService는 Criteria를 파라미터로 처리하도록 BoardService 인터페이스와 BoardServiceImpl 클래스를 수정한다.

예제) BoardService 인터페이스 getList()메서드 수정

	public List<BoardVO> getList(Criteria cri);

예제) BoardServiceImpl getList()메서드 수정

	@Override
	public List<BoardVO> getList(Criteria cri) {
	
		log.info("get List with criteria : " + cri);
		return mapper.getListWithPaging(cri);
	}

원칙적으로는 BoardService 쪽에 대한 수정이 이루어 졌으니 이에 대한 테스트를 진행한다.
메서드를 수정하면 이미 테스트 코드 역시 에러가 발생하므로 수정해서 테스트를 진행한다.

예제)BoardServiceTests.java  testGetList()메서드 수정

	@Test
	public void testGetList() {
		
		service.getList(new Criteria(2, 10)).forEach(board -> log.info(board));
	}

Criteria 클래스를 하나 만들어 두면 위와 같이 편하게 하나의 타입만으로 파라미터나 리턴 타입을 사용하 수 있기 때무에 여러모로 편리하다.

BoardController 역시 이전에 테스트를 진행했으므로, pageNum과 amount를 파라미터로 테스트한다.
예제) BoardController testListPaging() 메서드 추가
	@Test
	public void testListPaging() throws Exception {
		
		log.info(mockMvc.perform(
			MockMvcRequestBuilders.get("/board/list")
			.param("pageNum", "2")
			.param("amount", "50"))
			.andReturn().getModelAndView().getModelMap());
	}
	
페이징 화면 처리
URL의 파라미터를 이용해서 정상적으로 원하는 페이지로 이동하는 것을 확인했다면, 화면 밑에 페이지 번호를 표시하고 사용자가 페이지 번호를
클릭할 수 있게 처리한다.
페이지를 보여주는 작업은 다음과 같은 과정을 통해서 진행한다.
1. 브라우저 주소창에서 페이지 번호를 전달해서 결과를 확인하는 단계 -- 직접적으로 페이지 번호를 쿼리문으로 호출하는지 확인
2. JSP에서 페이지 번호를 출력하는 단계			   -- 화면에서 클릭할 수 있는 번호 버튼
3. 각 페이지 번호에 클릭 이벤트 처리				    -- 각 페이지 넘버에 맞게 클릭 이벤트
4. 전체 데이터 개수를 반영해서 페이지 번호 조절		  

페이지 처리는 단순히 링크의 연결이기 때문에 어렵지는 않지만, 다음 그림과 같이 목록 페이지에서 조회 페 이지, 수정 삭제 페이지까지 페이지 번호가 계속해서 유지되어여만 하기 때문에
끝까지 신경써야 하는 부분들이 많다.

페이징 처리할 때 필요한 정보들(중요)
- 화면에 페이지는 크게 다음과 같은 정보들이 필요하다.
1. 현재 페이지 번호(page)
2. 이전과 다음으로 이동 가능한 링크의 표시 여부(prev, next) --> 데이터가 많으면 단위를 몇개에 페이지까지 보여줄지 정한뒤 그보다 많을 경우 next클릭시 넘어가고 다시 전쪽으로 갈떄 prev로간다.
3. 화면에서 보여지는 페이지의 시작 번호와 끝 번호(startPage, endPage)

끝 페이지 번호와 시작 페이지 번호

페이징 처리를 하기 위해서 우선적으로 필용한 정보는 현재 사용자가 보고있는 페이지(page)의 정보이다.
예를 들어, 사용자가 5페이지를 본다면 화면의 페이지 번호는 1부터 시작하지만, 사용자가 19페이지를 본다면 11부터 시작해야 하기 때문이다.
(화면에 10개씩 페이
지 번호를 출력한다고 가정한 상태)
흔히들 페이지를 계산할 때 시작 번호를 먼저 하려고 하지만, 오히려 끝 번호를 먼저 계산해 두는 것이 수월하다.
끝 번호는 다음과 같은 공식으로 구할 수 있다.
(페이지 번호가 10개씩 보인다고 가정한다.)

예제) 페이징의 끝 번호(endPage)계산
this.endPage = (int)(Math.ceil(페이지번호 / 10.0)) * 10;

Math.ceil()은 소수점을 올림으로 처리하기 때문에 다음과 같은 상황이 가능하다.
1. 1페이지의 경우 : Math.ceil(0.1) * 10 = 10
2. 10페이지의 경우 : Math.ceil(1) * 10 = 10
3. 11페이지의 경우 : Math.ceil(1.1) * 10 = 20

끝 번호(endPage)는 아직 개선의 여지가 있다. 만일 전체 데이터 수가 적다면 10페이지로 끝나면 안되는 상황이 생길 수 도 있기 때문이다.
그럼에도 끝 번호(endPage)를 먼저 계산하는 이유는 시작 번호(startPage)는 무조건 끝 번호(endPage)에서 9라는 값을 뺀 값이 된다.

예제) 페이징의 시작 번호(startPage) 계산
this.startPage = this.endPage - 9;

끝 번호(endPage)는 전체 데이터 수(total)에 의해서 영향을 받는다.
예를 들어, 10개씩 보여주는 경우 전체 데이터 수(total)가 80개라고 가정하면 끝 번호(endPage)는 10이 아닌 8이 되어야만 한다.

만일 끝 번호(endPage)와 한 페이지당 출력되는 데이터 수(amount)의 곱이 전체 데이터 수(total)보다 크다면 끝 번호(endPage)는 다시 total을 잉요해서 다시 계산되어야 한다.

예제) total을 통한 endPage의 재계산
realEnd = (int) (Math.ceil((total * 1.0) / amount));

if(realEnd < this.endPage){
	this.endPage = realEnd;
}

먼저 전체 데이터 수(total)를 이용해서 진짜 끝 페이지(realEnd)가 몇 번까지 되는지를 계산한다.
만일 진짜 끝 페이지(realEnd)가 구해둔 끝 번호(endPage)보다 작다면 끝 번호는 작은 값이 되어야만 한다.

이전(prev)과 다음(next)

-이전(prev)과 다음은 아주 간단히 구할 수 있다. 이전(prev)의 경우는 시작 번호(startPage)가 1보다 큰 경우라면 존재하게 된다.
예제) 이전(prev) 계산
this.prev = this.startPage > 1;

다음(next)으로 가는 링크의 경우 위의 realEnd가 끝 번호(endPage)보다 큰 경우에만 존재하게 된다.
예제) 다음(next) 계산
this.next = this.endPage < realEnd;

페이징 처리를 위한 클래스 설계
- 화면에 페이징 처리를 위해서 위와 같이 여러 정보가 필요하다면 클래스를 구성해서 처리하는 방식도 꽤 편한 방식이 될 수 있다.
클래스를 구성하면 Controller 계층에서 JSP 화면에 전달할 때에도 객체를 생성해서 Model에 담아 보내는 과정이 단순해지는 장점도 있다.

예제) org.zerock.domain 패키지에 PageDTO 클래스를 설계한다.

package org.zerock.domain;

import lombok.Getter;
import lombok.ToString;
import lombok.extern.log4j.Log4j;

@Getter
@ToString
@Log4j
public class PageDTO {
	
	private int startPage; // 1페이지
	private int endPage; // 끝 페이지
	private boolean prev, next;
	
	private int total;
	private Criteria cri;
	
	public PageDTO(Criteria cri, int total) {
		
		this.cri = cri;
		this.total = total;
		
		this.endPage = (int)(Math.ceil(cri.getPageNum()/ 10.0)) * 10;
		this.startPage = this.endPage - 9;
		
		int realEnd = (int)(Math.ceil((total * 1.0) / cri.getAmount()));
		
		if (realEnd < this.endPage) {
			this.endPage = realEnd;
		}
		
		this.prev = this.startPage > 1;
		
		this.next = this.endPage < realEnd;
	}
}


PageDTO는 생성자를 정의하고 Criteria와 전체 데이터 수(total)를 파라미터로 지정한다.
Criteria 안에는 페이지에서 보여주는 데이터 수(amount)와 현재 페이지 번호(pageNum)를 가지고 있기 때문에 이를 이용해서 모든 내용을 계산할 수 있다.

BoardController에서는 PageDTO를 사용할 수 있도록 Model에 담아서 화면에 전달해 줄 필요가 있다.

예제) BoardController 클래스의 list()메서드 수정
	@GetMapping("/list")
	public void list(Criteria cri,Model model) {
		
		log.info("list : " + cri);
		
		model.addAttribute("list", service.getList(cri));
		//p.307 PageDTO를 사용할 수 있도록 Model에 담아서 화면에 전달할 코드 작성
		model.addAttribute("pageMaker", new PageDTO(cri, 123));
		
	}
 
list()는 'pageMaker'라는 이름으로 PageDTO 클래스에서 객체를 만들어서 Model에 담아준다.
PageDTO를 구성하기 위해서는 전체 데이터 수가 필요한데, 아직 그 처리가 이루어지지 않았으므로 임의의 값으로 123을 지정했다.

JSP에서 페이지 번호 출력
-JSP에서 페이지 번호를 출력하는 부분은 JSTL을 이용해서 처리할 수 있다.
SB Admin2는 부트 스트랩 기반으로 구성되어 있기 때문에 http://v4-alpha.getbootstrap.com/components/pagination/와 같이 부트 스트랩
관련 링크들에 필요한 예제들이 존재한다.

예제는 SB Admin2의 pages 폴더에 있는 tables.html 페이지의 페이지 처리를 이용해서 구성한다. 
기존의 <table> 태그가 끝나는 직후에 페이지 처리를 추가한다.

예제) views/board/list.jsp 수정

      <div class="pull-right">
       <ul class="pagination">
		                    		
	 <c:if test="${pageMaker.prev }">
	   <li class="paginate_button previous"><a href="#">Previous</a>
  	   </li>
  	 </c:if>
		                    		
	 <c:forEach var="num" begin="${pageMaker.startPage }"
	    end="${pageMaker.endPage }">	                    			
  	    <li class="paginate_button ${pageMaker.cri.pageNum == num ? "active":"" }">      			
	    <a href="#">${num }</a>	
	    </li>	                    			
	 </c:forEach>
		                    		
	 <c:if test="${pageMaker.next }">	                    		
	    <li class="paginate_button next"><a href="#">Next</a>	                    				
	    </li>
	 </c:if>
       </ul>		                    	
    </div>
		          
Model 창의 아래쪽에 별도의 <div class='row'>를 구성하고 페이지 번호들을 출력한다.
pageMaker라는 이름으로 전달된 pageDTO를 이용해서 화면에 페이지 번호들을 출력한다.

예를 들어, 현재 total은 123이라는 숫자로 지정되어 있으므로 5페이지를 조회하면 next값은 true가 되어야 한다.
반면에 amount 값이 20인 경우에는 7페이지까지만 출력되어야 한다.

페이지 번호 이벤트 처리
- 화면에서 페이지 번호가 보이기는 하지만 아직 페이지 번호를 클릭했을 때 이벤트 처리가 남아있다.
일반적으로 <a> 태그의 href 속성을 이용하는 방법을 사용할 수도 있지만, 직접 링크를 처리하는 방식의 경우 검색 조건이 붙고 난 후에 처리가 복잡하게 되므로 
JavaScript를 통해서 처리하는 방식을 이용한다.

우선 페이지와 관련된 <a> 태그의 href 속성값으로 페이지 번호를 가지도록 수정한다.
(번호의 출력 부분은 <c:out>을 이용해서 출력하는 것이 좋지만 예제에서는 가독성의 문제로 일반EL을 이용했다.)

예제) list.jsp 수정    
<div class="pull-right">
       <ul class="pagination">
		                    		
	 <c:if test="${pageMaker.prev }">
	   <li class="paginate_button previous"><a href="${pageMaker.startPage -1 }">Previous</a>
  	   </li>
  	 </c:if>
		                    		
	 <c:forEach var="num" begin="${pageMaker.startPage }"
	    end="${pageMaker.endPage }">	                    			
  	    <li class="paginate_button ${pageMaker.cri.pageNum == num ? "active":"" }">      			
	    <a href="${num }">${num }</a>	
	    </li>	                    			
	 </c:forEach>
		                    		
	 <c:if test="${pageMaker.next }">	                    		
	    <li class="paginate_button next">
		<a  href="${pageMaker.endPage +1 }" >Next</a>	                    				
	    </li>
	 </c:if>
       </ul>		                    	
    </div>

이제 화면에서는 <a> 태그는 href 속성값으로 단순히 번호만을 가지게 변경된다.
이 상태에서 페이지 번호를 클릭하게 되면 해당하는 URL이 존재하지 않기 때문에 404 에러 페이지가 나오게 된다.
<a> 태그가 원래의 동작을 못하도록 JavaScript 처리를 한다.
실제 페이지를 클릭하면 동작을 하는 부분은 별도의 <form> 태그를 이용해서 처리하도록 한다.
<c:out>을 사용하는 것이 더 좋은 방법이지만 간단히 사용하기 위해서 EL로 처리하였다.

예제) list.jsp form 추가

<form id="actionForm" action="/board/list" method="get">
  	<input type="hidden" name="pageNum" value="${pageMaker.cri.pageNum }">
  	<input type="hidden" name="amount" value="${pageMaker.cri.amount }">
 </form>

예제)list.jsp 기존의 동작하던 JavaScript 부분은 아래와 같이 기존의 코드에 페이지 번호를 클릭하면 처리하는 부분을 추가

var actionForm = $("#actionForm");
		
		$(".paginate_button a").on("click", function (e) {
			
			e.preventDefault();
			
			console.log("click");
			
			actionForm.find("input[name='pageNum']").val($(this).attr("href"));
			actionForm.submit();
			//jQuery에 있는
			//.find()는 어떤 요소의 하위 요소 중 특정 요소를 찾을 때 사용합니다.
			//.val()은 양식(form)의 값을 가져오거나 값을 설정하는 메소드입니다.
			//.attr()은 요소(element)의 속성(attribute)의 값을 가져오거나 속성을 추가한다.
		});

- list.jsp에서는 <form> 태그를 추가해서 URL의 이동을 처리하도록 변경했다.
JavaScript에서는 <a> 태그를 클릭해도 페이지 이동이 없도록 preventDefault() 처리를 하고, <form> 태그 내 pageNum 값은 href 속성값으로 변경한다.
이 처리를 하고나면 화면에서 페이지 번호를 클릭했을 때 <form> 태그 내의 페이지 번호가 바뀌는 것을 브라우저에서 개발자 도구를 통해 확인할 수 있다.

마지막 처리는 actionForm 자체를 submit() 시켜야 한다.

브라우저에서 페이지 번호를 클릭하면 화면에서 제대로 이동이 되는지를 확인한다.

조회 페이지로 이동
- 목록 화면에서 페이지 번호를 클릭하면 정상적으로 원하는 페이지로 이동하는 것을 볼 수 있지만, 몇 가지 문제가 있다.
우선 사용자가 3페이지에 있는 게시글을 클릭한 후 다시 목록으로 이동해 보면 다음과 같이 무조건 1페이지로 이동하는 증상이 일어난다.
페이징 처리를 하고 나면 특정 게시물의 조회페이지로 이동한 후 다시 목록으로 돌아가는데 문제가 생긴다.
조회 페이지에서 'List'를 선택하면 다시 1페이지의 상태로 돌아가는 문제가 발생하는 것을 볼 수 있다.
이를 해결하기 위해서는 조회 페이지로 갈 때 현재 목록 페이지의 pageNum과 amount를 같이 전달해야 한다.
이런 경우 페이지 이동에 사용했던 <form> 태그에 추가로 게시물의 번호를 같이 전송하고, action 값을 조정해서 처리할 수 있다.

원래 게시물의 제목에는 '/board/get?bno=xxx'로 이동할 수 있는 링크가 직접 처리되어 있다.

페이지 번호는 조회 페이지에 전달되지 않기 때문에 조회 페이지에서 목록 페이지로 이동할 때는 아무런 정보가 없이 다시
'board/list'를 호출하게 된다. 간단하게는 각 게시물의 링크에 추가로 '&pageNum=xx'와 같이 처리할 수 있지만 나중에 여러 조건들이 
추가되는 상황에서는 복잡한 링크를 생성해야 한다.

<a> 태그로 복잡한 링크를 생성하는 방식이 나쁘다고는 말할 수 없다. 
가장 대표적인 예가 검색엔진이다.
검색엔진에서는 출력된 정보와 링크를 저장해서 사용하기 때문에 <a> 태그 내의 링크가 완전한 URL인 경우가 노출에 유리하다.
만일 웹페이지가 검색엔진에 의해서 노출이 필요한 경우라면 직접 모든 문자열을 구성해 주는 방식이 더 좋다.

직접 링크로 연결된 경로를 페이지 이동과 마찬가지로 <form> 태그를 이용해서 처리할 수 있으므로 <a> 태그에는 이동하려는 게시물의 번호만을 가지게 수정한다.
(이벤트 처리를 수월하게 하기 위해서 <a> 태그에 class 속성을 부여했다.)

예제) list.jsp
  <td>
  <a class="move" href="<c:out value='${board.bno }'/>"
  <c:out value="${board.title }"/> </a>    	
 </td>

화면에서는 조회 페이지로 가는 링크 대신에 단순히 번호만이 출력된다.
(마우스를 올려보면 아래쪽에서 확인 가능하다.)

실제 클릭은 JavaScript를 통해서 게시물의 제목을 클릭했을 때 이동하도록 이벤트 처리를 새로 작성한다.

예제) list.jsp JavaScript 이벤트 추가

//list.jsp 게시물 조회를 위한 이벤트 처리 추가
		$(".move").on("click", function (e) {
			
			e.preventDefault();
			actionForm.append("<input type='hidden' name='bno' value='"+$(this).attr("href")+"'>");
			actionForm.attr("action", "/board/get");
			actionForm.submit();
		});

게시물의 제목을 클릭하면 <form> 태그에 추가로 bno 값을 전송하기 위해서 <input>태그를 만들어 추가하고,
<form> 태그의 action은 '/board/get'으로 변경한다.
위의 처리가 정상적으로 되었다면 게시물의 제목을 클릭했을 때 pageNum과 amount 파라미터가 추가로 전달되는 것을 볼 수 있다.

조회 페이지에서 다시 목록 페이지로 이동 - 페이지 번호 유지
- 조회 페이지에 다시 목록 페이지로 이동하기 위한 파라미터들이 같이 전송되었다면 조회 페이지에서 목록으로 이동하기 위한 이벤트를 처리해야 한다.
BoardController의 get() 메서드는 원래는 게시물의 번호만 받도록 처리되어 있지만, 추가적인 파라미터가 붙으면서 Criteria를 파라미터로 추가해서 받고 전달한다.

예제) BoardController 클래스의 일부
	@GetMapping({"/get", "/modify"})
	public void get(@RequestParam("bno") Long bno, @ModelAttribute("cri") Criteria cri , Model model) {
		
		log.info("/get or modify");
		model.addAttribute("board", service.get(bno));
	}

@ModelAttribute는 자동으로 Model에 데이터를 지정한 이름을 담아준다.(지정한 이름은 'cri')
@ModelAttribute를 사용하지 않아도 Controller에서 화면으로 파라미터가 된 객체는 전달이 되지만, 좀 더 명시적으로 이름을 지정하기 위해서 사용한다.

기존 get.jsp에서는 버튼을 클릭하면 <form> 태그를 이용하는 방식이었으므로 필요한 데이터를 추가해서 이동하도록 수정한다.

예제) views/board/get.jsp 수정
<form id="operForm" action="/board/modify" method="get">
	<input type="hidden" id="bno" name="bno" value="<c:out value='${board.bno}'/>">
	<input type="hidden" name="pageNum" value="<c:out value='${cri.pageNum}'/>">
	<input type="hidden" name="amount" value="<c:out value='${cri.amount}'/>">
</form>

get.jsp는 operForm이라는 id를 가진 <form>태그를 이미 이용했기 때문에 cri라는 이름으로 전달된 Criteria 객체를 이용해서 pageNum과 amount값을 태그로 구성하고, 
버튼을 클릭했을 때 정상적으로 목록 페이지로 이동하게 처리한다.

조회 페이지에서 수정/삭제 페이지로 이동
- 조회 페이지에서는 'Modify' 버튼을 통해서 수정/ 삭제 페이지로 이동하게 된다.
수정/삭제 페이지에서는 다시 목록으로 가는 버튼이 존재하므로 동일하게 목록 페이지에 필요한 파라미터들을 처리해야 한다. 
BoardController 에서는 get() 메서드에서 '/get'과 '/modify'를 같이 처리하므로 별도의 추가적인 처리 없이도 Criteria를 Model에 cri라는 이름으로 담아서 전달한다.

조회 페이지에서 <form> 태그는 목록 페이지로의 이동뿐 아니라 수정/ 삭제 페이지 이동에서도 사용되기 때문에 파라미터들은 자동으로 같이 전송된다.

수정과 삭체 처리
- modify.jsp에서는 <form> 태그를 이용해서 데이터를 처리한다. 거의 입력과 비슷한 방식으로 구현되는데, 이제 pageNum과 amount라는 값이 존재하므로
<form> 태그 내에서 같이 전송할 수 있게 수정해야 한다.

예제) views/board/modify.jsp 수정
	  <!-- 추가-->
	 <input type="hidden" name="pageNum" value="<c:out value='${cri.pageNum}'/>">
	 <input type="hidden" name="amount" value="<c:out value='${cri.amount}'/>">

modify.jsp 역시 Criteria를 Model에서 사용하기 때문에 위와 같이 태그를 만들어서 <form> 태그 전송에 포함한다.

수정/ 삭제 처리 후 이동
-POST 방식으로 진행하는 수정과 삭제 처리는 BoardController 에서 각각의 메서드 형태로 구현되어 있으므로 페이지 관련 파라미터들을 처리하기 위해서는 변경해 줄 필요가 있다.

예제) BoardController의 modify() 수정
	@PostMapping("/modify")
	public String modify(BoardVO board,@ModelAttribute("cri")Criteria cri ,RedirectAttributes rttr) {
		
		log.info("modify : " + board);
		
		if (service.modify(board)) {
		 rttr.addFlashAttribute("result", "success");
			
		}
		
		rttr.addAttribute("pageNum", cri.getPageNum());
		rttr.addAttribute("pageNum", cri.getAmount());

		return "redirect:/board/list";
	}
메서드의 파라미터에는 Criteria가 추가된 형태로 변경되고, RedirectAttributes 역시 URL 뒤에 원래의 페이지로 이동하기 위해서 pageNum과 amount 값을 가지고 이동하게 수정한다.

삭제 처리 역시 동일하게 Criteria를 받아들이는 방식으로 수정

예제) BoardController의 remove() 수정
	@PostMapping("/remove")
	public String remove(@RequestParam("bno") Long bno,@ModelAttribute("cri")Criteria cri ,RedirectAttributes rttr) {
		
		log.info("remove : " + bno);
		if (service.remove(bno)) {
			rttr.addFlashAttribute("result", "success");
		}
		
		rttr.addAttribute("pageNum",cri.getPageNum());
		rttr.addAttribute("pageNum",cri.getAmount());
		
		return "redirect:/board/list";
	}

위와 같은 방식으로 이용하면 수정/삭제 후 기존 사용자가 보던 페이지로 이동하는 것을 볼수 있다.

수정과 달리 삭제는 처리 후 1페이지로 이동해도 무방하지만, 이왕이면 사용자들에게 자신이 보던 정보를 이어서 볼 수 있게 조치해 주는 방식 역시 어렵지 않다.

수정/삭제 페이지에서 목록 페이지로 이동
- 페이지 이동의 마지막은 수정/삭제를 취소하고 다시 목록 페이지로 이동하는 것이다.
목록 페이지는 오직 pageNum과 amount만을 사용하므로 <form> 태그의 다른 내용들은 삭제하고 필요한 내용만을 다시 추가하는 형태가 편리하다.

예제) modify.jsp의 JavaScript 부분
<script type="text/javascript">

	$(document).ready(function () {
		var formObj = $("form");
		
		$('button').on("click", function (e) {
			
			e.preventDefault();
			
			var operation = $(this).data("oper");
			
			console.log(operation);
			
			if (operation === 'remove') {
				formObj.attr("action", "/board/remove");
			}
			else if (operation === "list") {
				// move to list 
				formObj.attr("action", "/board/list").attr("method", "get");
				.321 수정/삭제 페이지에서 목록 페이지 이동
				var pageNumTag = $("input[name='pageNum']").clone();
				var amountTag = $("input[name='amount']").clone();
				
				
				formObj.empty();
				formObj.append(pageNumTag);
				formObj.append(amountTag);
			}
			formObj.submit();
		});
		
	});

</script>

만일 사용작 'List' 버튼을 클릭한다면 <form> 태그에서 필요한 부분만 잠시 복사(clone)해서 보관해 두고, <form> 태그 내의 모든 내용은 지워버린다.(empty)
이우헤 다시 필요한 태그들만 추가해서 '/board/list'를 호출하는 형태를 이용한다.

MyBatis에서 전체 데이터의 개수 처리
-페이지의 이동이 모든 작업에서 정상적으로 이루어지는 것을 확인했다면 최종적으로는 데이터베이스에 있는 실제 모든 게시물의 수 (total)를 구해서 pageDTO를
구성할 때 전달해 주어야 한다.
전체의 개수를 구하는 SQL은 어렵거나 복잡하지 않기 때문에 어노테이션으로 처리해도 무방하지만 
BoardMapper 인터페이스에 getTotalCount() 메서드를 정의하고 XML을 이용해서 처리한다.

예제) BoardMapper.java getTotalCount() 메서드 정의
// p.322 Mybatis에서 전체 데이터의 개수 처리
public int getTotalCount(Criteria cri);
	
getTotalCount()는 Criteria를 파라미터를 전달받도록 설계하지 않아도 문제가 생기지는 않지만, 게시물의 목록과 저체 데이터 수를 구하는 작업은 일관성 있게
Criteria를 받는 것이 좋다. 

예제) BoardMapper.xml에 쿼리 정의

<!-- p.323 Mybatis에서 전체 데이터의 개수 처리 -->
<select id="getTotalCount" resultType="int">
	select count(*) from tbl_board where bno > 0
</select>

예제) BoardService와 별도의 메서드 작성 getTotalCount() 호출
	// p.323 BoardMapper의 getTotalCount()를 호출
	public int getTotal(Criteria cri);

BoardService의 getTotal()에 굳이 Criteria는 파라미터로 전달될 필요가 없기는 하지만, 목록과 전체 데이터 개수는 항상 같이 동작하는 경우가 많기 때문에 파라미터로 지정한다.
BoardServiceImpl 클래스는 getTotal() 메서드를 구현한다.
예제) BoardService와 BoardServiceImpl에서 별도의 메서드 작성 getTotalCount() 호출
	// p.323 BoardMapper의 getTotalCount()를 호출
	public int getTotal(Criteria cri) {
		
		log.info("get total count");
		return mapper.getTotalCount(cri);
	}

예제) BoardController에서는 BoardService 인터페이스를 통해서 getTotal()을 호출하도록 변경한다.

	@GetMapping("/list")
	public void list(Criteria cri,Model model) {
		
		log.info("list : " + cri);
		
		model.addAttribute("list", service.getList(cri));
		//p.307 PageDTO를 사용할 수 있도록 Model에 담아서 화면에 전달할 코드 작성
		//model.addAttribute("pageMaker", new PageDTO(cri, 123));
		
		// p.324 BoardService 인터페이스를 통해서 getTotal()을 호출하도록 변경
		int total = service.getTotal(cri);
		
		log.info("total: " + total);
		
		model.addAttribute("pageMaker", new PageDTO(cri, total));
	}

이상으로 게시물의 등록, 수정, 조회, 페이징 처리가 완료되었다.
남은 작업은 검색 조건을 이용하는 처리이다.



검색 처리
- 게시물 관리에서 마지막은 다양한 검색 처리이다.
검색 기능은 다시 검색 조건과 키워드로 나누어 생각해 볼 수 있다.
검색 조건은 일반적으로 <select> 태그를 이용해서 작성하거나 <checkbox>를 이용하는 경우가 많다.
과거에는 <checkbox>를 이용하는 경우가 더 많았지만, 최근에는 일반 웹 사이트에서 일반 사용자들의 경우에는 <select>를 관리자용이나 
검색 기능이 강한 경우 <checkbox>를 이용하는 형태가 대부분이다.

이 예제는 가장 흔한<select> 태그를 이용해서 검색 기능과 화면을 처리한다.

검색 기능과 SQL
게시물의 검색 기능은 다음과 같이 분류가 가능하다.

- 제목/ 내용/ 작성자 같이 단일 항목 검색
- 제목 or 내용, 제목 or 작성자, 내용 or 작성자, 제목 or 내용 or 작성자 와 같이 다중 항목 검색

검색 항목은 제목/ 내용/ 작성자와 같은 단일 항목 검색과 제목 or 내용과 같이 복합적인 항목으로 검색하는 방식이 존재한다.
게시물의 검색이 붙으면 가장 신경 쓰이는 부분은 역시 SQL쪽이다.
오라클은 페이징 처리에 인라인뷰를 이용하기 때문에 실제로 검색 조건에 대한 처리는 인라인뷰의 내부에서 이루어져야 한다.
단일 항목의 검색은 검색 조건에 따라서 칼럼이 달라지고, LIKE 처리를 통해서 키워드를 사용하게 된다.

만일 2페이지에 해당하는 데이터를 '제목'으로 검색하고, 키워드는 'Test'라고 한다면 
다음과 같이 작성될 수 있다.

예제) 검색조건 - 제목, 내용, 작성자
select 
* 
from
(
	select /*+INDEX_DESC(tbl_board pk_board) */ -- 힌트
	    rownum rn, bno, title, content, writer, regdate, updatedate
	from
	  tbl_board
	where
	-- 변경부분
	title like '%Test%'
	
	and rownum <= 20
	)
where rn > 10;

단일 항목은 인라인뷰 안쪽에서 필요한 데이터를 가져올 때 검색 조건이 적용되어야 하기 때문에 WHERE문 뒤에 검색 조건이 추가되고, ROWNUM 조건이 뒤따르게 하면 문제가 없다.



다중 항목 검색

제목이나 내용중에 'TEST'라는 문자열이 있는 게시물들을 검색하고 싶다면
다음과 같이 작성하면 된다.

예제)
select 
* 
from
(
	select /*+INDEX_DESC(tbl_board pk_board) */ -- 힌트
	    rownum rn, bno, title, content, writer, regdate, updatedate
	from
	  tbl_board
	where
	-- 변경부분
	title like '%Test%' or content like '%Test%'
	
	and rownum <= 20
	)
where rn > 10;


title like '%Test%' or content like '%Test%' 구문 자체는 이상이 없지만, 실제로 동작시켜 보면 
10개의 데이터가 아니라 많은 양의 데이터가 나오는 것을 볼 수 있다.

이렇게 많은 양의 데이터가 나온 이융는 위 SQL문에서 AND 연산자가 OR 연산자 보다 우선 순위가 높기 때문에 'ROWNUM이 20보다 작거나 같으면서(AND) 내용에 'Test'라는
문자열이 있거나(OR) 제목에 'Test'라는 문자열이 있는 ' 게시물들을 검색하게 된다.
제목에 'TEST'라는 문자열이 있는 경우는 많기 때문에 위의 그림과 같이 많은 양의 데이터를 가져오게 된다.

AND와 OR가 섞여있는 SQL을 잘성할 때에는 우선 순위 연산자인 '()'를 이용해서 OR 조건들을 처리해야 한다.

예제) 검색조건 제목 혹은 내용 , 제목 혹은 작성자, 제목 혹은 내용 혹은 작성자

-- 정상적으로 처리하기 위해서는 ( )를 이용해서 OR 조건을 처리해야만 한다.
select 
* 
from
(
	select /*+INDEX_DESC(tbl_board pk_board) */ -- 힌트
	    rownum rn, bno, title, content, writer, regdate, updatedate
	from
	  tbl_board
	where
	-- 변경부분
	(title like '%Test%' or content like '%Test%' or writer like '%Test%')
	
	and rownum <= 20
	)
where rn > 10;

결고를 보면 원하는 10개의 데이터만 출력되는 것을 볼 수 있다.

중요 ★★★★★★★★★★★★★★★★★★★
MyBatis의 동적 SQL
(실무에서 많이 씀)

SQL문에서 느끼는 점은 검색 조건이 변하면 SQL의 내용 역시 변하기 때문에 XML이나 어노테이션과 같이 고정된 문자열을 작성하는 방식으로 제대로 처리할 수 없다는 사실이다.
다행히 MyBatis는 동적(Dynamic) 태그 기능을 통해서 SQL을 파라미터들의 조건에 맞게 조정할
수 있는 기능을 제공한다.
MyBatis의 동적 태그는 약간의 구문을 이용해서 전달되는 파라미터를 가공해서 경우에 따라 SQL을 만들어서 실행할 수 있다.

MyBatis의 동적 태그들
MyBatis는 기존의 iBatis에서 발전하면서 복잡했던 동적 SQL을 작성하는 태그들이 많이 정리되어서 다음과 같이 몇가지의 태그들만을 이용한다.

- if
- choose(when, otherwise)
- trim(where, set)
- foreach

-- 위에 동적 태그들은 따로 웹서핑하여 개념을 잡는게 좋음
	그러려면 JAVA를 잘 이해해야함



검색 조건 처리를 위한 Criteria의 변화

페이징 처리에 사용했던 Criteria의 의도는 단순히 'pageNum'과 'amount'라는 파라미터를 수집하기 위해서이다.
페이징 처리에 검색 조건 처리가 들어가면 Criteria 역시 변화가 필요하다.

검색 조건을 처리하기 위해서는 검색 조건(type)과 검색에 사용하는 키워드가 필요하므로, 기존의 Criteria를 확장할 필요가 있다.
확정 방법으로는 상속 방법을 이용하거나 직접 Criteria 클래스를 수정하는 방식을 생각해 볼 수 있는데, 예제에서는 직접 Criteria 클래스를 수정했다.

예제) Criteria 수정( type과 keyword의 파라미터를 수집하기 위하여 추가)

package org.zerock.domain;

import org.springframework.web.util.UriComponentsBuilder;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
// Criteria는 '검색의 기준'을 의미
public class Criteria {

	private int pageNum;
	private int amount;
	
	// p.334 검색을 위한 추가
	private String type;
	private String keyword;
	
	public Criteria() {
		this(1,10);
	}
	
	public Criteria(int pageNum, int amount) {
		this.pageNum = pageNum;
		this.amount = amount;
	}
	
	// p.334 검색을 위한 추가
	public String[] getTypeArr() {
		
		return type == null ? new String[] {} : type.split("");
	}
	
	
}

Criteria 클래스는 type과 keyword라는 변수를 추가한다.
getter/setter는 lombok을 통해서 생성하고, getTypeArr은 검색 조건이 각 글자(T, W, C)로 구성되어 있으므로 검색 조건을 배열로
만들어서 한 번에 처리하기 위함이다.
getTypeArr()을 이용해서 MyBatis의 동적 태그를 활용할 수 있다.

BoardMapper.xml에서 Criteria 처리
BoardMapper.xml은 기존의 getListWithPaging()을 수정해서 동적 SQL을 처리한다.

예제) BoardMapper.xml의 검색 및 페이징 처리

<select id="getListWithPaging" resultType="org.zerock.domain.BoardVO">
<![CDATA[
SELECT
	bno, title, content, writer, regdate, updatedate
FROM
	(
	select /*+INDEX_DESC(tbl_board pk_board) */
	 	rownum rn, bno, title, content, writer, regdate, updatedate
	from 
		tbl_board
	where rownum <= 20
	) 
	where rn > 10
]]>

	<trim prefix="(" suffix=") AND " prefixOverrides="OR">
		<foreach item='type' collection="typeArr">
			<trim prefix="OR">
				<choose>
					<when test="type == 'T'.toString()">
					title like '%'||#{keyword}||'%'
					</when>
					<when test="type == 'C'.toString()">
					content like '%'||#{keyword}||'%'
					</when>
					<when test="type == 'W'.toString()">
					writer like '%'||#{keyword}||'%'
					</when>
				</choose>
			</trim>
		</foreach>
	</trim>
	
<![CDATA[
  rownum <= #{pageNum} * #{amount}
  ) 
where rn > (#{pageNum} -1) * #{amount}
]]>
</select>


검색 조건이 3가지이므로 총 6가지의 조합이 가능하지만, 각 문자열을 이용해서 검색 조건을 결합하는 형태로 하면 3개의 동적 SQL 구문만으로도
처리를 할 수 있다.
<foreach>를 이용해서 검색 조건들을 처리하는데 typeArr이라는 속성을 이용한다.
MyBatis는 원하는 속성을 찾을 때 getTypeArr()과 같이 이름에 기반을 두어서 검색하기 때문에 Criteria에서 만들어둔 getTypeArr() 결과인 문자열의 배열이 <foreach>의
대상이 되다.
(MyBatis는 엄격하게 Java Beans의 규칙을 따르지 않고, get/set 메서드만을 활용하는 방식이다.)

<choose>안쪽의 동적 SQL은 'OR title ... OR content... OR writer...' 와 같은 구문을 만들어내게 된다.
따라서 바깥쪽에서는 <trim>을 이용해서 맨 앞에서는 생성되는 'OR'를 없애준다.

동적 SQL은 경우에 따라서 여러 종류의 SQL이 생성될 수 있으므로 제대로 동작하는지 반드시 여러 번의 확인을 거쳐야만 한다.
기존에 BoardMapperTests를 만들어 두었으니 이를 이용해서 테스트 코드를 작성한다.

예제) BoardMapperTests 클래스의 testSearch() 메소드 추가

	@Test
	public void testSearch() {
		
		Criteria cri = new Criteria();
		cri.setKeyword("part3 최종 테스트 확인 내용");
		cri.setType("C");
		
		List<BoardVO> list = mapper.getListWithPaging(cri);
		
		list.forEach(board -> log.info(board));
	}


testSearch()는 Criteria 객테의 type과 keyword를 넣어서 원하는 SQL이 생성되는지 확인하기 위함이다.
중요한 것은 실행 결과가 아니라 실행할 때 만들어지는 SQL이다.

<sql><include>와 검색 데이터의 개수 처리

동적 SQL을 이용해서 검색 조건을 처리하는 부분은 해당 데이터의 개수를 처리하는 부분에서도 동일하게 적용되어야만 한다.
이 경우 가장 간단한 방법은 동적 SQL을 처리하는 부분을 그대로 복사해서 넣어줄 수 있지만, 만일 동적 SQL을 수정하는 경우에는 매번 목록을 가져오는 SQL과 데이터 개수를 처리하는 
SQL 쪽을 같이 수정해야 한다.

MyBatis는 <sql>이라는 태그를 이용해서 SQL의 일부를 별도로 보관하고, 필요한 경우에 include시키는 형태로 사용할 수 있다.

예제) BoardMapper.xml의 목록과 데이터 개수 처리

<sql id="criteria">
		<trim prefix="(" suffix=") AND " prefixOverrides="OR">
			<foreach item='type' collection="typeArr">
				<trim prefix="OR">
					<choose>
						<when test="type == 'T'.toString()">
						title like '%'||#{keyword}||'%'
						</when>
						<when test="type == 'C'.toString()">
						content like '%'||#{keyword}||'%'
						</when>
						<when test="type == 'W'.toString()">
						writer like '%'||#{keyword}||'%'
						</when>
					</choose>
				</trim>
			</foreach>
		</trim>
	</sql>
<select id="getListWithPaging" resultType="org.zerock.domain.BoardVO">
	<![CDATA[
	SELECT
		bno, title, content, writer, regdate, updatedate
	FROM
		(
		select /*+INDEX_DESC(tbl_board pk_board) */
		 	rownum rn, bno, title, content, writer, regdate, updatedate
		from 
			tbl_board
		where 
		
	]]>

	<include refid="criteria"></include>
	<![CDATA[
	rownum <= #{pageNum} * #{amount}
	) 
	where rn > (#{pageNum} -1) * #{amount}
	]]>
</select>

	<!-- p.323 Mybatis에서 전체 데이터의 개수 처리 -->
	<select id="getTotalCount" resultType="int">
		select count(*) from tbl_board 
		where 
		
		<include refid="criteria"></include>
		
		bno > 0
	</select>

<sql> 태그는 id라는 속성을 이용해서 필요한 경우에 동일한 SQL의 일부를 재사용할 수 있게 한다.


화면에서 검색 조건 처리

화면에서 검색은 다음과 같은 사항들을 주의해서 개발해야 한다.

- 페이지 번호가 파라미터로 유지되었던 것처럼 검색 조건과 키워드 역시 항상 화면 이동 시 같이 전송되어야 한다.
- 화면에서 검색 버튼을 클릭하면 새로 검색을 한다는 의미이므로 1페이지로 이동한다.
- 한글의 경우 GET방식으로 이동하는 경우 문제가 생길 수 있으므로 주의해야 한다.

목록 화면에서의 검색 처리

목록 화면인 list.jsp에서는 검색 조건과 키워드가 들어 갈 수 있게 HTML을 수정해야 한다.
views 폴더 내의 list.jsp를 수정해서 페이지 처리 바로 위쪽에 아래의 내용들을 추가 한다.

예제) list.jsp에 검색 조건 처리

   </c:forEach>		       
</table>
 <!-- p.340 list.jsp에 검색조건 처리 -->
 <div class="row">
	<div class="col-lg-12">
		<form id="searchForm" action="/board/list" method="get">
			<select name="type">
				<option value="">--</option>
				<option value="T">제목</option>
				<option value="C">내용</option>
				<option value="W">작성자</option>
				<option value="TC">제목 or 내용</option>
				<option value="TW">제목 or 작성자</option>
				<option value="TWC">제목 or 내용 or 작성자</option>	
			</select>	
			<input type="text" name="keyword">
			<input type="hidden" name="pageNum" value="${pageMaker.cri.pageNum }">
			<input type="hidden" name="amount" value="${pageMaker.cri.amount }">
			<button class="btn btn-default">Search</button>
		</form>
	</div>
</div>

수정된 HTML을 보면 페이징 처리를 위해서 만들어둔 <form> 태그에 <select>와 <input> 태그가 추가된 것을 볼 수 있다.

<form> 내 <button>의 기본 동작은 submit이므로 별도의 처리 없이 검색이 되는지 확인한다.
항상 테스트는 영문과 한들을 모두 테스트해야 한다.		                    

chrome 브라우저는 한글로 검색하는 경우에 주소창에는 한글이 깨지지 않고 나오지만 실제로는 그림에 있는 박스의 내용물처럼 전송되다.
IE에서는 박스의 내용과 동일하게 출력되는 것을 볼 수 있다.
검색이 처리된 후에는 몇 가지 문제가 있다는 사실을알게 되는데
1) 예를들아, 3페이지를 보다가 검색을 하면 3페이지로 이동하는 문제
2) 검색 후 페이지를 이동하면 검색 조건이 사라지는 문제
3) 검색 후 화면에서는 어떤 검색 조건과 키워드를 이용했는지 알 수 없는 문제들이 남아있는 것을 볼 수 있다.

검색 버튼의 이벤트 처리

여러 문제들 중에서 검색 버튼을 클릭하면 검색은 1페이지를 하도록 수정하고, 화면에 검색 조건과 키워드가 보이게 처리하는 작업을 우선으로 진행한다.

예제) list.jsp의 검색 버튼의 이벤트 처리(JavaScript)

		-- id가 searchFrom인 <form>을 클릭했을때 option속성에 selected가 value값이 없을 경우와 input에 value값이 없을때 alert를 뿌리고 return false처리
		   다있다면 pageNum을 1페이지로 init초기화
		var searchForm = $("#searchForm");
		
		$("#searchForm button").on("click", function (e) {
			
			if (!searchForm.find("option:selected").val()) {
				alert("검색종류를 선택하세요");
				return false;
			}
			
			if (!searchForm.find("input[name='keyword']").val()) {
				alert("키워드를 입력하세요");
				return false;
			}
			
			searchForm.find("input[name='pageNum']").val("1");
			e.preventDefault();
		    
			searchForm.submit();
			
		});

브라우저에서 검색 버튼을 클릭하면 <form> 태그의 전송은 막고, 페이지의 번호는 1이 되도록 처리한다.
화면에서 키워드가 없다면 검색을 하지 않도록 제어한다.
검색 후에는 주소창에 검색 조건과 키워드가 같이 GET 방식으로 처리되므로 이를 이용해서
<select> 태그나 <input> 태그의 내용을 수정한다.

예제) list.jsp에서 검색 조건과 키워드 보여주는 부분

 <!-- p.343 list.jsp에서 검색 조건과 키워드 보여주는 부분 수정 --> 
		                    <div class="row">
		                    	<div class="col-lg-12">
		                    		<form id="searchForm" action="/board/list" method="get">
		                    			<select name="type">
		                    				<option value=""
		                    					<c:out value="${pageMaker.cri.type == null?'selected':'' }"/>>--</option>	              
		                    				<option value="T"
		                    					<c:out value="${pageMaker.cri.type eq 'T'?'selected':''}"/>>제목</option>
		                    				<option value="C"
		                    					<c:out value="${pageMaker.cri.type eq 'C'?'selected':''}"/>>내용</option>
		                    				<option value="W"
		                    					<c:out value="${pageMaker.cri.type eq 'W'?'selected':''}"/>>작성자</option>
		                    				<option value="TC"
		                    					<c:out value="${pageMaker.cri.type eq 'TC'?'selected':''}"/>>제목 or 내용</option>
		                    				<option value="TW"
		                    					<c:out value="${pageMaker.cri.type eq 'TW'?'selected':''}"/>>제목 or 작성자</option>
		                    				<option value="TWC"
		                    					<c:out value="${pageMaker.cri.type eq 'TWC'?'selected':''}"/>>제목 or 내용 or 작성자</option>	
		                    			</select>	
		                    		 	<input type="text" name="keyword"
		                    		 		value="<c:out value='${pageMaker.cri.keyword}'/>" />
		                    		 	<input type="hidden" name="pageNum" value="${pageMaker.cri.pageNum }">
		                    		 	<input type="hidden" name="amount" value="${pageMaker.cri.amount }">
		                    		 	<button class="btn btn-default">Search</button>
		                    		</form>
		                    	</div>
		                    </div>

<select> 태그의 내부는 삼항 연산자를 이용해서 해당 조건으로 검색되었다면 'selected'라는 문자열을 출력하게 해서 화면에서 선택된 항목으로 보이도록 한다.

페이지 번호를 클릭해서 이동할 때에도 검색 조건과 키워드는 같이 전달되어야 하므로 페이지 이동에 사용한 <form> 태그를 아래와 같이 수정한다.

예제) list.jsp의 일부

 <form id="actionForm" action="/board/list" method="get">
  	<input type="hidden" name="pageNum" value="${pageMaker.cri.pageNum }">
  	<input type="hidden" name="amount" value="${pageMaker.cri.amount }">
  	<!-- p.344 페이지 번호를 클릭해서 이동할 때에도 검색 조건과 키워드는 같이 전달되어야 함 -->
  	<input type="hidden" name="type" value="${pageMaker.cri.type }">
  	<input type="hidden" name="keyword" value="${pageMaker.cri.keyword }">
 </form>

검색 조건과 키워드에 대한 처리가 되면 검색 후 페이지를 이동해서 동일한 검색 사항들이 계속 유지되는 것을 볼 수 있다.



조회 페이지에서 검색 처리

목록 페이지에서 조회 페이지로의 이동은 이미 <form> 태그를 이용해서 처리했기 때문에 별도의 처리가 필요하지 않는다.
다만 조회 페이지는 아직 Criteria의 type과 keyword에 대한 처리가 없기 때문에 이 부분을 수정해 줄 필요가 있다.

예제) get.jsp 조회페이지에서 검색 처리

				 <form id="operForm" action="/board/modify" method="get">
		                  	<input type="hidden" id="bno" name="bno" value="<c:out value='${board.bno}'/>">
		           		<input type="hidden" name="pageNum" value="<c:out value='${cri.pageNum}'/>">
		                  	<input type="hidden" name="amount" value="<c:out value='${cri.amount}'/>">
		                  	<!-- p.345 조회 페이지에서 검색처리 -->
		                  	<input type="hidden" name="keyword" value="<c:out value='${cri.keyword}'/>">
		                  	<input type="hidden" name="type" value="<c:out value='${cri.type}'/>">
		                  </form>

수정 / 삭제 페이지에서 검색처리

조회 페이지에서 수정/ 삭제 페이지로의 이동은 GET 방식을 통해서 이동하고, 이동 방식 역시 <form> 태그를 이용하는 방식이므로 기존의 <form> 태그에 추가적인 type과 keyword
조건만을 추가한다.

예제) modify.jsp 일부

   			<form role="form" action="/board/modify" method="post">
		                  
		                  <!-- p.319 추가 -->
	                  	<input type="hidden" name="pageNum" value="<c:out value='${cri.pageNum}'/>">
	                  	<input type="hidden" name="amount" value="<c:out value='${cri.amount}'/>">
	                  	<!-- p.346 추가 -->
	                  	<input type="hidden" name="keyword" value="<c:out value='${cri.keyword}'/>">
	                  	<input type="hidden" name="type" value="<c:out value='${cri.type}'/>">

수정/ 삭제 처리는 BoardController에서 redirect방식으로 동작하므로 type과 keyword조건을 같이 리다이렉트 시에 포함시켜야만 한다.

예제) BoardController의 일부

	// p.319 modify 수정/삭제 처리 후 이동
	@PostMapping("/modify")
	public String modify(BoardVO board,@ModelAttribute("cri")Criteria cri ,RedirectAttributes rttr) {
		
		log.info("modify : " + board);
		
		if (service.modify(board)) {
			rttr.addFlashAttribute("result", "success");
			
		}
		
		rttr.addAttribute("pageNum", cri.getPageNum());
		rttr.addAttribute("pageNum", cri.getAmount());
		// p.346 수정/삭제 처리는 BoardContorller에서 redirect 방식으로 동작하므로 type과 keyword 조건을 같이 리다이렉트 시에 포함시켜야만 한다.
		rttr.addAttribute("keyword", cri.getKeyword());
		rttr.addAttribute("type", cri.getType());
		
		return "redirect:/board/list";
	}


	@PostMapping("/remove")
	public String remove(@RequestParam("bno") Long bno,@ModelAttribute("cri")Criteria cri ,RedirectAttributes rttr) {
		
		log.info("remove : " + bno);
		if (service.remove(bno)) {
			rttr.addFlashAttribute("result", "success");
		}
		
		rttr.addAttribute("pageNum",cri.getPageNum());
		rttr.addAttribute("pageNum",cri.getAmount());
		// p.346 수정/삭제 처리는 BoardContorller에서 redirect 방식으로 동작하므로 type과 keyword 조건을 같이 리다이렉트 시에 포함시켜야만 한다.
		rttr.addAttribute("keyword", cri.getKeyword());
		rttr.addAttribute("type", cri.getType());
		
		return "redirect:/board/list" ;
	}

★★★★
리다이렉트는 GET방식으로 이루어지기 때문에 추가적인 파라미터를 처리해야 한다.
modify.jsp에서는 다시 목록으로 이동하는 경우에 필요한 파라미터만 전송하기 위해서 <form> 태그의 모든 내용을 지우고 다시 추가하는 방시을 이용했으므로 keyword와 type 
역시 추가하도록 아래와 같이 관련된 JavaScript 코드를 수정해야한다.

예제) modify.jsp (JavaScript)수정

				// p.321 수정/삭제 페이지에서 목록 페이지 이동
				var pageNumTag = $("input[name='pageNum']").clone();
				var amountTag = $("input[name='amount']").clone();
				// p.347 리다이렉트는 GET방식으로 이루어지기 때문에 추가적인 파라미터를 처리해야한다. 
				// 다시 목록으로 이동하는 경우에 필요한 파라미터만 전송하기 위해서 <form> 태그의 모든 내용을 지우고 다시 추가하는 방식을 이용했다.
				var keywordTag = $("input[name='keyword']").clone();
				var typeTag = $("input[name='type']").clone();
				formObj.empty();
				formObj.append(pageNumTag);
				formObj.append(amountTag);
				formObj.append(keywordTag);
				formObj.append(typeTag);


수정/조회 화면에서 어떤 작업을 하던지 다시 목록 페이지로 검색 조건이 유지되는지 확인해야한다.

검색한 상태에서 페이지의 게시물을 수정하면 검색 조건은 유지한 채 목록 페이지로 이동하는지를 테스트한다.

UriComponentsBuilder를 이용하는 링크 생성

웹페이지에서 매번 파라미터를 유지하는 일이 번거롭고 힘들다면 한 번쯤
UriComponentsBuilder라는 클래스를 이용해볼 필요가 있다.
org.springframework.web.util.UriComponentsBuilder는 여러 개의 파라미터들을 연결해서
URL의 형태로 만들어주는 기능을 가지고 있다.
URL을 만들어주면 리다이렉트를 하거나, <form> 태그를 사용하는 상황을 많이 줄여줄 수 있다.
검색 조건을 유지하는 Criteria 클래스에 링크를 생성하는 기능을 추가한다.

예제) Criteria 클래스의 일부

	// p. 349 링크를 생성하는 기능을 추가
	public String getListLink() {
		
		UriComponentsBuilder builder = UriComponentsBuilder.fromPath("")
				.queryParam("pageNum", this.pageNum)
				.queryParam("amount", this.getAmount())
				.queryParam("type", this.getType())
				.queryParam("keyword", this.getKeyword());
		
		return builder.toUriString();


UriComponentsBuilder는 queryParam()이라는 메서드를 이용해서 필요한 파라미터들을 손쉽게 추가할 수 있다.
예를 들어, 아래와 같은 조건들로 Criteria가 생성된다고 가정해 보겠다.
Criteria cri = new Criteria();
	cri.setPageNum(3);
	cri.setAmount(20);
	cri.setKeyword("새로");
	cri.setType("TC");

위와 같은 데이터를 가진 Criteria의 getListLink()의 결과는 '?pageNum = 3&amount=20&type=TC&keyword=%EC%83%88%EB%A1%9C'와 같이 GET방식에 적합한
URL 인코딩된 결과로 만들어 진다.
(가장 편리한 점은 한글 처리에 신경 쓰지 않아도 된다는 점이다.)


getListLink()를 이용하면 BoardController의 modify()와 remove()를 다음과 같이 간단하게 정리할 수 있다.

예제) BoardController의 일부 

	// p.319 modify 수정/삭제 처리 후 이동
	@PostMapping("/modify")
	public String modify(BoardVO board,@ModelAttribute("cri")Criteria cri ,RedirectAttributes rttr) {
		
		log.info("modify : " + board);
		
		if (service.modify(board)) {
			rttr.addFlashAttribute("result", "success");
			
		}

		return "redirect:/board/list" + cri.getListLink();
	}


	@PostMapping("/remove")
	public String remove(@RequestParam("bno") Long bno,@ModelAttribute("cri")Criteria cri ,RedirectAttributes rttr) {
		
		log.info("remove : " + bno);
		if (service.remove(bno)) {
			rttr.addFlashAttribute("result", "success");
		}

		
		return "redirect:/board/list" + cri.getListLink();
	}
	

UriComponentsBulider로 생성된 URL은 화면에서도 유용하게 사용될 수 있는데, 
주로 JavaScript를 사용할 수 없는 상황에서 링크를 처리해야 하는 상황에서 사용된다.