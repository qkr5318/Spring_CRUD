PART 4
REST 방식과 Ajax를 이용하는 댓글 처리

전통적인 웹 애플리케이션은 주로 서버사이드에서 화면에 필요한 모든 데이터를 만들어서 브라우저에 전송해주고, 
브라우저는 단순 뷰어(viewer) 역할에 그치는 형태였다.
시간이 흘러 모바일 환경이 대두되면서 이러한 서버의 역할은 많이 달라지고 있다.
서버는 브라우저나 모바일에서 필요한 순수한 데이터만을 전달하는 API 서버의 형태로 변화하고 있다.
예컨대, 검색 API 서버는 검색의 결과를 XML이나 JSON의 형태로 전달하고, 
브라우저나 모바일에서는 이를 가공해서 사용자에게 보여주는 방식이다.

PART4 에서는 이러한 환경에 대비할 수 있도록 REST 방식에 대해서 학습하고, Ajax를 이용해서 완성된 게시물에 댓글 기능을 추가해 본다.

REST 방식으로 전환 

지난 10년간 일어난 IT 분야의 가장 큰 변화를 생각해 보면 역시 '모바일'이라는 단어를 떠올릴 것이다.
모바일은 모든 사람들의 생활 깊숙이 침투해서 생활 방식에 많은 영향을 주고 있다.
모든 업무나 일상 생활에 필요한 작업들을 대부분 모바일을 통해서 할 수 있는 지금의 생활에서 WEB이라는 분야 역시 변화를 겪게 된다.

모바일 시대가 되면서 WEB 분야의 가장 큰 변화는 서버 역활의 변화라고 할 수 있다.
과거에는 서버의 데이터를 소비하는 주체가 '브라우저'라는 특정한 애플리케이션으로 제한적이었다면, 모바일의 시대가 되면서 앱이나 웹은 서버에서 제공하는 데이터를 소비하게 된다.
과거의 서버는 브라우저라는 하나의 대상만을 상대로 데이터를 제공했기 때문에 아예 브라우저가 소화 가능한 모든 데이터를 HTML이라는 형태로 전달하고,
브라우저는 이를 화면에 보여주는 역확을 해 왔다.

스마트폰에서는 앱(App)이라 불리는 고유한 애플리케이션을 이용해서 데이터를 소비하게 되고, 보이는 화면 역시 자신만의 방식으로 서비스하게 된다.
앱에서 서버에 기대하는 것은 완성된 HTML이 아니라 그저 자신에게 필요한 순수한 데이터만을 요구하게 되었다.
이처럼 서버의 역할은 점점 더 순수하게 데이터에 대한 처리를 목적으로 하는 형태로 진화하고 있다.
또한, 브라우저와 앱은 서버에서 전달하는 데이터를 이용해서 앱 혹은 브라우저 내부에서 별도의 방식을 통해서 이를 소비하는 형태로 전환하고 있다.

이러한 변화 속에서 웹의 URI(Uniform Resource Identifier) 의미도 조금 다르게 변화하기 시작했다.
예를 들어 과거에 제작된 웹페이지들의 경우 페이지를 이동하더라도 브라우저의 주소는 변화하지 않는 방식을 선호했다.
(가장 대표적인 사티으가 네이버의 카페와 같은 경우)
반면에 최근의 웹페이지들은 대부분 페이지를 이동하면 브라우저 내의 주소 역시 같이 이동하는 방식을 사용한다.

★note
흔희 URL(Uniform Resource Locator)과 URI(Uniform Resource Identifier)를 같은 의미로 사용하는 경우가 많다.
엄밀하게 URL은 URI의 하위 개념이기 때문에 혼용해도 무방하다. URI는 '자원의 식별자'라를 의미로 사용된다.

URL은 '이 곳에 가면 당신이 원하는 것을 찾을 수 있다.'와 같은 상징적인 의미가 좀 더 강하다면, URI는 '당신이 원하는 곳의 주소는 여기이다'와 같이 좀 더 현실적이고
구체적인 의미가 있다. URI의 'I'는 마치 데이터베이스의 PK와 같은 의미로 사용된다고 생각할 수 있다.

REST는 'Representational State Transfer'의 약어로 하나의 URI는 하나의 고유한 리소르(Resource)를 대표하도록 설계된다는 개념에 전송방식을 결합해서 원하는 작업을 지정한다.
예를 들어 '/boards/123'은 게시물 중에서 123번이라는 고유한 의미를 가지도록 설계하고, 이에 대한 처리는 GET, POST 방식과 같이 추가적인 정보를 통해서 결정한다.
URI + GET/POST/PUT/DELETE/...

스프링은 @RequestMapping이나 @ResponseBody와 같이 REST 방식의 데이터 처리를 위한 여러 종류의 어노테이션과 기능이 있다.
REST와 관련해서 알아두어야 하는 어노테이션은 다음과 같다.

- @RestController = Controller가 REST 방식을 처리하기 위한 것임을 명시한다.
- @ResponseBody = 일반적인 JSP와 같은 뷰로 전달되는 게 아니라 데이터 자체를 전달하기 위한 용도
- @PathVariable = URL 경로에 있는 값을 파라미터로 추출하려고 할 때 사용
- @CrossOrigin = Ajax의 크로스 도메인 문제를 해결해주는 어노테이션
- @RequestBody = JSON 데이터를 원하는 타입으로 바인딩 처리


@RestController

REST 방식에서 가장 먼저 기억해야 하는 점은 서버에서 전송하는 것이 순수한 데이터라는 점이다.
기존의 Controller에서 Model에 데이터를 담아서 JSP 등과 같은 뷰(View)로 전달하는 방식이 아니므로 기존의 Controller와는 조금 다르게 동작한다.

스프링4에서부터는 @Controller 외에 @RestController라는 어노테이션을 추가해서 해당 Controller의 모든 메서드의 리턴 타입을 기존과 다르게 처리한다는 것을 명시한다.
@RestController 이전에는 @Controller와 메서드 선언부에 @ResponseBody를 이용해서 동일한 결과를 만들 수 있다.
@RestController는 메서드의 리턴 타입으로 사용자가 정의한 클래스 타입을 사용할 수 있고, 이를 JSON이나 XML로 자동으로 처리할 수 있다.

예제 프로젝트 준비
POM.XML 수정

ex02 pom.xml을 복사 붙여 넣기 한 뒤
jackson-datebind 추가
(JSON데이터를 처리하기 위한 라이브러리 -> 브라우저에 객체를 JSON이라는 포맷의 문자열로 변환시켜 전송할 때 필요하다.)

★note
JSON(JavaScript Object Notation)의 약어로 구조가 있는 데이터를 '{}'로 묶고 '키'와 '값'으로 구성하는 경량의 데이터 포맷이다.
구조를 표현한 무자열은 프로그래밍 언어에 관계 없이 사용할 수 있기 때문에 XML과 더불어 가장많이 사용되는 데이터의 표현 방식이다.

예제) POM.XML 추가
	<!-- part4 추가 -->
		
		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
		<dependency>
		    <groupId>com.fasterxml.jackson.core</groupId>
		    <artifactId>jackson-databind</artifactId>
		    <version>2.9.6</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml -->
		<dependency>
		    <groupId>com.fasterxml.jackson.dataformat</groupId>
		    <artifactId>jackson-dataformat-xml</artifactId>
		    <version>2.9.6</version>
		</dependency>

테스트 할 때는 직접 Java 인스턴스를 JSON 타입의 문자열로 변환해야 하는 일들도 있으므로 gson라이브러리도 추가한다.
코드 내의 Gson 라이브러리는 Java의 객체를 JSON 문자열로 변환하기 위해서 사용한다.
예제) POM.XML 추가

	<!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
		<dependency>
		    <groupId>com.google.code.gson</groupId>
		    <artifactId>gson</artifactId>
		    <version>2.8.2</version>
		</dependency>



@RestController의 반환 타입

스프링의 @RestController는 특별히 기존의 @Controller와 다른 점은 없다.
'org.zerock.controller'패키지에 SampleController 생성

예제) SampleController 생성

package org.zerock.controller;


import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


import lombok.extern.log4j.Log4j;

@RestController
@RequestMapping("/sample")
@Log4j
public class SampleController {

}	

단순 문자열 반환 

@RestController는 JSP와 달리 순수한 데이터를 반환하는 형태이므로 다양한 포맷의 데이터를 전송할 수 있다.
주로 많이 사용하는 형태는 일반 문자열이나 JSON, XML등을 사용한다.

예제) SampleController 추가

package org.zerock.controller;


import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


import lombok.extern.log4j.Log4j;

@RestController
@RequestMapping("/sample")
@Log4j
public class SampleController {
	
	@GetMapping(value = "/getText", produces = "text/plain; charset=UTF-8")
	public String getText() {
		
		log.info("MIME TYPE : " + MediaType.TEXT_PLAIN_VALUE);
		
		return "안녕하세요";
	}

}

기존의 @Controller는 문자열을 반환하는 경우에는 JSP 파일의 이름으로 처리하지만, @RestController의 경우에는 순수한 데이터가 된다.
@GetMapping에 사용된 produces 속성은 해당 메서드가 생산하는 MIME 타입을 의미한다.
예제와 같이 문자열로 직접 지정할 수 있고, 메서드 내의 MediaType이라는 클래스를 이용할 수도 있다.
프로젝트의 실행은 이전 예제들과 같이 '/'경로로 실행되도록 하고 브라우저를 통해서
'/sample/getText'를 호출한다.

객체의 반환

객체를 반화하는 작업은 JSON이나 XML을 이용한다. 전달된 객체를 생상하기 위해서
'org.zerock.domain' 패키지를 생성하고, SampleVO 클래스를 작성한다.

예제) SampleVO 클래스 생성

package org.zerock.domain;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
// @AllArgsConstructor 모든 속성을 사용하는 생성자를 위한 
@NoArgsConstructor
// @NoArgsConstructor 비어 있는 생성자를 만들기 위한 
public class SampleVO {

	private Integer mno;
	private String firstName;
	private String lastName;
}


SampleVO 클래스는 비어 있는 생성자를 만들기 위한 @NoArgsConstructor와 
모든 속성을 사용하는 생성자를 위한 @AllArgsConstructor 어노테이션을 이용했다.

예제) SampleController에서 SampleVO를 리턴하는 getSample()메서드를 추가

@GetMapping(value = "/getSample",
	produces = { MediaType.APPLICATION_JSON_UTF8_VALUE,
	MediaType.APPLICATION_XML_VALUE})
	public SampleVO getSample() {
		
		return new SampleVO(112, "스타", "로드");
	}


getSample()은 XML과 JSON 방식의 데이터를 생성할 수 있도록 작성되었는데,
브라우저에서 '/sample/getSample'을 호출하면 XML형식으로 나온다
(APPLICATION_JSON_UTF8_VALUE는 스프링 5.2 버전부터는 Deprecated되고, APPLICATION_JSON_VALUE로 사용된다.)

브라우저가 받은 데이터가 XML이기 때문에 보이는 화면형식이다.
개발자 도구를 통해서 살펴보면 정상적인 XML데이터라는 것을 확인할 수 있다.

동일한 메서드를 '/sample/getSample.json'을 호출하게 되면 기존과 달리 JSON 타입의 데이터가 전달되는 것을 확인할 수 있다.

@GetMapping이나 @RequesetMapping의 produces 속성은 반드시 지정해야 하는 것은 아니므로 생략하는 것도 가능하다.

예제) SampleController에서 getSample2()메소드 추가

@GetMapping(value = "/getSample2")
	public SampleVO getSample2() {
		
		return new SampleVO(113, "로켓", "라쿤");
	}

컬렉션 타입의 객체 반환

경우에 따라서는 여러 데이터를 한 번에 전송하기 위해서 배열이나 릿트, 맵 타입의 객체들을 전송하는 경우도 발생한다.

예제) SmapleController getList() 메소드 추가

@GetMapping(value = "/getList")
	public List<SampleVO> getList(){
		
		return IntStream.range(1, 10).mapToObj(i -> new SampleVO(i, i + "First", i + " Last")).collect(Collectors.toList());
	}

getList()는 내부적으로 1부터 10미만까지의 루프를 처리하면서 SampleVO 객체를 만들어서 List<SampleVO>로 만들어 낸다.

브라우저를 통해서 '/sample/getList'를 호출하면 기본적으로는 XML 데이터를 전송하는 것을 볼 수 있다.
뒤에 확장자를 '.json'으로 처리하면 '[]'로 싸여진 JSON 형태의 배열 데이터를 볼 수 있다.

맵의 경우에는 '키'와 '값'을 가지는 하나의 객체로 간주된다.

예제) SampleController getMap()메소드 추가

	@GetMapping(value = "/getMap")
	public Map<String, SampleVO> getMap(){
		
		Map<String, SampleVO> map = new HashMap<>();
		map.put("First", new SampleVO(111, "그루트", "주니어"));
		
		return map;
	}
	
브라우저에서 '/sample/getMap'을 호출하면 확인할 수 있다.

Map을 이용하는 경우에는 '키(key)'에 속하는 데이터는 XML로 변환되는 경우에 태그의 이름이 되기 때문에 문자열을 지정한다.

ResponseEntity 타입
REST 방식으로 호출하는 경우는 화면 자체가 아니라 데이터 자체를 전송하는 방식으로 처리되기 때문에 데이터를 요청한 쪽에서는 정상적인 데이터인지 비정상적인 데이터인지를
구분할 수 있는 확실한 방법을 제공해야만 한다.
ResponseEntity는 데이터와 함께 HTTP 헤더의 상태 메시지 등을 같이 전달하는 용도로 사용한다.
HTTP의 상태 코드와 에러 메시지 등을 함께 데이터를 전달할 수 있기 때문에 받는 입장에서는 확실하게 결과를 알 수 있다.

예제) sampleController check()메소드 추가

	@GetMapping(value = "/check", params = { "height", "weight"})
	public ResponseEntity<SampleVO> check(Double height, Double weight){
		
		SampleVO vo = new SampleVO(0, "" + height, "" + weight);
		
		ResponseEntity<SampleVO> result = null;
		
		if (height < 150) {
			result = ResponseEntity.status(HttpStatus.BAD_GATEWAY).body(vo);
		}else {
			result = ResponseEntity.status(HttpStatus.OK).body(vo);
		}
		
		
		return result;
	}

check()는 반드시 'height'와 'weight'를 파라미터로 전달받는다.
이때 만일 'height'값이 150보다 작다면 502(bad gateway) 상태 코드와 데이터를 전송하고, 그렇지 않다면 200(OK) 코드와 데이터를 전송한다.

'/sample/check.json?height=140&weight=60'과 같이 JSON 타입의 데이터를 요구하고, height 값을 150보다 작게 하는 경우에는 502메시지와 데이터가 전달된다.


@RestController에서 파라미터
// @RestController는 데이터 자체를 호출 @Controller는 화면 호출
@RestController는 기존의 @Controller에서 사용하던 일반적인 타입이나 사용자가 정의한 타입(클래스)을 사용한다.
여기에 추가로 몇 가지 어노테이션을 이용하는 경우가 있다.

- @PathVariable = 일반 컨트롤러에서도 사용이 가능하지만 REST 방식에서 자주 사용된다. URL 경로의 일부를 파라미터로 사용할 때 이용
- @RequestBody = JSON 데이터를 원하는 타입의 객체로 변환해야 하는 경우에 주로 사용

@PathVariable
REST 방식에서는 URL 내에 최대한 많은 정보를 담으려고 노력한다. 
예전에는 '?' 뒤에 추가되는 쿼리 스트링(query string)이라는 형태로 파라미터를 이용해서 전달되던 데이터들이 REST 방식에서는 경로의 일부로 차용되는 경우가 많다.

스프링 MVC에서는 @PathVariable 어노테이션을 이용해서 URL 상에 경로의 일부를 파라미터로 사용할 수 있다.
예)
http://localhost:8080/sample/{sno}
http://localhost:8080/sample/{sno}/page{pno}

위의 URL에서 '{}'로 처리된 부분은 컨트롤러의 메서드에서 변수로 처리가 가능하다.
@PathVariable은 '{}'의 이름을 처리할 때 사용된다.

REST방식에서는 URL 자체에 데이터를 식별할 수 있는 정보들을 표현하는 경우가 많으므로 다양한 방식으로 @PathVariable이 사용된다.

예제) SampleController getPath()메서드 추가
	@GetMapping("/product/{cat}/{pid}")
	public String[] getPath(
		@PathVariable("cat") String cat,
		@PathVariable("pid") Integer pid){
			
			return new String[] { "category: " + cat, "productid: " + pid};
		}

@PathVariable을 적용하고 싶은 경우에는 '{}'를 이용해서 변수명을 지정하고,
@PathVariable을 이용해서 지정된 이름의 변숫값을 얻을 수 있다. 값을 얻을 때에는 int, double과 같은 기본 자료형은 사용할 수 없다.

브라우저에서 '/sample/product/bags/1234'로 호출하면 cat과 pid 변수의 값으로 처리되는 것을 확인할 수 있다.

@RequestBody
@RequestBody느 전달된 요청(request)의 내용(body)을 이용해서 해당 파라미터의 타입으로 변환을 요구한다.
내부적으로 HttpMessageConverter 타입의 객체들을 이용해서 다양한 포맷의 입력 데이터를 변환할 수 있다.
대부분의 경우에는 JSON 데이터를 서버에 보내서 원하는 타입의 객체로 변화하는 용도로 사용되지만, 경우에 따라서는 원하는 포맷의 데이터를 보내고, 이를 해석해서 원하는 타입으로 사용하기도 한다.

변환을 위한 예제를 위해서 'org.zerock.domain' 패키지에 Ticket 클래스를 정의한다.

예제) Ticket 클래스 생성
package org.zerock.domain;

import lombok.Data;

@Data
public class Ticket {

	// 번호(tno), 소유주(owner), 등급(grade)를 지정
	private int tno;
	private String owner;
	private String grade;
}

Ticket 클래스를 사용하는 예제는 SampleController에 추가한다.
예제) SampleController에 Ticket 추가

	@PostMapping("/ticket")
	public Ticket convert(@RequestBody Ticket ticket) {
		
		log.info("convert............... ticket" + ticket);
		
		return ticket;
	}
										// POST 방식
SampleController의 다른 메서드와 달리 @PostMapping이 적용된 것을 볼 수 있는데, 이것은 @RequestBody가 말 그대로 요청(request)한 내용(body)을 처리하기 때문에 
일반적인 파라미터 전달방식을 사용할 수 없기 때문이다.


REST 방식의 테스트
위와 같이 GET방식이 아니고, POST 등의 방식으로 지정되어 있으면서 JSON 형태의 데이터를 처리하는 것을
브라우저에서 개발하려면 많은 시간과 노력이 들어간다.
@RestController를 쉽게 테스트할 수 있는 방법은 주로 REST 방식의 데이터를 전송하는 툴을 이용하거나, JUnit과 spring-test를 이용해서 테스트 하는 방식을 고려할 수 있다.

JUnit 기반의 테스트
JUnit을 이용하는 방식은 PART2에서 진행했던 방식을 그대로 이용한다.
다만 REST 방식을 이용하다 보면 JSON 데이터를 테스트해야 하므로 차이점 위주로 알아두면 좋다.

예제)'src/test/java' 폴더 아래 SampleControllerTests 클래스 생성

package org.zerock.controller;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.zerock.domain.Ticket;

import com.google.gson.Gson;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringJUnit4ClassRunner.class)
// Test For Controller
@WebAppConfiguration

@ContextConfiguration({"file:src/main/webapp/WEB-INF/spring/root-context.xml",
	"file:src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml"})
// Java Config
// @ContextConfiguration(classes = { 
// org.zerock.config.RootConfig.class,
// org.zerock.config.ServletConfig.class})

@Log4j
public class SampleControllerTests {

	@Setter(onMethod_ = {@Autowired})
	private WebApplicationContext ctx;
	
	private MockMvc mockMvc;
	
	@Before
	public void setup() {
		this.mockMvc = MockMvcBuilders.webAppContextSetup(ctx).build();
	}
	
	@Test
	public void testConvert() throws Exception{
		
		Ticket ticket = new Ticket();
		ticket.setTno(123);
		ticket.setOwner("Admin");
		ticket.setGrade("AAA");
		
		String jsonStr = new Gson().toJson(ticket);
		
		log.info(jsonStr);
		
		mockMvc.perform(post("/sample/ticket")
				.contentType(MediaType.APPLICATION_JSON)
				.content(jsonStr))
				.andExpect(status().is(200));
				
	}
}

testConvert()는 SampleController에 작성해 두 convert() 메서드를 테스트하기 위해서 작성하였다. SampleController의 convert()는 JSON으로 전달되는 데이터를 받아서
Ticket 타입으로 변환한다. 이를 위해서는 해당 데이터가 JSON이라는 것을 명시해 줄 필요가 있다.
MockMvc는 contentType()을 이용해서 전달하는 데이터가 무엇인지를 알려줄 수 있다.
코드 내의 Gson 라이브러리는 Java의 객체를 JSON 문자열로 변환하기 위해서 사용한다.

위의 코드를 실행하면 다음과 같이 전달되는 JSON 문자열이 Ticket 타입의 객체로 변환된 것을 볼수 있다.
INFO : org.springframework.test.web.servlet.TestDispatcherServlet - FrameworkServlet '': initialization completed in 23 ms
INFO : org.zerock.controller.SampleControllerTests - {"tno":123,"owner":"Admin","grade":"AAA"}
INFO : org.zerock.controller.SampleController - convert............... ticketTicket(tno=123, owner=Admin, grade=AAA)


JUnit을 이용하는 방식의 테스트 장점은 역시 Tomcat을 구동하지 않고도 컨트롤러를 구동해 볼 수 있다는 점이다.

기타 도구
JUnit을 이용하는 방식 외에도 Tomcat을 구동한다면 REST 방식을 테스트할 수 있는 여러 가지 도구들이 존재한다.
Java나 각종 언어로 개발된 라이브러리들을 이용할 수 있다.

최근에는 브라우저에서 직접 REST 방식을 테스트할 수 있는 도구들이 꽤 많이있다.
Chrome 브라우저 앱스토어(chrome://apps/)로 이동해서 'REST client'로 검색하면 꽤 많은 크롬 확장 프로그램들을 볼 수 있다.

여러 확장 프로그램 중에서 'Yet Another REST Client' 등을 이용해서 테스트를 진행한다.
Tomcat을 실행하였다면 'Restlet Cient'에서는 'GET/POST/...'등의 방식으로 접근이 가능하다. 요청의 내용(body) 역시 오른쪽의 화면처럼 원하는 내용을 전달할 수 있다.


다양한 전송방식
REST 방식의 데이터 교환에서 가장 특이한 점은 기존의 GET/POST 외에 다양한 방식으로 데이터를 전달한다는 점이다.
HTTP의 전송방식은  아래와 같은 형태로 사용된다.

작업	전송방식
Create	POST
Read	GET
Update	PUT
Delete	DELETE

REST 방식은 URI와 같이 결합하므로 회원(member)라는 자원을 대상으로 전송방식을 결합하면 아래와 같은 형태가 된다.

작업	전송방식		URI
등록	POST		/member/new
조회	GET		/member/{id}
수정	PUT		/member/{id} + body (json 데이터 등)
삭제	DELETE		/member/{id}

POST 방식도 그렇지만 PUT, DELETE 방식은 브라우저에서 테스트하기가 쉽지 않기 때문에 개발 시 JUnit이나 'Restlet Client' 등과 같은 도구를 이용해서
테스트하고 개발해야만 한다.


Ajax 댓글처리

REST 방식을 가장 많이 사용하는 형태는 역시 브라우저나 모바일 App 등에서 Ajax를 이용해서 호출하는 것이다.
예제에서는 Ajax의 호출을 가정하고 웹페이지에서 사용하는 댓글 기능을 작성해 보도록 한다.
데이터베이스 상에서 댓글은 전형적인 1:N의 관계로 구성한다.
하나의 게시물에 여러 개의 댓글을 추가하는 형태로 구성하고, 화면은 조회 화면상에서 별도의 화면 이동 없이 처리하기 때문에 Ajax를 이용해서 호출한다.

이번 예제는 이전 PART3의 예제에 추가하는 형태로 작성한다. 프로젝트의 설정은 이전 장의 내용을 참고해서 구성해야만 한다.

프로젝트의 구성

REST 처리를 위해서는 pom.xml에서 수정된 내용이 대부분이므로, PART3에서 사용된 'src/main/java' 폴더 아래 모든 Java코드를 그대로 복사해서 사용한다.
'src/main/resources'에서는 log4jdbc-log4j2를 이용하기 위해서 log4jdbc.log4j2.properties 파일을 반드시 추가해야 한다.
또한 MyBatis에서 이용할 XML 파일들 역시 추가한다.

프로젝트는 오라클을 이용하므로 프로젝트의 설정을 통해서 JDBC 드라이버가 프로젝트 경로에 포함되도록 설정해준다.

WEB과 관련된 파일들 역시 PART3 예제의 모든 내용을 그대로 복사해서 사용한다.
Resources 폴더와 views 폴더 아래 모든 내용을 복사해서 프로젝트에 추가한다.

Tomcat의 실행은 '/' 경로를 이용해서 프로젝트가 정상적으로 동작하는지 확인해야 한다.


댓글 처리를 위한 영속 영역
댓글을 추가하기 위해서 댓글 구조에 맞는 테이블을 설계한다.
댓글 테이블은 tbl_reply라는 이름의 테이블로 지정해서 생성한다.

예제) 테이블 생성 tbl_reply및 시퀀스 생성, PK부여, tbl_board 참조

create table tbl_reply(
    rno number(10,0),
    bno number(10,0) not null,
    reply varchar2(1000) not null,
    replyer varchar2(50) not null,
    replyDate date default sysdate,
    updateDate date default sysdate
    );

reate sequence seq_reply;

drop TABLE tbl_reply;
alter table tlb_reply add CONSTRAINT pk_reply primary key (rno);

alter table tbl_reply add CONSTRAINT fk_reply_board
    foreign key(bno) references tbl_board(bno);


tbl_reply 테이블은 bno라는 칼럼을 이용해서 해당 댓글이 어떤 게시물의 댓글인지를 명시하도록 한다.
댓글 자체는 단독으로 CRUD 가 가능하므로, 별도의 PK를 부여하도록 하고 외래키(FK) 설정을 통해서 tbl_board 테이블을 참조하도록 설정한다.

ReplyVO 클래스의 추가
tbl_reply 테이블을 참고해서 org.zerock.domain 패키지 아래 ReplyVO 클래스를 추가한다.

예제) ReplyVO 클래스 생성

package org.zerock.domain;

import java.util.Date;

import lombok.Data;

@Data
public class ReplyVO {
	
	private Long rno;
	private Long bno;
	
	private String reply;
	private String replyer;
	private Date replyDate;
	private Date updateDate;
}

ReplyMapper 클래스와 XML 처리

org.zerock.mapper 패키지에는 ReplyMapper 인터페이스를 처리하고, XML 파일 역시 생성해 준다.

예제) ReplyMapper 인터페이스 생성
package org.zerock.mapper;

import java.util.List;

import org.apache.ibatis.annotations.Param;
import org.zerock.domain.Criteria;
import org.zerock.domain.ReplyVO;

public interface ReplyMapper {
	
	
}

댓글에 대한 처리 역시 화면상에서 페이지 처리가 필요할 수 있으므로 Criteria를 이용해서 처리하도록 한다.
실제 SQL은 'src/main/resources' 폴더 아래 ReplyMapper.xml 파일을 작성해서 처리한다.

XML에서는 tbl_reply 테이블에 필요한 SQL을 작성한다. 페이징 처리에서는 조금 더 신경 써야 하는 내용이 있으므로 우선은 특정 게시물 번호(bno)에 해당하는 
모든 댓글을 가져오는 형태로 작성한다.

XML을 작성할 때에는 항상 namaspace에 주의해서 작성한다.

예제)ReplyMapper.xml 생성
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 <mapper namespace="org.zerock.mapper.ReplyMapper">
 
 </mapper>

★ CRUD 작업을 테스트하기 전에 tbl_reply 테이블이 tbl_board 테이블과 FK(외래키)의 관계로 처리되어 있다는 점을 기억해야한다.

tbl_reply가 tbl_board 테이블의 bno 값과 정확히 일치해야 하므로 테스트를 진행하기 전에 최신 bno 번호 몇 개를 예제로 확인해 두도록 한다.
```
select * from tbl_board where rownum < 10 order by bno desc;
```

ReplyMapper 테스트

개발 초기에는 테스트 코드를 작성하는 것이 번거롭게 느껴지지만 가능하면 팀 전체가 테스트 코드를 습관적으로 작성하는 노력을 해야한다.
우선 ReplyMapper를 사용 가능 한지에 대한 테스트 작업을 진행한다.
테스트를 위해서는 ReplyMapperTests 클래스를 작성해 두도록한다.

예제) ReplyMapperTests 클래스 생성
package org.zerock.mapper;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;
import org.zerock.domain.Criteria;
import org.zerock.domain.ReplyVO;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringRunner.class)
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
// Java Config
// @ContextConfiguration(classes = { org.zerock.config.RootConfig.class})
@Log4j
public class ReplyMapperTests {

	
	@Setter(onMethod_ = @Autowired)
	private ReplyMapper mapper;
	
	
	@Test
	public void testMapper() {
		log.info(mapper);
	}

}


testMapper()를 통해서 ReplyMapper 타입의 객체가 정상적으로 사용이 가능한지 확인한다.

정상 출력
INFO : org.zerock.mapper.ReplyMapperTests - org.apache.ibatis.binding.MapperProxy@7966baa7
INFO : org.springframework.context.support.GenericApplicationContext 
- Closing org.springframework.context.support.GenericApplicationContext@458c1321: 
startup date [Wed Oct 11 15:43:48 KST 2023]; root of context hierarchy
INFO : com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...


CRUD 작업
ReplyMapper를 이용한 CRUD 작업은 단일 테이블에 대한 작업과 유사하므로
등록, 수정, 삭제, 조회 작업을 처리한다.


- 등록
우선은 외래키를 사용하는 등록 작업을 먼저 진행해 봅니다.

예제) ReplyMapper 인터페이스 insert()
package org.zerock.mapper;

import org.zerock.domain.ReplyVO;

public interface ReplyMapper {
	
	// 댓글 등록
	public int  insert(ReplyVO vo);
	
}


ReplyMapper의 SQL을 처리하는 XML의 내용은 다음과 같다

예제) ReplyMapper.xml insert 추가

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 <mapper namespace="org.zerock.mapper.ReplyMapper">
 
 	<insert id="insert">
 	
 		insert into tbl_reply (rno, bno, reply, replyer)
 		values (seq_reply.nextval, #{bno}, #{reply}, #{replyer})

 	</insert>
 
 </mapper>

테스트 코드는 기존에 존재하는 게시물의 일부의 bno(게시물 번호)를 사용해서 ReplyVO를 작성한다.

예제) ReplyMapperTests 클래스 test 메소드 추가
package org.zerock.mapper;

import static org.junit.Assert.*;

import ...생략...

@RunWith(SpringRunner.class)
@ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
// Java Config
// @ContextConfiguration(classes = { org.zerock.config.RootConfig.class})
@Log4j
public class ReplyMapperTests {

	// 테스트 전에 해당 번호의 게시물이 존재하는지 반드시 확인할 것
	private Long[] bnoArr = {11534347L, 11534346L, 11534345L, 11534344L, 11534342L};
	
	@Setter(onMethod_ = @Autowired)
	private ReplyMapper mapper;
	
	// 댓글등록 테스트
	@Test
	public void testCreate() {
		
		IntStream.rangeClosed(1, 10).forEach(i -> {
			
			ReplyVO vo = new ReplyVO();
			
			// 게시물의 번호
			vo.setBno(bnoArr[i % 5]);
			vo.setReply("댓글 테스트 " + i);
			vo.setReplyer("replyer " + i);
			
			mapper.insert(vo);
		});
	}
	
	@Test
	public void testMapper() {
		log.info(mapper);
	}

}


★ ReplyMapperTests 내부의 bnoArr은 게시물 번호의 일부로 실제 데이터베이스에 있는 번호여야만 한다.(PK와 FK의 관계로 묶여 있기 때문에).

테스트가 정상적으로 실행되는지 최종적으로 데이터베이스의 tbl_reply의 상태를 확인한다.

``` 
select * from tbl_reply order by rno desc;

등록 작업이 온전히 처리되는 것을 확인한 후에 조회 작업을 처리한다.

- 조회

ReplyMapepr 인터페이스와 ReplyMapper.xml에 조회 처리를 추가한다.

예제) ReplyMapper 인터페이스 read() 
package org.zerock.mapper;

import org.zerock.domain.ReplyVO;

public interface ReplyMapper {
	
	// 댓글 등록
	public int  insert(ReplyVO vo);

	// 댓글 조회
	public ReplyVO read(Long rno); // 특정 댓글 읽기
	
}

예제) ReplyMapper.xml select 추가
	<select id="read" resultType="org.zerock.domain.ReplyVO">
 	
 		select * from tbl_reply where rno = #{rno}
 		
 	</select>

테스트 코드는 tbl_reply에 있는 번호 중에서 하나를 이용해서 확인한다.

예제) ReplyMapperTests 클래스 testRead()메서드 추가

	// 특정 댓글 조회
	@Test
	public void testRead() {
		
		Long targetRno = 5L;
		
		ReplyVO vo = mapper.read(targetRno);
		
		log.info(vo);
	}

테스트 결과로 5번 댓글이 정상적으로 조회되는지 확인한다.
INFO : org.zerock.mapper.ReplyMapperTests - ReplyVO(rno=5, bno=11534342, 
reply=댓글 테스트 4, replyer=replyer 4, replyDate=Tue Oct 10 10:18:32 KST 2023, updateDate=Tue Oct 10 10:18:32 KST 2023)


- 삭제(delete)

특정 댓글의 삭제는 댓글의 번호(rno)만으로 처리가 가능하다.(외래키FK)

예제) ReplyMapper 인터페이스  delete 추가
package org.zerock.mapper;

import org.zerock.domain.ReplyVO;

public interface ReplyMapper {
	
	// 댓글 등록
	public int  insert(ReplyVO vo);

	// 댓글 조회
	public ReplyVO read(Long rno); // 특정 댓글 읽기

	// 댓글 삭제
	public int delete (Long rno);
	
}

예제) ReplyMapper.xml delete 추가

 	<delete id="delete">
 	
 		delete from tbl_reply where rno = #{rno}
 	
 	</delete>

예제) ReplyMapperTests 클래스의 일부

	// 댓글 삭제
	@Test
	public void testDelete() {
		
		Long targetRno = 2L;
		
		mapper.delete(targetRno);
		
	}

- 수정

댓글의 수정은 현재의 tbl_reply 테이블의 구조에서는 댓글의 내용(reply)과 최종 수정 시간(updatedate)을 수정한다.

예제) ReplyMapper 인터페이스 update() 추가

package org.zerock.mapper;

import org.zerock.domain.ReplyVO;

public interface ReplyMapper {
	
	// 댓글 등록
	public int  insert(ReplyVO vo);

	// 댓글 조회
	public ReplyVO read(Long rno); // 특정 댓글 읽기

	// 댓글 삭제
	public int delete (Long rno);

	// 댓글 수정
	public int update(ReplyVO reply);
	
}

예제) ReplyMapper.xml update 추가

 	<update id="update">
 	
 		update tbl_reply set reply = #{reply}, updatedate = sysdate where rno = #{rno}
 	
 	</update>

예제) ReplyMapperTests 클래스 testUpdate() 메서드 추가
	@Test
	public void testUpdate() {
		
		Long targetRno = 10L;
		
		ReplyVO vo = mapper.read(targetRno);
		
		vo.setReply("Update Reply ");
		
		int count = mapper.update(vo);
		
		log.info("UPDATE COUNT: " + count);
	}


@Param 어노테이션과 댓글 목록

댓글의 목록과 페이징 처리는 기존의 게시물 페이징 처리와 유사하지만, 
추가적으로 특정한 게시물의 댓글만을 대상으로 하기 때문에 추가로 게시물의 번호가 필요하게 된다.

MyBatis는 두 개 이상이 데이터를 파라미터로 전달하기 위해서는
1) 별도의 객체로 구성하거나
2) Map을 이용하는 방식
3) @Param을 이용해서 이름을 사용하는 방식이다.

여러 방식 중에 가장 간단하게 사용할 수 있는 방식이 @Param을 이용하는 방식이다.
@Param의 속성값은 MyBatis에서 SQL을 이용할 때 '#{}'의 이름으로 사용이 가능하다.

페이징 처리는 기존과 동일하게 Criteria를 이용한다.
여기에 추가적으로 해당 게시물의 번호는 파라미터를 전달하도록 ReplyMapper를 구성한다.

예제) ReplyMApper 인터페이스 추가 getListWithPaging() 메서드 추가

package org.zerock.mapper;

import java.util.List;

import org.apache.ibatis.annotations.Param;
import org.zerock.domain.Criteria;
import org.zerock.domain.ReplyVO;

public interface ReplyMapper {
	
	// 댓글 등록
	public int  insert(ReplyVO vo);
	
	// 댓글 조회
	public ReplyVO read(Long rno); // 특정 댓글 읽기
	
	// 댓글 삭제
	public int delete (Long rno);
	
	// 댓글 수정
	public int update(ReplyVO reply);
	
	// 게시물 댓글 목록 
	// @Param의 속성값은 MyBatis에서 SQL을 이용할 때 '#{}'의 이름으로 사용이 가능하다.
	// 페이징 처리는 기존과 동일하게 Criteria를 이용
	// 여기서 추가적으로 번호는 파라미터를 전달하도록 ReplyMapper를 구성한다.
	public List<ReplyVO> getListWithPaging(
			@Param("cri") Criteria cri,
			@Param("bno") Long bno);
}

XML로 처리할 때에는 지정된 'cri'와 'bno'를 모두 사용할 수 있다.

댓글도 페이징 처리를 해 줄 수 있는데, 조금 뒤쪽에서 이것을 처리하고 지금은 특정 게시물의 댓글을 가져오는 것을 작성한다.

예제) ReplyMapper.xml
 	<select id="getListWithPaging" resultType="org.zerock.domain.ReplyVO">
 	
 		select rno, bno, reply, replyer, replyDate, updatedate
 		from tbl_reply
 		where bno = #{bno}
 		order by rno asc
 	
 	</select>

XML에서 '#{bno}'가 @Param("bno")와 매칭되어서 사용되는 점에 주목해야 한다.

테스트 코드에서는 현재 데이터베이스에 추가되어 있는 댓글들의 게시물 번호로 확인한다.

예제) ReplyMapperTests testList()메서드 추가

	@Test
	public void testList() {
		
		Criteria cri = new Criteria();
		
		// 11534347L
		List<ReplyVO> replies = mapper.getListWithPaging(cri, bnoArr[0]);
		
		replies.forEach(reply -> log.info(reply));
	}


서비스 영역과 Controller 처리

서비스 영역과 Controller의 처리는 기존의 BaordService와 동일하게 ReplySevice인터페이스와 ReplyServiceImpl 클래스를 작성
--> Controller에서 url 호출만 하면 알아서 비즈니스 로직에서 db와 연동하여 하겠끔 도와줌

예제) ReplyService 인터페이스 생성

package org.zerock.service;

import java.util.List;

import org.zerock.domain.Criteria;
import org.zerock.domain.ReplyVO;

public interface ReplyService {
	
	public int register(ReplyVO vo);
	
	public ReplyVO get(Long rno);
	
	public int modify(ReplyVO vo);
	
	public int remove(Long rno);
	
	public List<ReplyVO> getList(Criteria cri, Long bno);
}

ReplyService를 구현하는 ReplyServiceImple 클래스에는 @Service 어노테이션과 @Log4j를 적용
--> @Service 어노테이션은 rootContext.xml에서 bean객체로 그 경로에 있는 모든 @Service가 명시되어 있는 클래스 파일을 읽는다.

예제) ReplyService인터페이스를 구현하는 ReplyServiceImpl 구현 클래스 생성

package org.zerock.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.zerock.domain.Criteria;
import org.zerock.domain.ReplyVO;
import org.zerock.mapper.ReplyMapper;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

/*
 * 스프링 4.3을 이용하는 경우 ReplyServiceImpl
 * @Service
 * @Log4j
 * @AllArgsContructor
 * public class ReplyServiceImpl implements ReplyService{
 * 
 * 	private ReplyMapper mapper;
 * }
 * */

@Service
@Log4j
public class ReplyServiceImpl implements ReplyService {

	@Setter(onMethod_ = @Autowired)
	private ReplyMapper mapper;

	@Override
	public int register(ReplyVO vo) {
		
		log.info("register........ " + vo);
		
		return mapper.insert(vo);
	}

	@Override
	public ReplyVO get(Long rno) {
		
		log.info("get........... " + rno);
		
		return mapper.read(rno);
	}

	@Override
	public int modify(ReplyVO vo) {
		
		log.info("modify.......... " + vo);
		
		return mapper.update(vo);
	}

	@Override
	public int remove(Long rno) {
		
		log.info("delete........ " + rno);
		
		return mapper.delete(rno);
		
	}

	@Override
	public List<ReplyVO> getList(Criteria cri, Long bno) {
		
		log.info("get Reply List of a Board " + bno);
		
		return mapper.getListWithPaging(cri, bno);
	}
	
	
}


ReplyServiceImpl은 ReplyMapper에 의존적인 관계이기 때문에 위의 코드와 같이
@Setter를 이용해서 처리하거나 스프링 4.3의 생성자와 자동주입을 이용해서 아래와 같이 처리할 수 있다.

예제) 스프링 4.3 을 이용하는 경우
@Service
@Log4j
@AllArgsContstructor
public class ReplyServiceImpl Implements ReplyService{

	private ReplyMapper mapper;
}


ReplyController의 설계

ReplyController는 앞의 예제에서 SampleController와 유사하게 @RestController어노테이션을 이용해서 설계하며 다음과 같은 URL을 기준으로 작동할 수 있게 작성한다.

작업	URL				HTTP 전송방식
등록	/replies/new			POST
조회	/replies/:rno			GET
삭제	/replies/:rno			DELETE
수정	/replies/:rno			PUT or PATCH
페이지	/replies/pages/:bno/:page	GET

REST 방식으로 동작하는 URL을 설계할 때는 PK를 기준으로 작성하는 것이 좋다.
PK만으로 조회, 수정, 삭제가 가능하기 때문이다. 
다만 댓글의 목록은 PK를 사용할 수 없기 때문에 파라미터로 필요한 게시물의 번호(bno)와 페이지 번호(page) 정보들을 URL에서 표현하는 방식을 사용한다.

ReplyController는 ReplyService 타입의 객체인 ReplyServiceImpl 객체를 주입받도록 설계한다.

예제)  ReplyController 생성

package org.zerock.controller;

import java.util.List;
.. 생략

/*
 * @Setter 주입을 이용하거나 위의 코드와 같이 @AllArgsContstructor를 이용해서
 * ReplyService 타입의 객체를 필요로 하는 생성자를 만들어서 사용한다.
 * (스프링 4.3이상)*/

@RequestMapping("/replies/")
@RestController
@Log4j
@AllArgsConstructor
public class ReplyController {
	
	private ReplyService service;

}


등록 작업과 테스트
REST 방식으로 처리할 때 주의해야 하는 점은 브라우저나 외부에서 서버를 호출할 때 데이터의 포맷과 서버에서 보내주는 데이터의 타입을 명확히 설계해야 하는 것이다.
예를 들어 댓글 등록의 경우 브라우저에서는 JSON 타입으로 된 댓글 데이터를 전송하고, 서버에서는 댓글의 처리 결과가 정상적으로 되었는지 문자열로 결과를 알려 주도록 한다.

예제) ReplyController에 insert하는 create() 메소드 추가 
	

	// insert
	@PostMapping(value = "new",
			consumes = "application/json", //--> Client가 Server에게 보내는 데이터 타입명시
			produces = {MediaType.TEXT_PLAIN_VALUE}) // --> Server가 Client에게 반환하는 데이터 타입 명시
	public ResponseEntity<String> create(@RequestBody ReplyVO vo){
		
		log.info("ReplyVO: " + vo);
		
		int insertCount = service.register(vo);
		
		log.info("Reply INSERT COUNT : " + insertCount);
		
		return insertCount == 1
				? new ResponseEntity<>("success", HttpStatus.OK)
				: new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
				// 삼항 연산자 처리
	}

create()는 @PostMapping으로 POST 방식으로만 동작하도록 설계하고, consumes와 produces를 이용해서 JSON 방식의 데이터만 처리하도록 하고, 문자열을 반환하도록 설계한다.
create()의 파라미터는 @RequestBody를 적용해서 JSON 데이터를 ReplyVO 타입으로 변환하도록 지정한다.

create()는 내부적으로 ReplyServiceImpl을 호출해서 register()를 호출하고, 댓글이 추가된 숫자를 확인해서 브라우저에서
'200 OK' 혹은 '500 Internal Server Error'를 반환하도록 한다.
테스트를 위해서 프로젝트를 '/'경로로 실행하고, 크롬 확장 프로그램 등을 이용해서 테스트를 진행할 수 있다.

테스트 시에는 POST 방식으로 전송하고, 'Content-Type'은 'application/json, charset=utf-8'으로 지정해야한다.
실제 전송되는 데이터는 존재하는 게시물 번호(bno)와 댓글 내용(reply), 댓글 작성자(replyer)를 JSON 문법에 맞게 작성하도록 주의한다.
게시물의 번호는 기존에 존재하는 번호이어야 하므로 주의가 필요하다.

chrome-extension://ehafadccdcdedbhcbddihehiodgcddpl/index.html (chrome 확장 프로그램 개발자 도구 툴)
여기에 Body text 입력하는 곳에 {"bno":11534347,"reply":"Hello Reply", "replyer":"Park"} 작성

작성된 댓글은 데이터베이스에 정상적으로 추가되었는지 확인한다. 


특정 게시물의 댓글 목록 확인 
예제) ReplyController에 특정 게시물의 댓글 목록 확인 하는 getList() 메소드 추가
	// 특정게시물 댓글목록 확인
	@GetMapping(value = "pages/{bno}/{page}",
			produces = {
					MediaType.APPLICATION_XML_VALUE,
					MediaType.APPLICATION_JSON_UTF8_VALUE})
	public ResponseEntity<List<ReplyVO>> getList(
			@PathVariable("page") int page,
			@PathVariable("bno") Long bno){
		
		log.info("getList........ ");
		Criteria cri = new Criteria(page,10);
		
		log.info(cri);
		
		return new ResponseEntity<List<ReplyVO>>(service.getList(cri, bno), HttpStatus.OK);
	}

ReplyController의 getList()는 Criteria를 이용해서 파라미터를 수집하는데,
'/{bno}/{page}'의 'page'값은 Criteria를 생성해서 직접 처리해야한다.
게시물의 번호는 @PathVariable을 이용해서 파라미터로 처리하고 브라우저에서 아래와 같이 테스트 해본다.

http://localhost:8081/replies/pages/11534347/1

테스트 결과는 XML 타입으로 댓글 데이터들이 나오는 것을 확인할 수 있다.
만일 JSON 타입을 원한다면 마지막에'.json'을 추가하면 된다.

댓글 삭제/ 조회

ReplyController의 댓글의 수정/삭제/조회는 위와 유사한 방식으로 JSON이나 문자열을 반환하도록 설계한다.

예제)ReplyController 삭제/조회하는 get()메소드와 remove() 메소드
	// 조회
	@GetMapping(value = "/{rno}",
			produces = {MediaType.APPLICATION_XML_VALUE,
						MediaType.APPLICATION_JSON_UTF8_VALUE})
	public ResponseEntity<ReplyVO> get(@PathVariable("rno") Long rno){
		
		log.info("get : " + rno);
		
		return new ResponseEntity<ReplyVO>(service.get(rno), HttpStatus.OK);
	}
	// 삭제
	@DeleteMapping(value = "/{rno}", produces = {MediaType.TEXT_PLAIN_VALUE})
	public ResponseEntity<String> remove(@PathVariable("rno") Long rno){
		
		log.info("remove: "+ rno);
		
		return service.remove(rno) == 1
			? new ResponseEntity<String>("success", HttpStatus.OK)
			: new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}


댓글 수정

댓글 수정은 JSON 형태로 전달되는 데이터와 파라미터로 전달되는 댓글 번호(rno)를 처리하기 때문에 아래와 같이 처리한다.
예제) ReplyController 수정을 하는 modify()메서드 추가
	// 수정
	@RequestMapping(method = {RequestMethod.PUT, RequestMethod.PATCH},
			value = "/{rno}",
			consumes = "application/json",
			produces = {MediaType.TEXT_PLAIN_VALUE})
	public ResponseEntity<String> modify(
			@RequestBody ReplyVO vo,
			@PathVariable("rno") Long rno){
		
		vo.setRno(rno);
		
		log.info("rno : " + rno);
		log.info("modify : " + vo);
		
		return service.modify(vo) == 1
			?	new ResponseEntity<String>	("success", HttpStatus.OK)
			:   new	ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}

댓글 수정은 'PUT'방식이나 'PATCH'방식을 이용하도록 처리하고, 실제 수정되는 데이터는 JSON 포맷이므로 @RequestBody를 이용해서 처리한다.
@RequestBody로 처리되는 데이터는 일반 파라미터나 @PathVariable 파라미터를 처리할 수 없기 때문에 직접 처리해 주는 부분을 주의해야 한다.
 
chrome-extension://ehafadccdcdedbhcbddihehiodgcddpl/index.html (chrome 확장 프로그램 개발자 도구 툴)
여기에 Body text 입력하는 곳에 {"bno":11534347,"reply":"댓글을 수정합니다.", "replyer":"Park2"} 작성


JavaScript 준비

JSP 내에서 댓글에 대한 처리는 하나의 페이지 내에서 모든 작업이 이루어지기 때문에 조금 복잡하게 느껴지는 것이 사실이다.
또한 기존과 달리 JavaScript와 동적으로 만들어지는 HTML로 처리하기 때문에 각 단계를 주의해서 작성해야 한다.

JavaScript의 모듈화

화면에서 사용되는 jQuery는 막강한 기능과 다양한 플러그인을 통해서 많은 프로젝트에서 기본으로 사용된다. 
특히 Ajax를 이용하는 경우에는 jQuert의 함수를 이용해서 너무나 쉽게 처리할 수 있기 때문에 많이 사용한다.
화면 내에서 JavaScript 처리를 하다 보면 어느 순간 이벤트 처리와 DOM, Ajax, 처리 등이 마구 섞여서 유지보수 하기 힘든 코드를 만드는 경우가 많다.
이런 경우를 대비해서 좀 더 JavaScript를 하나의 모듈처럼 구성하는 방식을 이용하는 것이 좋다.
JavaSctipt에서 가장 많이 사용하는 패턴 중 하나는 모듈 패턴이다. 
모듈 패턴은 쉽게 말해서 관련 있는 함수들을 하나의 모듈처럼 묶음으로 구성하는 것을 의미한다.
JavaSctript의 클러저를 이용하는 가장 대표적인 방법이다.

wepapp 내 resorces폴더에 js 폴더 내 reply.js 파일을 작성한다.

예제) reply.js 생성




console.log("Reply Module.......");

var replyService = {}

reply.js 파일은 게시물의 조회 페이지에서 사용하기 위해서 작성된 것이므로, view/baord/get.jsp 파일에 추가한다.

예제) get.jsp에 reply.js 등록

<script type="text/javascript" src="/resources/js/reply.js"></script>

reply.js가 정상적으로 동작하는지를 확인하기 위해서 브라우저에서 'board/get?bno=xxx'번호를 호출하면 reply.js가 실행되는지를 확인한다.
(개발자 도구에서 네트워크란에 호출하는 파일들중 reply.js가 호출됐는지 확인)
브라우저에서는 개발자 도구를 이용해서 reply.js가 아무 문제 없이 로딩되고 있는지 확인해야하고,
Console메뉴에서는 console.log()의 내용이 실행되는지를 확인해야 한다.

모듈 구성하기(함수 집합/모음)
모듈 패턴은 쉽게 말해서 Java의 클래스처럼 JavaScript를 이용해서 메서드를 가지는 객체를 구성한다.
모듈 패턴은 JavaScript의 즉시 실행함수와 '{}'를 이용해서 객체를 구성한다.

예제) reply.js 수정 


console.log("Reply Module.......");

var replyService = (function(){

	return {name : "AAAA"};
	
})();

JavaScript의 즉시 실행함수는 ()안에 함수를 선언하고 바깥쪽에서 실행해 버린다.
즉시 실행함수는 함수의 실행 결과가 바깥쪽에 선언된 변수에 할당된다.
위의 코드에서는 replyService라는 변수에 name이라는 속성에'AAAA'라는 속성값을 가진 객체가 할당된다.

replyService의 확인은 reply.js를 사용하는 get.jsp를 이용해서 확인한다.
$(document).ready(function () {
//p.401
console.log(replyService);
}
jQuery의 $(document).ready()는 한 페이지 내에서 여러 번 나와도 상관없기 때문에 기존의 JavaScript 코드를 수정하지 않으려면 위와 같이 별도의 태그로 분리해도 무방하다.

개발자 ㄱ도구에서는 ReplyService 객체가 정상적으로 표시되어야 한다.


reply.js 등록 처리
모듈 패턴은 즉시 실행하는 함수 내부에서 필요한 메서드를 구성해서 객체를 구성하는 방식이다.

예제) reply.js
var replyService = (function(){

	function add(reply, callback){
		console.log("reply...........");
	}
	
	return {add:add};
	
})();

개발자 도구에서는 replyService 객체의 내부에는 add라는 메서드가 존재하는 형태로 보이게 된다.
외부에서는 replyService.add(객체,콜백)를 전달하는 형태로 호출할 수 있는데, Ajax 호출은 감쳐져 있게 때문에 코드를 좀 더 깔끔하게 작성할 수 있다.

reply.js내에 Add 함수는 Ajax를 이용해서 POST 방식으로 호출하는 코드를 작성한다.

예제) reply.js Ajax를 이용하여 add함수를 POST 방식으로 호출

var replyService = (function(){
	// p.403
	function add(reply, callback){
		console.log("reply...........");
		
		$.ajax({
		type : 'post',
		url : '/replies/new',
		data : JSON.stringify(reply),
		contentType : "application/json; charset=utf-8",
		success : function(result, status, xhr){
			if(callback){
				callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
				error(er);
				}
			}
		})
	
	}

	return {
		add:add
		};
})();

add()에서 주의 깊에 봐야하는 부분은 데이터 전송 타입이 'application/json:charset=utf-8' 방식으로 전송하는 점과 파라미터로 callback과 error를 함수로 받을 것이라는 점이다.
만일 Ajax 호출이 성공하고, callback 값으로 적절한 함수가 존재한다면 해당 함수를 호출해서 결과를 반영하는 방식이다.

JavaScript는 특이하게도 함수의 파라미터 개수를 일치시킬 필요가 없기 때문에 callback이나 error와 같은 파라미터는 필요에 따라서 작성할 수 있다.
reply.js를 이용하는 get.jsp에서는 테스트를 위해 replyService.add()를 호출해 보낟.

예제) board/get.jsp replyService.add() 호출

	
		console.log(replyService);
		
		console.log("=====================");
		console.log("JS TEST");
		
		var bnoValue = '<c:out value="${board.bno}"/>';
	
		// for replyService add test
		replyService.add(
			{reply:"JS Test GETLIST", replyer:"tester", bno:bnoValue}
			,
			function(result){
				alert("RESULT: " + result);
			}
		);

get.jsp 내부에서는 Ajax 호출은 replyService라는 이름의 객체에 감쳐줘 있으므로 필요한 파라미터들만 전달하는 형태로 간결해 진다.
replyService의 add()에 던져야 하는 파라미터는 JavaScript의 객체 타입으로 만들어서 전송해 주고, Ajax 전송 결과를 처리하는 함수를 파라미터로 같이 전달한다.

프로젝트를 Tomcat에서 실행하고 결과를 확인해 보면 데이터베이스에는 정상적으로 댓글이 추가되어야 하고, 브라우저에서는 경고창이 보여야만 한다.

브라우저에서는 JSON형태로 데이터가 전송되고 있는 것을 확인할 수 있어야 하고, 전송되는 데이터 역시 JSON 형태로 전송되는지 확인해야 한다.

서버에서는 JSON 데이터가 ReplyVO타입으로 제대로 변환되는 것을 볼 수 있다.


댓글의 목록 처리
댓글 등록이 정상적으로 처리되었다면 다음 단계에서는 해당 게시물에 있는 댓글의 전체 목록을 가져온다.
댓글 목록은 최종적으로는 페이징 처리가 되어야 하지만, 우선적으로는 전체 댓글을 가져오는 형태로 구현해 본다.

프로젝트가 Tomcat 상에서 실행되고 있다면 '/replies/pages/게시물번호/페이지번호.xml' 혹은 
'/replies/pages/게시물번호/페이지번호.json'형태로 데이터를 먼저 확인할 수있다.

getJSON() 사용
replies/js에서는 Ajax 호출을 담당하므로, jQuery의 getJSON()을 이용해서 처리할 수 있다.
-getJSNO(url,callback)
1) 자바에서 static 메서드와 유사--> jQuery에서는 전역메서드라 불린다.

2) 첫번째 매개변수로 JSON 파일을 로드한다. 

3) 두번째 매개변수(콜백함수)에서 JSON 파일을 이용하여 로드된 데이터를 처리한다. 콜백함수는 로드된 데이터를 인자로 넘겨받는다.(JSON 데이터를 참조하기 위해 data 변수를 사용하고 있다.)

예제) reply.js getList() 메서드 추가 Ajax에 getJSON() 사용

console.log("Reply Module.......");


var replyService = (function(){
	// p.403
	function add(reply, callback){
		console.log("reply...........");
		
		$.ajax({
		type : 'post',
		url : '/replies/new',
		data : JSON.stringify(reply),
		contentType : "application/json; charset=utf-8",
		success : function(result, status, xhr){
			if(callback){
				callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
				error(er);
				}
			}
		})
	
	}
	
	function getList(param, callback, error){
		
		var bno = param.bno;
		var page = param.page || 1;
		
			$.getJSON("/replies/pages/" + bno + "/" + page + ".json",
				function(data){
					if(callback){
						callback(data);
					}
				}).fail(function(xhr, status, err){
				if(error){
					error();
					}
			});
	
	}
	
	
	return {
		add:add,
		getList : getList
		};
	
})();


getList()는 param이라는 객체를 통해서 필요한 파라미터를 전달받아 JSON 목록을 호출한다.
JSON 형태가 필요하므로 URL 호출 시 확장자를 '.json'으로 요구한다.

댓글 등록과 마찬가지로 get.jsp에서는 해당 게시물의 모든 댓글을 가져오는지 확인하는 코드를 작성한다.

예제) get.jsp에 replyService.getList() 호출

		// reply List test
		replyService.getList({bno:bnoValue, page:1}, function(list){
			console.log("getJson으로 부터 받은 Data === " + list + " list.length === " + list.length);
			for (var i = 0, len = list.length||0; i < len; i++) {
				console.log(list[i]);
			}
		}
		);

댓글 삭제와 갱신
댓글 삭제는 DELETE 방식을 통해서 해당 URL을 호출하는 것뿐이므로 그다지 어려운 점은 없다.
reply.js에서 remove()라는 함수를 아래와 같이 추가한다.
예제) reply.js에 remove() 함수 추가

console.log("Reply Module.......");


var replyService = (function(){
	// p.403
	function add(reply, callback){
		console.log("reply...........");
		
		$.ajax({
		type : 'post',
		url : '/replies/new',
		data : JSON.stringify(reply),
		contentType : "application/json; charset=utf-8",
		success : function(result, status, xhr){
			if(callback){
				callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
				error(er);
				}
			}
		})
	
	}
	
	function getList(param, callback, error){
		
		var bno = param.bno;
		var page = param.page || 1;
		
			$.getJSON("/replies/pages/" + bno + "/" + page + ".json",
				function(data){
					if(callback){
						callback(data);
					}
				}).fail(function(xhr, status, err){
				if(error){
					error();
					}
			});
	
	}
	
	function remove(rno, callback, error){
		$.ajax({
			type : 'delete',
			url : '/replies/' + rno,
			success : function(deleteResult, status, xhr){
				if(callback){
					callback(deleteResult);
				}
			},
			error : function(xhr, status, er){
				if(error){
					error(er);
				}
			}
		});
	}

	
	
	return {
		add:add,
		getList : getList,
		remove : remove
		};
	
})();

remove()는 DELETE방식으로 데이터를 전달하므로, $.ajax()를 이용해서 구체적으로 type 속성으로 'delete'를 지정한다.
board/get.jsp에서는 반드시 실제 데이터베이스에 있는 댓글 번호를 이용해서 정상적으로 댓글이 삭제되는지를 확인한다.

예제) get.jsp rplyService.remove() 호출
		// 22번 댓글 삭제 테스트
		replyService.remove(22, function(count){
			
			console.log(count);
			
			if (count === "success") {
				alert("REMOVED");
			}
		}, function (err) {
				alert("ERROR...");
		});

위의 코드에서는 23번 댓글이 존재한다면 이를 삭제하도록 한다.
삭제 전의 데이터베이스와 삭제 후의 데이터베이스를 비교해서 확인한다.

댓글 수정
댓글 수정은 수정하는 내용과 함께 댓글의 번호를 전송한다.
댓글의 내용은 JSON 형태로 전송하기 때문에 댓글 등록과 유사한 부분이 많다.

예제)reply.js에 update()메소드 추가
console.log("Reply Module.......");


var replyService = (function(){
	// p.403
	function add(reply, callback){
		console.log("reply...........");
		
		$.ajax({
		type : 'post',
		url : '/replies/new',
		data : JSON.stringify(reply),
		contentType : "application/json; charset=utf-8",
		success : function(result, status, xhr){
			if(callback){
				callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
				error(er);
				}
			}
		})
	
	}
	
	function getList(param, callback, error){
		
		var bno = param.bno;
		var page = param.page || 1;
		
			$.getJSON("/replies/pages/" + bno + "/" + page + ".json",
				function(data){
					if(callback){
						callback(data);
					}
				}).fail(function(xhr, status, err){
				if(error){
					error();
					}
			});
	
	}
	
	function remove(rno, callback, error){
		$.ajax({
			type : 'delete',
			url : '/replies/' + rno,
			success : function(deleteResult, status, xhr){
				if(callback){
					callback(deleteResult);
				}
			},
			error : function(xhr, status, er){
				if(error){
					error(er);
				}
			}
		});
	}
	// p.410 댓글 수정
	
	function update(reply, callback, error){
		
		console.log("RNO : " + reply.rno);
		
		$.ajax({
			type : 'put',
			url : '/replies/' + reply.rno,
			data : JSON.stringify(reply),
			contentType : "application/json; charset=utf-8",
			success : function(result, status, xhr){
				if(callback){
					callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
					error(er);
				}
			}
		});
	}
	
	
	return {
		add:add,
		getList : getList,
		remove : remove,
		update : update
		};
	
})();


replyService를 이용하는 get.jsp에서는 댓글 번호는 데이터베이스에 존재하는 댓글의 번호를 이용한다. 댓글은 수정하는 내용이 댓글의 내용 밖에 없지만 JavaScript 객체로 처리하는 방식을 이용한다.
예제) get.jsp에 댓글수정 replyService.update

	// 21번 댓글 수정
		replyService.update({
			rno : 21,
			bno : bnoValue,
			reply : "Modified 맞냐?......."
		}, function(result){
			
			alert("수정 완료....");
		
		});


댓글 조회 처리
특정 번호의 댓글 조회는 GET방식으로 동작한다.

예제) reply.js에 get() 추가
console.log("Reply Module.......");


var replyService = (function(){
	// p.403
	function add(reply, callback){
		console.log("reply...........");
		
		$.ajax({
		type : 'post',
		url : '/replies/new',
		data : JSON.stringify(reply),
		contentType : "application/json; charset=utf-8",
		success : function(result, status, xhr){
			if(callback){
				callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
				error(er);
				}
			}
		})
	
	}
	
	function getList(param, callback, error){
		
		var bno = param.bno;
		var page = param.page || 1;
		
			$.getJSON("/replies/pages/" + bno + "/" + page + ".json",
				function(data){
					if(callback){
						callback(data);
					}
				}).fail(function(xhr, status, err){
				if(error){
					error();
					}
			});
	
	}
	
	function remove(rno, callback, error){
		$.ajax({
			type : 'delete',
			url : '/replies/' + rno,
			success : function(deleteResult, status, xhr){
				if(callback){
					callback(deleteResult);
				}
			},
			error : function(xhr, status, er){
				if(error){
					error(er);
				}
			}
		});
	}
	// p.410 댓글 수정
	
	function update(reply, callback, error){
		
		console.log("RNO : " + reply.rno);
		
		$.ajax({
			type : 'put',
			url : '/replies/' + reply.rno,
			data : JSON.stringify(reply),
			contentType : "application/json; charset=utf-8",
			success : function(result, status, xhr){
				if(callback){
					callback(result);
				}
			},
			error : function(xhr, status, er){
				if(error){
					error(er);
				}
			}
		});
	}
	// p.412 댓글 조회 처리
	function get(rno, callback, error){
		$.get("/replies/" + rno +".json", function(result){
			
			if(callback){
				callback(result);
			}
		
		}).fail(function(xhr, status, err){
			if(error){
				error();
			}
		});
	}
	
	
	return {
		add:add,
		getList : getList,
		remove : remove,
		update : update,
		get : get
		};
	
})();


get.jsp엣는 단순히 댓글의 번호만을 전달한다.

예제) get.jsp에 replyService.get 호출
	// get 댓글 조회 처리
		replyService.get(10, function(data){
			console.log(data);
		});


이벤트 처리와 HTML 처리
앞의 과정을 그대로 진행했다면 이미 Ajax의 처리까지는 완료되는 것을 확인했다는 의미가 된다.
남은 작업은 화면에서 버튼 등에서 발생하는 이벤트를 감지하고, Ajax 호출의 결과를 화면에 반영하는 것이다.
※ 조회 페이지가 열리면 댓글을 가져와서 아래쪽에 출력 / 댓글에 대한 처리는 모달창을 이용

댓글 목록 처리
댓글의 목록을 위해서는 별도의 <div>를 생성해서 처리해야 한다. 
게시글과 관련된 화면 아래쪽에 <div>를 추가한다. 추가하는 <div>에는 나중에 화면의 모습을 파악할 수 있도록 간단한 텍스트 등을 구성해 둔다.

예제) board/get.jsp 모달창 추가
 <!-- /.row -->
	 <div class="row">
      	<div class="col-lg-12">
		      <!-- /.panel -->
	          <div class="panel panel-default">
		          <!-- p.419
		            <div class="panel-heading"> 
			              <i class="fa fa-comments fa-fw"></i> Reply
			              </div>		
		           -->
			       <div class="panel-heading"> 
			              <i class="fa fa-comments fa-fw"></i> Reply
			              <button id="addReplyBtn" class="btn btn-primary btn-xs pull-right">
			              New Reply</button>
		           </div>	                    
		              <!-- /.panel-heading -->
		              <div class="panel-body">
		                  
		                  <ul class="chat">
		                  	<!-- start reply -->
		                  	<li class="left clearfix" data-rno='12'>
		                  		<div>
		                  			<div class="header">
		                  				<strong class="primary-font">user00</strong>
		                  				<small class="pull-right text-muted">2018-01-01 13:13</small>
		                  			</div>	
		                  			<p>Good Job!</p>
		                  		</div>
		                  	</li>
		                  </ul>
		                
		            </div>
		            <!-- /end panel-body -->
		        </div>
		        <!-- /end panel -->
	    </div>
		    <!-- /.col-lg-6 -->

	</div>


댓글의 목록은 <ul> 태그 내에 <li> 태그를 이용해서 처리한다.
각 <li> 태그는 하나의 댓글을 의미하므로 수정이나 삭제 시 이를 클릭하게 된다.
수정이나 삭제 시에는 반드시 댓글 번호(rno)가 필요하므로 'data-rno'속성을 이용해서 처리한다.
위의 코드를 추가한 후 브라우저에서는 아래쪽에 댓글의 목록이 보이게 된다.


이벤트 처리 
게시글의 조회 페이지가 열리면 자동으로 댓글 목록을 가져와서 <li> 태그를 구성해야 한다.
이에 대한 처리는 $(document).ready() 내에서 이루어 지도록 한다.

예제) get.jsp script 작성

	$(document).ready(function() {
		var bnoValue = '<c:out value="${board.bno}"/>';
		var replyUL = $(".chat");
		
			showList(1);
			
			function showList(page) { // 댓글 전체 목록을 보여주는 showList()
				replyService.getList({bno:bnoValue, page:1}, function(list){
					
					var str = "";
					if (list == null || list.length == 0) {
						replyUL.html("");
						
						return;
					}
					for (var i = 0, len = list.length||0; i < len; i++) {
						str +="<li class='left clearfix' data-rno='"+ list[i].rno+"'>";
						str +="	<div> <div class='header'><strong class='primary-font'>"
						+list[i].replyer+"</strong>";
						str +="	<small class='pull-right text-muted'>" +list[i].
						replyDate+"</small></div>";
						str +="	<p>" +list[i].reply+"</p></div></li>";
					}
					
					replyUL.html(str);
				}); //end function
			}// end showList

showList()는 페이지 번호를 파라미터로 받도록 설계하고, 만일 파라미터가 없는 경우에는 자동으로 1페이지가 되도록 설정한다.
브라우저에서 DOM 처리가 끝나면 자동으로 showList()가 호출되면서 <ul> 태그 내에 내용으로 처리된다.
만일 1페이지가 아닌 경우라면 기존<ul>에 <li>들이 추가되는 형태이다.
※ DOM(문서 객체 모델)이란 
  DOM은 웹 페이지, 즉 HTML 문서를 계층적 구조와 정보로 표현하며, 이를 제어할 수 있는 프로퍼티와  
   메서드를 제공하는 트리 자료구조이기도 하다. 따라서 HTML DOM, 혹은 HTML DOM Tree로 부르기도 한다.
   트리 자료구조는 노드들의 계층 구조로 이루어져 있다. 계층 구조로 이루어져 있기 때문에 
   부모-자식 관계 - 형제 관계를 표현하는 비선형 자료구조를 나타낸다.
   트리 자료 구조로 구축이 되기 때문에, HTML 문서는 최종적으로 하나의 최상위 노드(root노드)에서 시작해
   자식 노드들을 가지며,아래로만 떧어나가는 구조로 만들어지게 된다.
  DOM은 앞서 프로그래밍 언어가 해당 문서에 접근하여 읽고 조작할 수 있도록 API를 제공하는 일종의 인터페이스라고 설명했습니다. 
   조금 더 부연 설명을 하자면 DOM은 어떤 프로그래밍 언어에 의존하지 않는 독립적인 인터페이스라는 것입니다.


시간에 대한 처리
XML이나 JSON 형태로 데이터를 받을 때는 순수하게 숫자로 표현되는 시간 값이 나오게 되어 있으므로, 
화면에서는 이를 변환해서 사용하는 것이 좋다.
날짜 포맷의 경우 문화권마다 표기 순서 등이 다르기 때문에 화면에서 포맷을 처리하는 방식을 권장한다.

최근의 웹페이지들을 보면 해당일에 해당하는 데이터는 '시/분/초'를 보여주고, 
전날에 등록된 데이터들은 '년/월/일' 등을 보여주는 경우가 많다.
현재 시간을 기준으로 해서 화면에 내용이 달라지도록 하는 부분은 아래와 같이 함수를 작성해서 사용할 수 있다.

예제) reply.js 함수 추가 displayTime() 추가

// p.417 시간 처리 
	function displayTime(timeValue){
		console.log("displayTime 호출 ");
		var today = new Date();
		
		var gap = today.getTime() - timeValue;
		
		var dateObj = new Date(timeValue);
		var str = "";
		
		if(gap < (1000 * 60 * 60 * 24)){
			
			var hh = dateObj.getHours();
			var mm = dateObj.getMinutes();
			var ss = dateObj.getSeconds();
			
			return [ (hh > 9 ? '' : '0') + hh, ':', (mm > 9 ? '' : '0') + mm,
				':', (ss > 9 ? '' : '0') + ss ].join('');
		} else {
			var yy = dateObj.getFullYear();
			var mm = dateObj.getMonth() + 1; // getMonth() is zero-based
			var dd = dateObj.getDate();
			
			return [ yy, '/', (mm > 9 ? '' : '0') + mm, '/',
				(dd > 9 ? '' : '0') + dd ].join('');
		}
	}
	
	return {
		add:add,
		getList : getList,
		remove : remove,
		update : update,
		get : get,
		displayTime : displayTime
	}

displayTime()은 Ajax에서 데이터를 가져와서 HTML을 만들어 주는 부분에 'replyService.displayTime(listp[i].replyDate)'의 형태로 적용하도록 한다.

예제) get.jsp 

for (var i = 0, len = list.length||0; i < len; i++) {
	str +="<li class='left clearfix' data-rno='"+ list[i].rno+"'>";
	str +="	<div> <div class='header'><strong class='primary-font'>"
	+list[i].replyer+"</strong>";
	str +="	<small class='pull-right text-muted'>" + replyService.displayTime(list[i].
	replyDate)+"</small></div>";
	str +="	<p>" +list[i].reply+"</p></div></li>";
}

작성된 displayTime()을 적용하면 24시간이 지난 댓글은 날짜만 표시되고, 24시간 이내의 글은 시간으로 표시된다.

새로운 댓글 처리
댓글 목록 상단에는 버튼을 하나 추가해서 사용자들이 새로운 댓글을 추가할 수 있도록 준비한다.

예제) board/get.jsp 버튼생성 html영역

 	 <!-- /.panel -->
	          <div class="panel panel-default">
		          <!-- p.419
		            <div class="panel-heading"> 
			              <i class="fa fa-comments fa-fw"></i> Reply
			              </div>		
		           -->
			       <div class="panel-heading"> 
			              <i class="fa fa-comments fa-fw"></i> Reply
			              <button id="addReplyBtn" class="btn btn-primary btn-xs pull-right">
			              New Reply</button>
		           </div>

댓글의 추가는 모달창을 이용해서 진행한다. 모달창은 별도로 화면 중앙에 위치하기 때문에 태그를 추가하는 위치는 그다지 신경 쓰지 않아도 된다.
<script> 태그의 시작전에 아래 코드를 추가한다.
(모달창의 코드는 SBAdmin2의 pages 폴더 내 notifications.html 안에 포함되어 있다.)

예제) get.jsp 모달창 태그 추가

	 <!-- Modal -->
      <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
          <div class="modal-dialog">
              <div class="modal-content">
                  <div class="modal-header">
                      <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                      <h4 class="modal-title" id="myModalLabel">REPLY MODAL</h4>
                  </div>
                  <div class="modal-body">
                     <div class="form-group">
                     	<label>Reply</label>
                     	<input class="form-control" name="reply" value="NewReply!!!!">
                     </div>
                     <div class="form-group">
                     	<label>Replyer</label>
                     	<input class="form-control" name="replyer" value="replyer">
                     </div>
                     <div class="form-group">
                     	<label>Reply Date</label>
                     	<input class="form-control" name="replyDate" value="">
                     </div>
                  </div>
                  <div class="modal-footer">
                  	  <button id="modalModBtn" type="button" class="btn btn-warning">Modify</button>
                  	  <button id="modalRemoveBtn" type="button" class="btn btn-danger">Remove</button>
                  	  <button id="modalRegisterBtn" type="button" class="btn btn-danger">Register</button>
                      <button id="modalCloseBtn" type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                      <button id="modalClassBtn" type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                  </div>
              </div>
              <!-- /.modal-content -->
          </div>
          <!-- /.modal-dialog -->
      </div>
      <!-- /.modal -->

모달창은 브라우저에서 댓글에 대한 여러 작업(CRUD)에서 활용할 것이므로 필요한 모든 내용을 담도록 하고 각 작업에 맞게 버튼이나 입력창이 보이거나 감춰지도록 한다.

새로운 댓글의 추가 버튼 이벤트 처리

댓글 목록 상단의 'New Reply'를 클릭하면 화면에서는 모달창을 아래와 같이 처리한다.
모달과 관련된 객체들은 여러 함수에서 사용할 것이므로 바깥쪽으로 빼두어 매번 jQuery를 호출하지 않도록 한다.

예제) get.jsp 내의 댓글 추가 시작 시 버튼 이벤트 처리

$(document).ready(function() {
		var bnoValue = '<c:out value="${board.bno}"/>';
		var replyUL = $(".chat");
		
			showList(1);
			
			function showList(page) {
				replyService.getList({bno:bnoValue, page:1}, function(list){
			
				}
			// 'New Reply'클릭시 새댓글 모달 창 나오는 이벤트 처리
			var modal = $(".modal");
			var modalInputReply = modal.find("input[name='reply']");
			var modalInputReplyer = modal.find("input[name='replyer']");
			var modalInputReplyDate = modal.find("input[name='replyDate']");
			
			var modalModBtn = $("#modalModBtn");
			var modalRemoveBtn = $("#modalRemoveBtn");
			var modalRegisterBtn = $("#modalRegisterBtn");
			
			$("#addReplyBtn").on("click", function (e) {
				
				modal.find("input").val("");
				modalInputReplyDate.closest("div").hide();
				modal.find("button[id != 'modalCloseBtn']").hide();
				
				modalRegisterBtn.show();
				
				$(".modal").modal("show");
			});

사용자가 'New Reply'버튼을 클릭하면 입력에 필요 없는 항목들은 안 보이게 처리하고, 모달창을 보이게 한다.

댓글 등록 및 목록 갱신
새로운 댓글의 추가는 필요한 댓글의 내용(reply)과 댓글의 작성자(replyer) 항목만으로 추가해서 모달창 아래쪽의 'Register' 버튼을 클릭해서 처리한다.

예제) get.jsp 내의 새로운 댓글 추가 처리

	// 댓글 등록 및 목록 갱신
			modalRegisterBtn.on("click", function (e) {
				
				var reply = {
						reply : modalInputReply.val(),
						replyer : modalInputReplyer.val(),
						bno : bnoValue
				};
				
				replyService.add(reply, function (result) {
					
					alert(result);
					
					modal.find("input").val("");
					modal.modal("hide");
				
				});
			});


댓글이 정상적으로 추가되면 경고창을 이용해서 성공했다는 사실을 알려주고, 등록한 내용으로 다시 등록할 수 없도록 입력 항목을 비우고 모달창을 닫아준다.

댓글이 정상적으로 처리되었지만 목록 자체는 갱신된 적이 없으므로 화면에서 새로 등록된 댓글이 보이지 않는다.
이러한 문제 때문에 댓글을 추가한 후에는 다시 댓글의 목록(showList(1))을 갱신할 필요가 있다.

예제) modalRegsiter 클릭이벤트 처리후 showList(1) 댓글목록 갱싱 추가
	modalRegisterBtn.on("click", function (e) {
				
				var reply = {
						reply : modalInputReply.val(),
						replyer : modalInputReplyer.val(),
						bno : bnoValue
				};
				
				replyService.add(reply, function (result) {
					
					alert(result);
					
					modal.find("input").val("");
					modal.modal("hide");
					
					showList(1);
				});
			});

기존의 코드에 showList(1)을 추가해서 댓글이 추가된 후 그 사이에 추가되었을지 모르는 새로운 댓글도 가져오도록 한다.

특정 댓글의 클릭 이벤트 처리
댓글은 댓글의 목록에서 내용이 모두 출력되기 때문에 별도로 클릭한다는 것은 해당 댓글을 수정하거나 삭제하는 경우에 발생한다.
댓글의 수정과 삭제는 원치적으로는 로그인한 사용자가 해당 댓글의 작성자인 경우에만 허락되어야 한다.
다만 현재까지 로그인에 대해서는 처리된 적이 없으므로 코드에서는 어떠한 댓글도 수정/삭제가 되도록 작성한다.

DOM에서 이벤트 리스너를 등록하는 것은 반드시 해당 DOM 요소가 존재해야만 가능하다.
위와 같이 동적으로 Ajax를 통해서 <li> 태그들이 만들어지면 이후에 이벤트를 등록해야 하기 때문에 일반적인 방식이 아니라
'이벤트 위임(delegation)'의 형태로 작성해야 한다.

'이벤트 위임'이 말은 거창하지만 실제로는 이벤트를 동적으로 생성되는 요소가 아닌 이미 존재하는 요소에 이벤트를 걸어주고, 나중에 이벤트의 대상을 변경해주는 방식이다.
jQuery는 on()을 이용해서 쉽게 처리할 수 있다.

예제) get.jsp 댓글 클릭 이벤트 처리
	$(".chat").on("click", "li", function(e){
		
		var rno = $(this).data("rno");
		
		console.log(rno);
	});

jQuery에서 이벤트를 위임하는 방식은 이미 존재하는 DOM 요소에 이벤트를 처리하고 나중에 동적으로 생기는 요소들에 대해서
파라미터 형식을 지정한다.
위의 경우 <ul>태그의 클래스 'chat'을 이용해서 이벤트를 걸고 실제 이벤트의 대상은 <li> 태그가 되도록 한다.

브라우저에서 확인해 보면 이벤트 <ul>에 걸었지만, 각 댓글이 이벤트의 this가 된 것을 확인할 수 있다.
※ jQuery에 on() 함수는 위 같은 코드는 ul 태그 하나에 이벤트를 붙인다. 하지만 하위 li 요소에 대해 이벤트를 지정할 수 있다. 따라서 하나의 이벤트 바인딩으로 깔끔한 처리가 가능한 것이다.

위의 코드가 정상적으로 동작한다면 화면에서는 댓글을 볼 수 있는 모달창을 처리해준다. 
모달창을 브라우저에서 보여주는 코드는 특정한 댓글을 클릭했을 때 보여주도록 한다.

예제) get.jsp 댓글 이벤트 처리
// 특정 댓글의 클릭 이벤트 처리
			$(".chat").on("click","li", function (e) {
				
				var rno = $(this).data("rno");
				
				replyService.get(rno, function (reply) {
					
					modalInputReply.val(reply.reply);
					modalInputReplyer.val(reply.replyer);
					modalInputReplyDate.val(replyService.displayTime(reply.replyDate)).attr("readOnly", "readOnly");
					modal.data("rno", reply.rno);
					
					modal.find("button[id != 'modalCloseBtn']").hide();
					modalModBtn.show();
					modalRemoveBtn.show();
					
					$(".modal").modal("show");
				});
				
				console.log(rno);
			});

댓글을 조회하는 행위는 현재의 경우 모든 내용이 화면에 있기 때문에 별도로 조회할 필요는 없지만, 원치적으로 Ajax로 댓글을 조회한 후
수정/삭제를 하는 것이 정상적이다.
댓글을 가져온 후에는 필요한 항목들을 채우고 수정과 삭제에 필요한 댓글 번호(rno)는 'data-rno' 속성을 만들어서 추가해 둔다.
브라우저에서 특정 댓글을 클릭하면 아래 모습처럼 필요한 내용들만 보이게 된다.

댓글의 수정/삭제 이벤트 처리
댓글의 삭제는 가장 간단하게 결화를 보여주는 작업만을 처리하면 되므로 가장 간단하게 처리할 수 있다.
삭제/수정 작업 모두 작업이 끝난 후에는 다시 댓글 목록을 갱신해야만 한다.

예제)get.jsp 내에서 댓글 수정
	// 댓글의 수정/ 삭제 이벤트 처리
		
		modalModBtn.on("click", function (e) {
		
			var reply = {rno:modal.data("rno"), reply: modalInputReply.val()};
			
			replyService.update(reply, function (result) {
				
				
				alert(result);
				modal.modal("hide");
				showList(1);
			});
		});
		

댓글 삭제 역시 모달창에 있는 'data-rno' 값을 이용해서 처리한다.

예제) get.jsp 내에서 댓글 삭제
		modalRemoveBtn.on("click", function (e) {
		
			var rno = modal.data("rno");
			
			replyService.remove(rno, function (result) {
				
				
				alert(result);
				modal.modal("hide");
				showList(1);
			});
		});


댓글의 페이징 처리
현재까지 작성된 예제는 해당 게시물의 전체 댓글을 가져와서 화면에 출력한다.문제는 댓글의 숫자가 엄청나게 많을 경우이다.
댓글의 숫자가 많다면 데이터베이스에 많은 양의 데이터를 가져와야 하고, 이는 성능상의 문제를 가져올 수 있다.
일반적으로는 이런 문제를 페이징 처리를 이용해서 처리한다.

데이터베이스의 인덱스 설계
댓글에 대해서 우선적으로 고려해야 하는 일은 tbl_reply 테이블을 접근할 때 댓글의 번호(rno)가 중심이 아니라, 
게시물의 번호(bno)가 중심이 된다는 점이다.
댓글을 조회할 때에는 해당 게시물의 댓글을 가져오기 때문에 'tbl_reply where bno = 200 order by rno asc'와 같은 방식으로 접근하게 된다.

tbl_reply 테이블은 pk는 rno이다.
만일 bno값이 100번인 게시물의 댓글들을 보면 PK_REPLY를 이용해서 검색을 하다 보니 중간에 있는 다른 게시물의 번호들은 건너뛰어 가면서 특정 
게시물의 댓글들을 찾아야만 한다.
만일 데이터가 많아진다면 성능에 문제가 생길 수 있다.

효율을 높이고 싶다면 게시물의 번호에 맞게 댓글들을 모아서 빠르게 찾을 수 있는 구조로 만드는 것이 좋다.
'bno=2 order by rno asc' 200에 해당하는 범위만 찾아서 조회(range scan)
==> '인덱스를 생성한다'고 표현한다.

예제) 인덱스 생성 SQL쿼리문
create index idx_reply on tbl_reply (bno desc, rno desc);

인덱스를 이용한 페이징 쿼리
인덱스를 이용하는 이유 중에 하나는 정렬을 피할 수 있기 때문이다.
특정한 게시물의 rno의 순번대로 데이터를 조회하고 싶다면 다음과 같은 쿼리를 작성하게 된다.

예제) rno의 역순
select /*INDEX(tbl_reply idx_reply) */
    ROWNUM rn, bno, rno, reply, replyer, replyDate, updatedate
    from tbl_reply
    where bno ='11534347'
    and rno > 0;

실행된 결과를 보면 'IDX_REPLY'를 이용해서 테이블에 접근하는 것을 볼 수 있다.
테이블에 접근해서 결과를 만들 때 생성되는 ROWNUM은 가장 낮은 rno 값을 가지는 데이터가 1번이 되게 된다.

ROWNUM이 원하는 순서대로 나오기 떄문에 페이징 처리는 이전에 게시물 페이징과 동일한 형태로 작성할 수 있다.

예제) 10개씩 2페이지를 가져오는 쿼리

select rno, bno, reply, replyer, replyDate, updatedate
	(
	select /*INDEX(tbl_reply idx_reply) */
    	ROWNUM rn, bno, rno, reply, replyer, replyDate, updatedate
    	from tbl_reply
    	where bno ='11534347'
	and > 0
    	and rownum <= 20 
	)
	where rn > 10
;

위의 내용을 반영한다면 ReplyMapper.xml에 기재

예제) ReplyMapper.xml 댓글 목록 페이징 처리 쿼리문

 	<select id="getListWithPaging" resultType="org.zerock.domain.ReplyVO">
 	
 		<![CDATA[
 		select rno, bno, reply, replyer, replyDate, updatedate
		from
		    (
		    select /*INDEX(tbl_reply idx_reply) */
		    ROWNUM rn, bno, rno, reply, replyer, replyDate, updatedate
		    from tbl_reply
		    where bno = #{bno}
		    and rno > 0
		    and rownum <= #{cri.pageNum} * #{cri.amount}
		    ) 
		where rn > (#{cri.pageNum} - 1) * #{cri.amount}
 		]]>
 	
 	</select>

ReplyMapper.xml의 페이징 처리가 잘되는지 테스트

예제) ReplyMapperTests.java 페이징 쿼리가 잘 되는지 testList2() 추가

	@Test
	public void testList2() {
		
		Criteria cri = new Criteria(2, 10);
		
		List<ReplyVO> replies = mapper.getListWithPaging(cri, 11534347L);
		
		replies.forEach(reply -> log.info(reply));
	}


댓글의 숫자 파악
댓글들을 페이징 처리하기 위해서는 해당 게시물의 전체 댓글의 숫자를 파악해서 화면에 보여줄 필요가 있다.
ReplyMapper 인터페이스에는 getCountByBno()를 추가한다.

예제) ReplyMapper 인터페이스에 댓글 목록 전체 갯수 구하는 getCountByBno() 추가
	// 댓글의 숫자 파악 
	// 댓글들을 페이징 처리하기 위해서는 해당 게시물의 전체 댓글의 숫자를 파악해서 화면에 보여줄 필요가 있다.
	// ReplyMapper 인터페이스에 getCountByBno()를 추가
	public int getCountByBno(Long bno);

 ReplyMapper.xml에서는 id속성값이 getCountByBno인 <select>를 추가

예제) ReplyMapper.xml 특정 게시물의 댓글 전체 갯수를 조회하는 getCountByBno 쿼리 추가
 	<!-- 댓글 전체 수 조회 쿼리 -->
 	<select id="getCountByBno" resultType="int">
 		<![CDATA[
 			select count(rno) from tbl_reply where bno = #{bno}
 		]]>
 	</select>


ReplyServiceImpl에서 댓글과 댓글 수 처리
단순히 댓글 전체를 보여주는 방식과 달리 댓글의 페이징 처리가 필요한 경우에는 댓글 목록과 함게 전체 댓글의 수를 같이 전달해야만 한다.
ReplyService 인터페이스와 구현 클래스인 ReplyServiceImpl 클래스는 List<ReplyVO>와 댓글의 수를 같이 전달할 수 있는 구조로 변경

예제) org.zerock.domain패키지에 ReplyPageDTO 클래서 생성
package org.zerock.domain;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;

@Data
@AllArgsConstructor
@Getter
public class ReplyPageDTO {

	private int replyCnt;
	private List<ReplyVO> list;
}

ReplyPageDTO는 객체 생성 시에 편리하도록 @AllArgsConstructor를 이용해서 replyCnt와 list를 생성자의 파라미터로 처리한다.
ReplyService 인터페이스와 ReplyServiceImpl 클래스에는 ReplyPageDTO를 반환하는 메서드를 추가한다.

예제) ReplyService 인터페이스에 getListPage 메서드 추가

public ReplyPageDTO getListPage(Criteria cri, Long bno);

예제) ReplyServiceImpl에 getListPage 메서드 추가

	@Override
	public ReplyPageDTO getListPage(Criteria cri, Long bno) {
	
		
		return new ReplyPageDTO(
				mapper.getCountByBno(bno),
				mapper.getListWithPaging(cri, bno));
	}

ReplyController 수정
ReplyController에서는 ReplyService에 새롭게 추가된 getListPage()를 호출하고 데이터를 전송하는 형태로 수정한다.

예제) ReplyController getList()메서드 수정

	@GetMapping(value = "pages/{bno}/{page}",
			produces = {
					MediaType.APPLICATION_XML_VALUE,
					MediaType.APPLICATION_JSON_UTF8_VALUE})
	public ResponseEntity<ReplyPageDTO> getList(
			@PathVariable("page") int page,
			@PathVariable("bno") Long bno){
		
		log.info("getList........ ");
		Criteria cri = new Criteria(page,10);
		
		log.info("get Reply List bno: " + bno);
		log.info("cri: " + cri);
		
		return new ResponseEntity<ReplyPageDTO>(service.getListPage(cri, bno), HttpStatus.OK);
	}

기존과 동일하게 JSON 데이터를 전송하지만 ReplyPageDTO 객체를 JSON으로 전송하게 되므로, 
특정 게시물의 댓글 목록을 조회하면 'replyCnt'와 'list'라는 이름의 속성을 가는 JSON 문자열이 전송된다.


댓글 페이지의 화면 처리
댓글의 화면 처리는 다음과 같은 방식으로 처리한다.
- 게시물을 조회하는 페이지에 들어오면 기본적으로 가장 오래된 댓글들을 가져와서 1페이지에 보여준다.
- 1페이지의 게시물을 가져올 대 해당 게시물의 댓글의 숫자를 파악해서 댓글의 페이지 번호를 출력한다.
- 댓글이 추가되면 댓글의 숫자만을 가져와서 최종 페이지를 찾아서 이동한다.
- 댓글의 수정과 삭제 후에는 다시 동일 페이지를 호출한다.

댓글 페이지 계산과 출력
Ajax로 가져오는 데이터가 replyCnt와 list라는 데이터로 구성되므로 이를 처리하는 reply.js의 내용 역시 이를 처리하는 구조로 수정한다.

예제) reply.js getList() 메소드 수정
	function getList(param, callback, error){
		
		var bno = param.bno;
		var page = param.page || 1;
		
			$.getJSON("/replies/pages/" + bno + "/" + page + ".json",
				function(data){
					if(callback){
						//callback(data); 댓글 목록만 가져오는 경우
						callback(data.replyCnt, data.list); // 댓글 숫자와 목록을 가져오는 경우
					}
				}).fail(function(xhr, status, err){
				if(error){
					error();
					}
			});
	
	}

기존에 비해서 변경되는 부분은 callback 함수에 해당 게시물의 댓글 수(replyCnt)와 페이지에 해당하는 댓글 데이터를 전달하도록 하는 부분이다.
화면에 대한 처리는 get.jsp 내에서 이루어진다.

reply.js를 이용해서 댓글의 페이지를 호출하는 부분은 showList 함수이므로 페이지 번호를 출력하도록 수정한다.

예제) get.jsp showList() 수정

			function showList(page) {
				replyService.getList({bno:bnoValue, page:page}, 
				function(replyCnt,list){
					
					console.log("replyCnt: " + replyCnt);
					console.log("list: " + list);
					console.log("page: " + page);
					console.log(list);
					
					if (page == -1) {
						pageNum = Math.ceil(replyCnt/10.0);
						showList(pageNum);
						return;
					}
					
					var str = "";
					if (list == null || list.length == 0) {
						replyUL.html("");
						
						return;
					}
					for (var i = 0, len = list.length||0; i < len; i++) {
						
						str +="<li class='left clearfix' data-rno='"+ list[i].rno+"'>";
						str +="	<div> <div class='header'><strong class='primary-font'>"
						+list[i].replyer+"</strong>";
						str +="	<small class='pull-right text-muted'>" + replyService.displayTime(list[i].
						replyDate)+"</small></div>";
						str +="	<p>" +list[i].reply+"</p></div></li>";
						
					}
					
					replyUL.html(str);
					//p.441 추가
					showReplyPage(replyCnt);
				}); //end function

showList() 함수는 파라미터로 전달되는 page 변수를 이용해서 원하는 댓글 페이지를 가져오게 된다.
이때 만일 page 번호가 '-1'로 전달되면 마지막 페이지를 찾아서 다시 호출하게 된다.
사용자가 새로운 댓글을 추가하면 showList(-1);을 호출하여 우선 전체 댓글의 숫자를 파악하게 한다.
이 후에 다시 마지막 페이지를 호출해서 이동시키는 방식으로 동작시킨다.
이러한 방식은 여러 번 서버를 호출해야 하는 단점이 있기는 하지만, 댓글의 등록 행위가 댓글 조회나 페이징에 비해서 적기 때문에 심각한 문제는 아니다.
(책은 등록후 맨 끝페이지로 가지만 나는 등록하면 1페이지로 보냄)

예제) modalRegisterBtn 클릭 이벤트 수정
	modalRegisterBtn.on("click", function (e) {
				
				var reply = {
						reply : modalInputReply.val(),
						replyer : modalInputReplyer.val(),
						bno : bnoValue
				};
				
				replyService.add(reply, function (result) {
					
					alert(result);
					
					modal.find("input").val("");
					modal.modal("hide");
					
					//showList(1);
					showList(1);
				});
			});

댓글은 화면상에서 댓글이 출력되는 영역의 아래쪽에 <div class='panel-footer'>를 하나 추가하고,
<div>의 아래쪽에 추가한다.

예제) get.jsp 태그 추가

<div class="panel-body">
	<ul class="chat">
		                  	
	</ul>
		                
</div>
<!-- /end panel-body -->		            
<!-- .chat-panel 추가 -->		            
<div class="panel-footer">		            
		            
</div>

추가된 <div class='panel-footer'>에 댓글 페이지 번호를 출력하느 로직은 showReplyPage()는 아래와 같다.

예제) showReplyPage() 생성

<script type="text/javascript">

	var pageNum = 1;
	var replyPageFooter = $(".panel-footer");
	var replyPageUl = $(".pagination");
	
	function showReplyPage(replyCnt) {
		
		var endNum = Math.ceil(pageNum / 10.0) * 10;
		var startNum = endNum - 9;
		
		var prev = startNum != 1;
		var next = false;
		
		if (endNum * 10 >= replyCnt) {
			endNum = Math.ceil(replyCnt/10.0);
		}
		
		if (endNum * 10 < replyCnt) {
			next = true;
		}
		
		var str = "<ul class='pagination pull-right'>";
		
		if (prev) {
			str+= "<li class='page-item'><a class='page-link' href='"+(startNum -1)+"'>Previous</a></li>";
		}
		
		
		for (var i = startNum; i <= endNum; i++) {
			
			var active = pageNum == i? "active":"";
			
			str += "<li class='page-item "+active+"'><a class='page-link' href='"+i+"'>"+i+"</a></li>";
		}
		if (next) {
			str += "<li class='page-item'><a class='page-link' href='"+(endNum + 1)+"'>Next</a></li>";
		}
		
		str += "</ul>";
		
		console.log(str);
		
		replyPageFooter.html(str);
		
		
		
	}
</script>

showReplyPage()는 기존에 Java로 작성되는 PageMaker의 JavaScript 버전에 해당한다.
댓글 페이지를 문자열로 구성한 후 <div>의 InnerHtml로 추가한다. 
showList()의 마지막에 페이지를 출력하도록 수정한다.

예제) showList() 추가

				for (var i = 0, len = list.length||0; i < len; i++) {
						
						str +="<li class='left clearfix' data-rno='"+ list[i].rno+"'>";
						str +="	<div> <div class='header'><strong class='primary-font'>"
						+list[i].replyer+"</strong>";
						str +="	<small class='pull-right text-muted'>" + replyService.displayTime(list[i].
						replyDate)+"</small></div>";
						str +="	<p>" +list[i].reply+"</p></div></li>";
						
					}
					
					replyUL.html(str);
					//p.441 추가
					showReplyPage(replyCnt);
				}); //end function

실제로 화면상에는 CSS의 구성으로 인해서 아래쪽에 추가된다.

마지막 처리는 페이지의 번호를 클릭했을 때 새로운 댓글을 가져오도록 하는 부분이다.

예제) get.jsp replyPageFooter 클릭이벤트 처리
		replyPageFooter.on("click","li a", function (e) {
			e.preventDefault();
			console.log("page click");
		
			var targetPageNum = $(this).attr("href");
		
			console.log("targetPageNum : " + targetPageNum);
			
			pageNum = targetPageNum;
			
			showList(pageNum);
		});

댓글의 페이지 번호는 <a> 태그 내에 존재하므로 이벤트 처리에서는 <a> 태그의 기본 동작을 제한하고(preventDefault()) 댓글 페이지 번호를 변경한 후
해당 페이지의 댓글을 가져오도록 한다.

댓글 수정과 삭제

댓글이 페이지 처리되면 댓글의 수정과 삭제 시에도 현재 댓글이 포함된 페이지로 이동하도록 수정
예제) get.jsp 수정과 삭제 showList()호출로 현재 댓글이 포함된 페이지로 이동하도록 수정
// 댓글의 수정/ 삭제 이벤트 처리
		
		modalModBtn.on("click", function (e) {
		
			var reply = {rno:modal.data("rno"), reply: modalInputReply.val()};
			
			replyService.update(reply, function (result) {
				
				
				alert(result);
				modal.modal("hide");
				//showList(1); // p.422 수정으로 주석처리함
				showList(pageNum);
			});
		});
		
		modalRemoveBtn.on("click", function (e) {
		
			var rno = modal.data("rno");
			
			replyService.remove(rno, function (result) {
				
				
				alert(result);
				modal.modal("hide");
				//showList(1); // p.422 수정으로 주석처리함
				showList(pageNum);
			});
		});

기존과 달리진 점은 showList()를 호출할 때 현재 보고 있는 댓글 페이지의 번호를 호출한다는 점이다.
브라우저에서 댓글의 등록, 수정, 삭제 작업은 모두 페이지 이동을 하게 된다.
